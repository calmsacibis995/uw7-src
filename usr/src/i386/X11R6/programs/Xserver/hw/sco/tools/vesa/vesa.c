/*
 *	@(#)vesa.c	11.2	11/12/97	11:33:30
 *
 *	Copyright (C) The Santa Cruz Operation, 1991-1997.
 *	This Module contains Proprietary Information of
 *	The Santa Cruz Operation, and should be treated as Confidential.
 */
/*
 * NAME:
 * 	vesa - queries vesa information from the installed graphics
 *	adapter.
 *
 * SYNOPSYS:
 *	vesa [-v] [-m] [-t [-i]] [-d depth] [-l model] [-w width] 
 *		[-h height] [modes] 
 *
 *	'vesa' call various int10 video bios routines to query information
 *	about the installed graphics adapter.  Without any arguments,
 *	'vesa' returns 0 if information can be queried from the
 *	installed adapter (i.e. the bios support the VBE extensions).
 *	Otherwise it returns 1.
 *
 *	The output generated by vesa is in tcl format.
 *
 * FLAGS:
 *	-v : print vesa system information
 *	-m : print mode information
 *	-t : verify that the all the modes execute without
 *		errors.  The test can be limited to a subset of
 *		the supported modes by appending a list of
 *		modes (e.g. 0x101 0x106) with the -t arg.
 *	-i : don't have to be on /dev/console to verify modes.
 *	-d depth : limit search to modes of specified depth.
 *	-m model : limit search to modes of specified memory model.
 *	-w width : limit search to modes with X resolution >= specified width
 *	-h height : limit search to modes with Y resolution >= specified height
 *
 * RETURN STATUS:
 *	== 0 (command == 'vesa') the installed adapter supports 
 *		VBE extensions
 *      == 0 (command == 'vesa -t [modes]') the installed adapter
 *		supports the VBE extensions and the specified modes
 *		were executed without errors.
 *	== 1 if the installed adapter doesn't support the VBE extensions
 *	== 2 error while querying vesa system information
 *      == 3 error while querying vesa mode information
 *      == 4 error while testing modes
 *      == 5 unable to test modes.  Need to be on console in a character
 *		mode screen.
 *	== 99 any other error contidition
 *
 * NOTES:
 *
 */
/*
 *	SCO MODIFICATION HISTORY
 *
 *	S001	Wed Nov 12 09:40:14 PST 1997	hiramc@sco.COM
 *	- no more v86.h locally, now using <sys/v86bios.h>
 *	S000	Mon Feb 17 14:10:03 PST 1997	kylec@sco.com
 *	-  Create
 *
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/param.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <locale.h>
#include <sys/kd.h>
#include <sys/vt.h>

#include <sys/v86bios.h>	/*	S001	*/

/* VBE - SVGA information - function 4f00 */
typedef struct 
{

  uchar_t	signature[4];
  ushort_t	version;
  ushort_t	oemstring[2];
  uchar_t	capabilities[4];
  ushort_t	vidmodes[2];
  ushort_t	memory;
  
  /* Added for VBE 2.0 */
  ushort_t	oem_software_rev;
  ushort_t 	oem_vendor[2];
  ushort_t 	oem_product[2];
  ushort_t	oem_product_rev[2];

  uchar_t	reserved[222];
  uchar_t	oem_data[256];  /* data area for oem strings */

} SVGA_SysInfo;

/* VBE - function 0x4f01, returns SVGA mode information */
typedef struct 
{

  ushort_t	mode_attributes;
  uchar_t	winA_attributes;
  uchar_t	winB_attributes;
  ushort_t	win_granularity;
  ushort_t	win_size;
  ushort_t	winA_segment;
  ushort_t	winB_segment;
  ushort_t	win_func_ptr[2];
  ushort_t	bytes_per_scan_line;

  /* optional fields */
  ushort_t	x_resolution;
  ushort_t	y_resolution;
  uchar_t	x_char_size;
  uchar_t	y_char_size;
  uchar_t	number_of_planes;
  uchar_t	bits_per_pixel;
  uchar_t	number_of_banks;
  uchar_t	memory_model;
  uchar_t	bank_size;
  uchar_t	number_of_image_pages;
  uchar_t	reserver_for_page_function;
  
  /* Direct color fields */
  uchar_t	red_mask_size;
  uchar_t	red_field_position;
  uchar_t	green_mask_size;
  uchar_t	green_field_position;
  uchar_t	blue_mask_size;
  uchar_t	blue_field_position;
  uchar_t	rsvd_mask_size;
  uchar_t	rsvd_field_position;
  uchar_t	direct_color_mode_info;

  /* Mandatory information for VBE 2.0 */
  ushort_t	phys_base_ptr[2];
  ushort_t	off_screen_mem_offset[2];
  ushort_t	off_screen_mem_size;
  
  uchar_t	reserved[206];

} SVGA_ModeInfo;

/* Command line args */
#define MAX_ARG			256
typedef struct _VESA_Args {

  int print_vesainfo;
  int print_modeinfo;
  int test_modes;
  int ignore_err;
  int min_width;
  int min_height;
  
  int depthCnt;
  int depth[MAX_ARG];

  int memModelCnt;
  int memModel[MAX_ARG];

  int svgaModeCnt;
  ushort_t svgaMode[MAX_ARG];

} VESA_Args;


/* VBE - function 0x4f01 defines for 'mode_attributes' */
#define CAN_INITIALIZE		0x001 /* D0 */
#define HAS_EXTENDED_INFO	0x002 /* D1 */
#define HAS_OUTPUT_FUNCS	0x004 /* D2 */
#define IS_COLOR_MODE		0x008 /* D3 */
#define IS_GRAPHICS_MODE	0x010 /* D4 */
#define IS_VGA_COMPATIBLE	0x020 /* D5 */
#define WINDOWED_FRAME_BUFFER   0x040 /* D6 */
#define LINEAR_FRAME_BUFFER	0x080 /* D7 */

/* misc defines */
#define ADDRESS(seg,off)	(((seg) << 4) + (off))
#define SEGMENT(x)		((x) >> 4)
#define OFFSET(x)		((x) & 0xFF) 

#define VBE			0x4F /* Video Bios Extension */
#define VBE_OK			0x00
#define VBE_SVGA_SYS_INFO	0x00
#define VBE_SVGA_MODE_INFO	0x01
#define VBE_SVGA_SET_MODE	0x02
#define VBE_SVGA_QUERY_MODE	0x03
#define VBE_SVGA_BANK_SWITCH	0x05
#define VBIOS			0x10 /* Video Bios Interrupt */

/* Exit status */
#define EXIT_NO_ERROR		0
#define EXIT_NOT_VESA		1
#define EXIT_QUERY_SYSTEM_ERROR	2
#define EXIT_QUERY_MODE_ERROR	3
#define EXIT_TEST_MODE_ERROR	4
#define EXIT_NOT_ON_CONSOLE	5
#define EXIT_INVALID_ARG	6
#define EXIT_ERROR		99



unsigned short
VBEQueryCurrentMode(int fd_v86)
{
  intregs_t regs;

  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_INT16;
  regs.entry.intval = VBIOS;
  regs.eax.byte.ah = VBE;
  regs.eax.byte.al = VBE_SVGA_QUERY_MODE;

  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error ||
      (regs.eax.byte.al != VBE) || (regs.eax.byte.ah != VBE_OK))
    {
      return (0);
    }
  else
    {
      return (regs.ebx.word.bx);
    }

}

unsigned short
VBESetMode(int fd_v86, unsigned short mode)
{
  intregs_t regs;

  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_INT16;
  regs.entry.intval = VBIOS;
  regs.eax.byte.ah = VBE;
  regs.eax.byte.al = VBE_SVGA_SET_MODE;
  regs.ebx.word.bx = mode;
  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error ||
      (regs.eax.byte.al != VBE) || (regs.eax.byte.ah != VBE_OK))
    {
      return (0);
    }
  else
    {
      return (mode);
    }
}

unsigned short
VBEBankSwitch(int fd_v86, unsigned short seg, unsigned short off)
{
  intregs_t regs;

  /* Set a bank */
  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_CALL;
  regs.entry.farptr.v86_cs = seg;
  regs.entry.farptr.v86_off = off;
  regs.eax.byte.ah = VBE;
  regs.eax.byte.al = VBE_SVGA_BANK_SWITCH;
  regs.ebx.byte.bh = 0;         /* set */
  regs.edx.word.dx = 0;         /* bank # */

  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error)
    {
      return(0);
    }

  /* Query */
  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_CALL;
  regs.entry.farptr.v86_cs = seg;
  regs.entry.farptr.v86_off = off;
  regs.eax.byte.ah = VBE;
  regs.eax.byte.al = VBE_SVGA_BANK_SWITCH;
  regs.ebx.byte.bh = 1;         /* query */
  regs.edx.word.dx = 0;         /* bank # */

  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error ||
      (regs.edx.word.dx != 0))
    {
      return(0);
    }

  return(1);

}


#define V86BIOS_MISC            (MMU_PAGESIZE/2) /* misc data */

int
VBEQuerySysInfo(int fd_v86, SVGA_SysInfo *info)
{
  SVGA_SysInfo *svgaSysInfo = (SVGA_SysInfo *)V86BIOS_MISC;
  intregs_t regs;

  /* Query SVGA Sys info */
  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_INT16;
  regs.entry.intval = VBIOS;
  regs.eax.byte.ah = VBE;
  regs.eax.byte.al = VBE_SVGA_SYS_INFO;

  /* svga system information data returned at V86BIOS_MISC */
  regs.es = SEGMENT(V86BIOS_MISC);
  regs.edi.word.di = OFFSET(V86BIOS_MISC);

 /* query VBE2.0 info */
  strcpy((char *)svgaSysInfo->signature, (const char *)"VBE2");

  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error ||
      (regs.eax.byte.al != VBE) || (regs.eax.byte.ah != VBE_OK))
    {
      return(0);
    }
  else
    {
      if (info)
        {
          memcpy((void*)info, (const void *)svgaSysInfo, sizeof(SVGA_SysInfo));
        }
      return(V86BIOS_MISC);
    }
}

int
VBEQueryModeInfo(int fd_v86, ushort_t mode, SVGA_ModeInfo *info)
{
  intregs_t regs;

  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_INT16;
  regs.entry.intval = VBIOS;
  regs.eax.byte.ah = VBE;
  regs.eax.byte.al = VBE_SVGA_MODE_INFO;
  regs.ecx.word.cx = mode;
  regs.es = SEGMENT(V86BIOS_MISC);
  regs.edi.word.di = OFFSET(V86BIOS_MISC);

  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error ||
      (regs.eax.byte.al != VBE) || (regs.eax.byte.ah != VBE_OK))
    {
      return (0);
    }
  else
    {
      if (info)
        memcpy((void*)info, (const void *)V86BIOS_MISC, sizeof(SVGA_ModeInfo));
      return(V86BIOS_MISC);
    }
}

unsigned short
VGASetMode(int fd_v86, unsigned short vga_mode)
{
  intregs_t regs;

  memset((void*)&regs, 0, sizeof(regs));
  regs.type = V86BIOS_INT16;
  regs.entry.intval = VBIOS;
  regs.eax.byte.al = vga_mode;
  if ((ioctl(fd_v86, V86BIOS_CALL, &regs) < 0) || regs.error)
    {
      return (0);
    }
  else
    {
      return (vga_mode);
    }
}

void
PrintModeInfo (mode, modeInfo)
     int mode;
     SVGA_ModeInfo *modeInfo;

{
  printf("\nset MODE(%dx%d-%d) {\n",
	 modeInfo->x_resolution,
	 modeInfo->y_resolution,
	 modeInfo->bits_per_pixel);
  printf("\t{VESA_MODE {%#X}}\n",
	 mode);
  printf("\t{WIN_GRANULARITY {%#X}}\n",
	 modeInfo->win_granularity);
  printf("\t{WIN_SIZE {%#X}}\n",
	 modeInfo->win_size);
  printf("\t{WIN_A_SEGMENT {%#X}}\n",
	 modeInfo->winA_segment);
  printf("\t{WIN_A_PERMS {%#X}}\n",
	 modeInfo->winA_attributes & 0x7);
  printf("\t{WIN_B_SEGMENT {%#X}}\n",
	 modeInfo->winB_segment);
  printf("\t{WIN_B_PERMS {%#X}}\n",
	 modeInfo->winB_attributes & 0x7);
  printf("\t{WIN_FUNC_PTR {{SEGMENT {%#X}} {OFFSET {%#X}}}}\n",
	 modeInfo->win_func_ptr[1],
	 modeInfo->win_func_ptr[0]);
  printf("\t{PIXBYTES {%d}}\n", /* bytes per scanline %d */
	 modeInfo->bytes_per_scan_line,
	 modeInfo->bytes_per_scan_line);
  printf("\t{PIXWIDTH {%d}}\n", /* x resolution */
	 modeInfo->x_resolution);
  printf("\t{PIXHEIGHT {%d}}\n", /* y resolution */
	 modeInfo->y_resolution);
  printf("\t{PIXPLANES {%d}}\n", /* number of planes */
	 modeInfo->number_of_planes);
  printf("\t{PIXBITS {%d}}\n", /* bits per pixel */
	 modeInfo->bits_per_pixel);
  printf("\t{DEPTH {%d}}\n", /* bits per pixel */
	 modeInfo->bits_per_pixel);
  printf("\t{BANKS {%d}}\n", /* number of banks */
	 modeInfo->number_of_banks);
  printf("\t{MEMORY_MODEL {%d}}\n", /* VBE memory model */
	 modeInfo->memory_model);
  printf("\t{BANK_SIZE {%d}}\n", /* bank size */
	 modeInfo->bank_size);

  if (modeInfo->mode_attributes & LINEAR_FRAME_BUFFER)
    printf("\t{FRAME_BUFFER {{SEGMENT {%#X}} {OFFSET {%#X}}}}\n",
	   modeInfo->phys_base_ptr[1],
	   modeInfo->phys_base_ptr[0]);
  else
    printf("\t{FRAME_BUFFER {{SEGMENT {0}} {OFFSET {0}}}}\n");

  printf("}\n");
}


void
ProcessCommandLine ( argc, argv, vesaArgs )
     int	argc;
     char	*argv[];
     VESA_Args  *vesaArgs;
{
  int i, j, idx;

  vesaArgs->print_vesainfo = 0;
  vesaArgs->print_modeinfo = 0;
  vesaArgs->test_modes = 0;
  vesaArgs->ignore_err = 0;
  vesaArgs->min_width = 0;
  vesaArgs->min_height = 0;
  vesaArgs->depthCnt = 0;
  vesaArgs->depth[0] = 0;
  vesaArgs->memModelCnt = 0;
  vesaArgs->memModel[0] = 0;
  vesaArgs->svgaModeCnt = 0;
  vesaArgs->svgaMode[0] = 0;


  for ( i = 1; i < argc; i++ )
    {
       if ( strcmp(argv[i], "-d") == 0)
	{
	  i++;
          idx = vesaArgs->depthCnt;
          if ((i < argc) && (idx < MAX_ARG))
            {
              vesaArgs->depth[idx] = (int)strtol(argv[i], 0, 0);
              vesaArgs->depthCnt = idx + 1;
            }
 	  if (idx >= MAX_ARG)
	    exit(EXIT_INVALID_ARG);
	}

      else if ( strcmp(argv[i], "-l") == 0)
	{
	  i++;
          idx = vesaArgs->memModelCnt;
          if ((i < argc) && (idx < MAX_ARG))
            {
              vesaArgs->memModel[idx] = (int)strtol(argv[i], 0, 0);
              vesaArgs->memModelCnt = idx + 1;
            }
 	  if (idx >= MAX_ARG)
	    exit(EXIT_INVALID_ARG);
	}

      else if ( strcmp(argv[i], "-w") == 0)
	{
	  i++;
          if (i < argc)
            {
              vesaArgs->min_width = (int)strtol(argv[i], 0, 0);
            }
	}

      else if ( strcmp(argv[i], "-h") == 0)
	{
	  i++;
          if (i < argc)
            {
              vesaArgs->min_height = (int)strtol(argv[i], 0, 0);
            }
	}

      else if ( argv[i][0] == '-' )
	{
	  for (j=1; argv[i][j]; j++)
	    {
	      switch (argv[i][j])
		{
		case 'v': 
		  vesaArgs->print_vesainfo = 1;
		  break;
		case 'm':
		  vesaArgs->print_modeinfo = 1;
		  break;
		case 't':
		  vesaArgs->test_modes = 1;
		  break;
		case 'i':
		  vesaArgs->ignore_err = 1;
		  break;
		default:
		  exit(EXIT_INVALID_ARG);
		  break;
		}
	    }
	}
      
      else
 	{
          idx = vesaArgs->svgaModeCnt;
          if (idx < MAX_ARG)
            {
              vesaArgs->svgaMode[idx] = (ushort_t)strtol(argv[i], 0, 0);
              if (vesaArgs->svgaMode[idx] != 0)
                vesaArgs->svgaModeCnt = idx + 1;
	      else
		exit(EXIT_INVALID_ARG);
            }
 	  else 
	    exit(EXIT_INVALID_ARG);
        }
    }
}


main (int argc, char **argv)
{
  intregs_t regs;
  int fd_mem, fd_console, fd_v86;
  int console_mode;
  unsigned char svgaFunction;
  SVGA_SysInfo svgaSysInfo;
  int c, i;
  ushort_t *mode;
  int vbe = 0;
  unsigned short initial_vesa_mode = 0;
  int status = EXIT_NO_ERROR;
  VESA_Args vesaArgs;

  setlocale(LC_ALL, "");
  ProcessCommandLine(argc, argv, &vesaArgs);
 
  /* Init some stuff */
  fd_mem = open("/dev/pmem", O_RDWR);
  if (fd_mem < 0)
    {
      perror("/dev/pmem");
      exit(EXIT_ERROR);
    }

  if ((caddr_t)(-1) == (caddr_t)mmap(( caddr_t)0, 0x100000,
                                     PROT_READ|PROT_WRITE,
                                     MAP_SHARED|MAP_FIXED,
                                     fd_mem, 0))
    {
      perror("mmap(0)");
      exit(EXIT_ERROR);
    }


  fd_v86 = open(V86BIOS_DEVICE, O_RDWR);
  if (fd_v86 == -1)
    {
      perror(V86BIOS_DEVICE);
      exit(EXIT_ERROR);
    }

  if (!VBEQuerySysInfo(fd_v86, &svgaSysInfo))
    {
      printf("set VESA {0}\n");
      exit(EXIT_NOT_VESA);
    }

  if (vesaArgs.test_modes)
    {
      fd_console = open("/dev/video", O_RDWR);
      if ((fd_console < 0) && !vesaArgs.ignore_err)
        {
          perror("/dev/video");
          exit(EXIT_NOT_ON_CONSOLE);
        }
      console_mode = ioctl(fd_console, CONS_GET, 0);
    }

  /* Display OEM ID string + VESA version */
  if (!strncmp((char*)svgaSysInfo.signature, "VESA", 4))
    {
      vbe = svgaSysInfo.version >> 8; /* VBE version */

      if (vesaArgs.print_vesainfo)
        {
          printf("set VESA {1}\n"
                 "set VBE {%d.%d}\n"
                 "set MEMORY {%#X}\n"
                 "set OEM {%s}\n",
                 svgaSysInfo.version >> 8,
                 svgaSysInfo.version & 0xFF,
                 svgaSysInfo.memory * 0x10000,
                 ADDRESS(svgaSysInfo.oemstring[1],
                         svgaSysInfo.oemstring[0]));


          if (vbe >= 2) /* if VBE >= 2.0 */
            printf("set OEM_SOFTWARE_REV {%d.%d}\n"
                   "set OEM_VENDOR_NAME {%s}\n"
                   "set OEM_PRODUCT_NAME {%s}\n"
                   "set OEM_PRODUCT_REV {%s}\n",
                   svgaSysInfo.oem_software_rev >> 8,
                   svgaSysInfo.oem_software_rev & 0xFF,
                   ADDRESS(svgaSysInfo.oem_vendor[1],
                           svgaSysInfo.oem_vendor[0]),
                   ADDRESS(svgaSysInfo.oem_product[1],
                           svgaSysInfo.oem_product[0]),
                   ADDRESS(svgaSysInfo.oem_product_rev[1],
                           svgaSysInfo.oem_product_rev[0]));

        }

      /* Query Supported modes */
      mode = (ushort_t*)ADDRESS(svgaSysInfo.vidmodes[1], svgaSysInfo.vidmodes[0]);

      if (!vesaArgs.svgaModeCnt)
        {
          for (i=0; *mode != 0xFFFF; mode++)
            {
              vesaArgs.svgaMode[i++] = *mode;
            }
          vesaArgs.svgaModeCnt = i;
        }

      for (i=0; (i < vesaArgs.svgaModeCnt) &&
	     (vesaArgs.print_modeinfo | vesaArgs.test_modes); i++)
        {
          SVGA_ModeInfo modeInfo;
          
          if (!VBEQueryModeInfo(fd_v86, vesaArgs.svgaMode[i], &modeInfo))
            {
              fprintf(stderr, "%#X\n", vesaArgs.svgaMode[i]);
              status = EXIT_QUERY_MODE_ERROR;
              break;            /* were done */
            }

	  if (vesaArgs.depthCnt)
	    {
	      int j;
	      for (j=0; j<vesaArgs.depthCnt; j++)
		if (vesaArgs.depth[j] == modeInfo.bits_per_pixel)
		  break;
	      if (j >= vesaArgs.depthCnt)
		continue;
	    }

	  if (vesaArgs.memModelCnt)
	    {
	      int j;
	      for (j=0; j<vesaArgs.memModelCnt; j++)
		if (vesaArgs.memModel[j] == modeInfo.memory_model)
		  break;
	      if (j >= vesaArgs.memModelCnt)
		continue;
	    }
          
          if ((vesaArgs.min_width > modeInfo.x_resolution) ||
              (vesaArgs.min_height > modeInfo.y_resolution))
            {
              continue;
            }

          if (vesaArgs.test_modes)
            {
              if ((modeInfo.mode_attributes &
                   (CAN_INITIALIZE|IS_GRAPHICS_MODE|HAS_EXTENDED_INFO)) !=
                  (CAN_INITIALIZE|IS_GRAPHICS_MODE|HAS_EXTENDED_INFO))
                {
                  fprintf(stderr, "%#X\n", vesaArgs.svgaMode[i]);
                  status = EXIT_TEST_MODE_ERROR;
                }
              else if (!VBESetMode(fd_v86, vesaArgs.svgaMode[i]) ||
                       ((vbe < 2) &&
                        !VBEBankSwitch(fd_v86,
                                       modeInfo.win_func_ptr[1],
                                       modeInfo.win_func_ptr[0])))

                {
                  modeInfo.mode_attributes &= ~CAN_INITIALIZE;
                  fprintf(stderr, "%#X\n", vesaArgs.svgaMode[i]);
                  status = EXIT_TEST_MODE_ERROR;
                }
            }

          if (vesaArgs.print_modeinfo &&
	      ((modeInfo.mode_attributes &
               (CAN_INITIALIZE|IS_GRAPHICS_MODE|HAS_EXTENDED_INFO)) ==
              (CAN_INITIALIZE|IS_GRAPHICS_MODE|HAS_EXTENDED_INFO)))
            {
	      PrintModeInfo(vesaArgs.svgaMode[i], &modeInfo);
            }
        }
    }
  else
    {
      printf("\nset VESA {0}");
      status = EXIT_NOT_VESA;
    }     

  /* Cleanup */
  if (vesaArgs.test_modes)
    {
      VGASetMode(fd_v86, 0x3);
      if (fd_console >= 0)
        ioctl(fd_console, MODESWITCH | console_mode, 0);
    }

  close(fd_v86);
  close(fd_mem);
  close(fd_console);

  exit(status);

}
