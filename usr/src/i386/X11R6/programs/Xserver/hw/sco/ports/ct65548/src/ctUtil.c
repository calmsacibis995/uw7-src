/*
 *	@(#)ctUtil.c	11.1	10/22/97	12:34:14
 *	@(#) ctUtil.c 58.1 96/10/09 
 *
 *	Copyright (C) The Santa Cruz Operation, 1991-1997.
 *	The Santa Cruz Operation, and should be treated as Confidential.
 *	This Module contains Proprietary Information of
 *	The Santa Cruz Operation, and should be treated as Confidential.
 *
 * The information in this file is provided for the exclusive use of the
 * licensees of The Santa Cruz Operation, Inc.  Such users have the right 
 * to use, modify, and incorporate this code into other products for purposes 
 * authorized by the license agreement provided they include this notice 
 * and the associated copyright notice with any such product.  The 
 * information in this file is provided "AS IS" without warranty.
 */
/*
 * Copyright (C) 1994 Double Click Imaging, Inc.
 *
 *
 *      SCO     Modifications
 *
 *      S000    Wed Mar 01              1995    rogerv@sco.COM
 *      SCO-59-5741: Turn off debug messages. 
 *
 */

#ident "@(#) $Id: ctUtil.c 58.1 96/10/09 "

#include <varargs.h>

#include "X.h"
#include "scrnintstr.h"
#include "windowstr.h"

#include "ctDefs.h"
#include "ctMacros.h"

#define CT_BITBLT_SANITY_CHECK
/* #define CT_BITBLT_DEBUG */

/*
 * NOTE: This static structure doesn't lend itself to screen switching! The 
 * BitBlt engine should be synch'd and the pointer should be reset upon every
 * screen switch. This is a hack; but I don't want to pass the pointer to the
 * CT_WAIT_FOR_IDLE() macro that calls CT(BitBltSync)() if it times out.
 */
static struct {
	unsigned long	*fbPointer;
	char		location[132+1];
	char		msg[132+1];
	unsigned long	offset;
	unsigned long	pattern;
	unsigned long	bg;
	unsigned long	fg;
	unsigned long	control;
	unsigned long	source;
	unsigned long	dest;
	unsigned long	cmd;
	Bool		valid;
} ctBitBltInfo;

void
CT(BitBltInit)(pScreen)
ScreenPtr pScreen;
{
	CT(PrivatePtr) ctPriv = CT_PRIVATE_DATA(pScreen);

#ifdef DEBUG_PRINT
	ErrorF("BitBltInit(): ptr=0x%08x\n", ctPriv->fbPointer);
#endif /* DEBUG_PRINT */

	ctBitBltInfo.fbPointer = (unsigned long *)ctPriv->fbPointer;
}

void
CT(BitBltScreenSwitch)(pScreen)
ScreenPtr pScreen;
{
	CT(PrivatePtr) ctPriv = CT_PRIVATE_DATA(pScreen);

#ifdef DEBUG_PRINT
	ErrorF("BitBltScreenSwitch(): ptr=0x%08x\n", ctPriv->fbPointer);
#endif /* DEBUG_PRINT */

	ctBitBltInfo.fbPointer = (unsigned long *)ctPriv->fbPointer;
}

void
CT(BitBltInfoReset)()
{
	ctBitBltInfo.valid = FALSE;
}

void
CT(BitBltSync)()
{
	int count = 1;

#ifdef DEBUG_PRINT
	ErrorF("BitBltSync(): ptr=0x%08x\n", ctBitBltInfo.fbPointer);
#endif /* DEBUG_PRINT */

	while (CT_IS_BUSY()) {
#ifdef CT_BITBLT_DEBUG
		ErrorF("Wait DR04[20]: count=%d\n", count);
#endif /* CT_BITBLT_DEBUG */
		*ctBitBltInfo.fbPointer = (unsigned long)0x0000000L;
		count++;
	}

#ifdef DEBUG_PRINT
	ErrorF("BitBltSync(): DONE\n");
#endif /* DEBUG_PRINT */
}

void
CT(BitBltTimeoutError)()
{
#ifdef CT_BITBLT_DEBUG
	if (ctBitBltInfo.valid == TRUE) {
		ErrorF("BitBlt timeout generated by %s\n",
			ctBitBltInfo.location);
		ErrorF("%s", ctBitBltInfo.msg);
		ErrorF("DR00:  offset=0x%08x\n", ctBitBltInfo.offset);
		ErrorF("DR01: pattern=0x%08x\n", ctBitBltInfo.pattern);
		ErrorF("DR02:      bg=0x%08x\n", ctBitBltInfo.bg);
		ErrorF("DR03:      fg=0x%08x\n", ctBitBltInfo.fg);
		ErrorF("DR04: control=0x%08x\n", ctBitBltInfo.control);
		ErrorF("DR05:  source=0x%08x\n", ctBitBltInfo.source);
		ErrorF("DR06:    dest=0x%08x\n", ctBitBltInfo.dest);
		ErrorF("DR07:     cmd=0x%08x\n", ctBitBltInfo.cmd);
	} else {
		ErrorF("BitBlt timeout generated: no debugging information\n");
	}
#endif /* CT_BITBLT_DEBUG */
	CT(BitBltSync)();
	FatalError("BitBlt engine timeout\n");
	/* NOTREACHED */
}

void
CT(BitBltDebugF)(va_alist)
va_dcl
{
	char *format;
	va_list args;

	va_start(args);

	format = va_arg(args, char *);

#ifdef CT_BITBLT_DEBUG
	vsprintf(ctBitBltInfo.msg, format, args);
	ErrorF("%s", ctBitBltInfo.msg);
#else /* CT_BITBLT_DEBUG */
	ErrorF(format, args);
#endif /* CT_BITBLT_DEBUG */

	va_end(args);
}

#ifdef CT_BITBLT_DEBUG
void
CT(BitBltDumpRegisters)(cmd, file, line)
unsigned long cmd;
char *file;
int line;
{
	sprintf(ctBitBltInfo.location, "%s: %d", file, line);
	ctBitBltInfo.offset = CT_IND(CT_BLTOFFSET);
	ctBitBltInfo.pattern = CT_IND(CT_BLTSTIP);
	ctBitBltInfo.bg = CT_IND(CT_BLTBG);
	ctBitBltInfo.fg = CT_IND(CT_BLTFG);
	ctBitBltInfo.control = CT_IND(CT_BLTCTRL);
	ctBitBltInfo.source = CT_IND(CT_BLTSRC);
	ctBitBltInfo.dest = CT_IND(CT_BLTDST);
	ctBitBltInfo.cmd = cmd;
	ctBitBltInfo.valid = TRUE;
}
#endif /* CT_BITBLT_DEBUG */

#ifdef CT_BITBLT_SANITY_CHECK
void
CT(BitBltSanityCheck)()
{
	int count = 1;

#define BITBLT_WAIT_VALUE	 1000000

	while (CT_IS_BUSY()) {
		if (count < BITBLT_WAIT_VALUE) {
			/*
			 * Wait for slow processing.
			 */
			count++;
			continue;
		}
		/*
		 * We've waited patiently; now start outputting dwords,
		 * one at a time. When the BitBlt engine is in sync, exit.
		 */
		CT(BitBltTimeoutError)();
		/* NOTREACHED */
	}

#ifdef CT_BITBLT_DEBUG
	CT(BitBltInfoReset)();
#endif /* CT_BITBLT_DEBUG */
}
#endif /* CT_BITBLT_SANITY_CHECK */
