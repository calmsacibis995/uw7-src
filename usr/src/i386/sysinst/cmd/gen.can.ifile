#!/bin/ksh 
#ident	"@(#)gen.can.ifile	15.2	97/12/29"
#
# gen.can.ifile
#
# usage:   gen.can.ifile [ <pkg/ path> [ <setinfo path> ] ]
#
# example:
# 	t=/tmp_mnt/cilantro/gem9/
# 	gen.can.ifile  $t/pkg.v7e           $t/usr/src/i386/set/UnixWare/setinfo
# example:
# 	gen.can.ifile  $t/usr/src/work/pkg  $t/usr/src/i386/set/UnixWare/setinfo
#
# This script is invoked by the 'create_ISL_pkg_data' script.
#
# See NOTEs below.
#
# This script runs an awk program which
# parses    a canned-configuration specification table, and
# generates a canned-configuration 'ifile'.
#
################################################################################
# Input tables:
#
#-------------------------------------------------------------------------------
#--- pkg_table -----------------------------------------------------------------
#
#	The file "pkg_table" contains a table describing individual
#	"packages" and the interdependencies between them.
#	The "pkg_table" file is generated by the script "gen.pkg.table",
#	but can be edited by hand to add missing description fields
#	(described below, at the end of the Input tables section).
#   
#   	To define a PACKAGE (in "pkg_table"), the format is:
#   	      PACKAGE <shortname>
#   	            LABEL <ISL screen item label>
#   	            DESC  <ISL screen descriptive text, line1>
#   	                  <line2...>
#   	            PKGS  <shortnames of PACKAGEs required by this PACKAGE>
#   	The PKGS field is optional.
#
#	Remember that pkg_table is initially generated by "gen.pkg.table".
#	Thus hand-edited changes to the "pkg_table" file will be lost
#	when the script is rerun.
#	Please see that script for NOTE'd areas for improvement.
#
#-------------------------------------------------------------------------------
#--- can_table -----------------------------------------------------------------
#
#	The file "can_table" contains a table describing individual
#	"cans" and "services" and the interdependencies between them.
#	The table is meant to be maintained by hand.
#
#       To define the list of absolutely required packages for installation:
#
#	      REQUIRED_PKGS base ls ... <all on 1 line>
#
#       To define the list of packages that should *never* be installed:
#
#	      FORBIDDEN_PKGS dshm osmp compaq nwsup nwsrv ... <all on 1 line>
#
#          Note:  REQUIRED_PKGS override FORBIDDEN_PKGS.
#
#   	To define a CAN (in "can_table"), the format is:
#
#   	      CAN <shortname (1 line)>
#   	            LABEL <ISL screen item label (1 line)>
#   	            DESC  <ISL screen descriptive text, line1>
#   	                  <line2...>
#   	            PKGS  <shortnames of PACKAGEs comprising this CAN (1 line)>
#   
#   	To define a SERVICE (in "can_table"), the format is:
#
#   	      SERVICE <shortname>
#   	            LABEL <ISL screen item label>
#   	            DESC  <ISL screen descriptive text, line1>
#   	                  <line2...>
#   	            PKGS  <shortnames of PACKAGEs comprising this SERVICE>
#
#     Note:  If you specify no PKGS, or if none of the PKGS listed
#            has an entry in the pkg_table file, then the CAN/SERVICE
#            will not appear on the ISL 'services' screen.
#
#-------------------------------------------------------------------------------
#--- can_desc.* ----------------------------------------------------------------
#
#	The files 
#		  can_desc.fr  can_desc.de  can_desc.es  can_desc.ja ...
#	contain translated versions of DESCription field
#	of each CAN and SERVICE defined in the "can_table" file.
#	As an example, "can_desc.fr" might contain:
#	     CAN <untranslated shortname #1>
#	     French deescription of zee first can.
#	     2nd line of the French deescription of zee first can.
#	     CAN <untranslated shortname #2>
#	     ...
#
#	These translated descriptions override the DESC fields in the can_table
#	ONLY IF the user has chosen to install in a foreign language for which
#	a "can_desc.$LANG" file existed at the time this script was run.
#   
################################################################################
# Output canned-configuration ifile:
#
#	The awk program creates the file "can_ifile"
#	which contains shell variable assignments.
#
#	The can_ifile is separate from the main ifile because
#	the ivar get" mechanism cannot handle multi-line (DESC) values.
#
#	can_ifile is dotted in by ISL UI modules that need to present choices
#	of cans, services and packages.
#
#	These modules will set the INSTPKGS ifile variable to contain
#	a list of all packages chosen by the user.
#
################################################################################

pkg_home=$ROOT/$SPOOL
[ -n "$1" ] && pkg_home="$1"
setinfo=$pkg_home/../usr/src/work/set/UnixWare/setinfo
[ -n "$2" ] && setinfo="$2"

# The input files currently have no leading paths, so they must exist in ./.
can_table=can_table	# hand-edited
can_desc=can_desc	# hand-edited
pkg_table=pkg_table	# created by gen.pkg.table
pkg_sizes=pkg_sizes	# created by gen.pkg.sizes

# The final output file, $out, is mv'd from /tmp by the
# create_ISL_pkg_data script.
tmp=/tmp/can_ifile.tmp
out=/tmp/can_ifile

# NOTE:	The build process should run this script (via create_ISL_pkg_data)
#	and then move the can_ifile into the directory
#		work/sysinst/desktop/ui_modules/ 
#	in the build tree.  The cut.flop script will grab if from there.

[ -f $out ] && /bin/rm -f $out
[ -f $tmp ] && /bin/rm -f $tmp
touch $tmp
touch $out
chmod 777 $tmp $out

################################################################################
# Process can_table and generate can_ifile:
#
#                            'print' is used to output most var=value pairs,
#                            but 'printf' is used for DESC because it allows
#                            control over newline placement, and so trailing
#                            newlines are avoided.  This can be important
#                            when the DESC fills the text box on a UI screen.

cat $can_table $pkg_table | \
nawk > $tmp '
	BEGIN	{ lic_i = set_i = can_i = svc_i = pkg_i = -1	}
		{ gsub( "^	*", "" ); gsub( "none", "" ); }
	/^#/	{ next				}
	$1=="SET" || $1=="CAN" || $1=="SERVICE" || $1=="PACKAGE" || \
	$1=="LABEL" || $1=="DESC" || $1=="SVCS" || $1=="PKGS" || \
	$1=="CNS" || $1=="LICS" || $1=="LICENSE" || $1=="ID" {
			if (in_desc) { print "\""; in_desc = 0; } }
	in_desc { printf( "\n %s", $0); next }
	/^REQUIRED_PKGS/ {	gsub("REQUIRED_PKGS",""); 
				for(p=1; p<=NF; p++) rp[$p]=1;
				print "required_pkgs=\""$0"\""		}
	/^FORBIDDEN_PKGS/ {	gsub("FORBIDDEN_PKGS",""); 
				for(p=1; p<=NF; p++) if(!($p in rp)) fp[$p]=1;
				print "forbidden_pkgs=\""$0"\""		}
	/^LOCALIZED_PKGS/ {	gsub("LOCALIZED_PKGS",""); 	
				print "localized_pkgs=\""$0"\""		}
	/^SET/	{ prefix = "set"; prefix2 = "SET"; i = ++set_i; label = $2 }
	/^CAN/	{ prefix = "can"; prefix2 = "CAN"; i = ++can_i; label = $2 }
	/^SERV/	{ prefix = "svc"; prefix2 = "SVC"; i = ++svc_i; label = $2 }
	/^PACK/	{ prefix = "pkg"; prefix2 = "PKG"; i = ++pkg_i; label = $2 }
	/^LICENSE/  { prefix = "lic"; prefix2 = "LIC"; i = ++lic_i; label = $2 }
	/^LABE/	{	
			if(label=="UnixWare") UnixWare_i = i
			if(label=="base") base_i = i; # instead of...
			# ...print label"_"prefix2"_INDEX="i;
# if ( prefix == "can" || prefix == "pkg" )
			print prefix"_code["i"]="label;	
			gsub( ".*LABEL.", "" );
			print prefix"_label["i"]=\""$0"\"";		}
	/^DESC/	{	in_desc = 1;
			gsub( ".*DESC.", "" );
			printf( "%s", prefix"_desc["i"]=\""$0 );	}
	/^SVCS/	{	gsub( ".*SVCS.", "" );
# JTB commented next line out: we need SET:SVCS
#if ( 0 ) 
			print prefix"_svcs["i"]=\""$0"\"";		}
	/^CNS/	{	gsub( ".*CNS.", "" );
			print prefix"_cans["i"]=\""$0"\"";		}
	/^LICS/	{	gsub( ".*LICS.", "" );
			print prefix"_lics["i"]=\""$0"\"";		}
	/^ID/	{	gsub( ".*ID.", "" );
			print prefix"_id["i"]=\""$0"\"";		}
	/^PKGS/	{	gsub( ".*PKGS.", "" );
			printf( "%s", prefix"_pkgs["i"]=\"");
			for(p=1; p<=NF; p++) 
				if(!(($p in rp)||($p in fp))) 
					printf("%s ",$p);
			print "\"";					}
	END	{	
			if (in_desc) printf( "\"\n");
			print "num_cans="++can_i;
			print "num_svcs="++svc_i;
			print "num_pkgs="++pkg_i;		
			print "num_sets="++set_i;		
			print "num_lics="++lic_i;		
			print "base_pkg_num="base_i;		
		}
	'

################################################################################
# Process internationalized descriptions of cans and services.

de=/tmp/desc_errs.$$
> $de

for desc_file in $can_desc.* ; do

[ ! -r $desc_file ] && {
	echo WARNING: File unreadable: $desc_file
	continue
}

echo Processing $desc_file...

cat $tmp $desc_file | nawk > $tmp.2 \
'		{	gsub( "^[	 ]*", "" );	}
	/^#/	{	next				}
	/_code/ {	
			gsub( "_", " " ); prefix=$1;
			if (prefix == "pkg") next;
			gsub( ".*\\[", "" ); gsub("]="," ");
			codenum[prefix"_"$2]=$1
			next
		}
	$1 == "CAN" || $1 == "SERVICE" {
			if ("" == once)		once=1;
			else			print "\""; 
			if ($1 == "CAN")	prefix="can";
			else			prefix="svc";
			once = i = codenum[prefix"_"$2];
			n="";
			v=prefix"_desc_"lang"["i"]=\"" ;	
			if (i == "") {
				print "Error: "prefix" "$2" not defined in can_table" >de;
				#once=""
			}
			next;
		}
	(i!="")	{	printf( "%s%s", n,v$0 );	v=""; n="\n";	}
	END	{	if (i!="") print "\""; 				}
' lang=${desc_file##*.} de=$de

done
cat $tmp.2 >> $tmp
echo " "
[ -s $de ] && {
	cat $de
	echo ""
	# Abort here?  Missing descriptions don't cripple the ISL.
}
			

################################################################################
# Verify table integrity.

# Warn about multiple and missing definitions:
# (This scan could be part of the nawk program above,
#  but would make things unnecessarily confusing.)

nawk < $tmp '
	{ 	gsub("\"",""); }
	/can_code/ {
		gsub(".*=","");
		if (can[$1]++ > 0) print "Multiply defined CAN:     "$1 }
	/svc_code/ {
		gsub(".*=","");
		if (svc[$1]++ > 0) print "Multiply defined SERVICE: "$1 }
	/pkg_code/ {
		gsub(".*=","");
		if (pkg[$1]++ > 0) print "Multiply defined PACKAGE: "$1 }
	/set_code/ {
		gsub(".*=","");
		if (set[$1]++ > 0) print "Multiply defined SET: "$1 }
	/lic_code/ {
		gsub(".*=","");
		if (lic[$1]++ > 0) print "Multiply defined LICENSE: "$1 }
	/localized_pkgs/ {	next	}
	/_svcs.*=[^0-9]/ {
		gsub(".*=","");
		for(i=1; i<=NF; i++) svc_ref[$i]++  }
	/_pkgs.*=[^0-9]/ {
		gsub(".*=","");
		for(i=1; i<=NF; i++) pkg_ref[$i]++	}
	/_cans.*=[^0-9]/ {
		gsub(".*=","");
		for(i=1; i<=NF; i++) can_ref[$i]++	}
	/_lics.*=[^0-9]/ {
		gsub(".*=","");
		for(i=1; i<=NF; i++) lic_ref[$i]++	}
	END {
		err = 0;
		for(i in svc_ref)
			if (!svc[i]) { err++; print "Undefined SERVICE: "i; }
		for(i in pkg_ref)
			if (!pkg[i]) { err++; print "Undefined PACKAGE: "i; }
		for(i in can_ref)
			if (!can[i]) { err++; print "Undefined CAN: "i; }
		for(i in lic_ref)
			if (!lic[i]) { err++; print "Undefined LICENSE: "i; }
		exit err
	}'

errs=$?


################################################################################
# Warn about missing PACKAGEs (referenced packages):

ret=0
for pkg in ` sed < $tmp -n -e 's,",,g' -e '/pkg_code/s,.*=,,p' `
do
	#[ -d $pkg_home/$pkg ] || [ -d $pkg_home/ifiles/$pkg ] || {
	[ -d $pkg_home/$pkg ] || {
		[ $ret = 0 ] && {
			echo ""
			echo Packages not found under $pkg_home:
		}
		echo -n "$pkg "
		ret=1
	}
done
[ $ret = 1 ] && echo ""


# Could refuse to rename $tmp to $out if ret!=0
[ -s $de ]	&& ret=3
[ $errs != 0 ]	&& ret=2
mv $tmp $out

################################################################################
# Convert lists of service/package names to lists of service/package indexes.
# That is, from
#     can_svcs[1]="file_n_print database messaging fax"
#     svc_pkgs[6]="nis netbios"
# we generate
#     can_svc_nums[1]=" 0 4 1 3"
#     svc_pkg_nums[6]=" 50 77"
# This streamlines some looping algorithms in the cans and services UI modules.
#
. $out

indexes=/tmp/indexes
echo >$indexes

############ util funcs: convert names to numbers

# arg: $1 = package name
# true -> nnp = pkg_num
pkg_num () {
	nnp=-1
	while (( ( nnp += 1 ) < num_pkgs )) ; do
		[ "$1" = "${pkg_code[nnp]}" ] && return 0
	done
	return 1
}

# arg: $1 = service name
# true -> ns = pkg_num
svc_num () {
	ns=-1
	while (( ( ns += 1 ) < num_svcs )) ; do
		[ "$1" = "${svc_code[ns]}" ] && return 0
	done
	return 1
}

# arg: $1 = can name
# true -> nc = can_num
can_num () {
	nc=-1
	while (( ( nc += 1 ) < num_cans )) ; do
		[ "$1" = "${can_code[nc]}" ] && return 0
	done
	return 1
}

# arg: $1 = lic name
# true -> nl = lic_num
lic_num () {
	nl=-1
	while (( ( nl += 1 ) < num_lics )) ; do
		[ "$1" = "${lic_code[nl]}" ] && return 0
	done
	return 1
}


########### end util funcs

# Generate can_svc_nums array assignments...
[ 0 = 1 ] && {
nc=-1
while (( ( n += 1 ) < num_cans )) ; do
	x='can_svc_nums['$nc']="'
	for s in ${can_svcs[nc]} ; do
		svc_num $s && x="$x $ns"
	done
	echo $x'"' >>$indexes
done
}

# Generate can_pkg_nums array assignments...
nc=-1
while (( ( nc += 1 ) < num_cans )) ; do
	x='can_pkg_nums['$nc']="'
	for p in ${can_pkgs[nc]} ; do
		pkg_num $p && x="$x $nnp"
	done
	echo $x'"' >>$indexes
done

# Generate svc_pkg_nums array assignments...
ns=-1
while (( ( ns += 1 ) < num_svcs )) ; do
	x='svc_pkg_nums['$ns']="'
	for p in ${svc_pkgs[ns]} ; do
		pkg_num $p && x="$x $nnp"
	done
	echo $x'"' >>$indexes
done

# Generate set_can_nums array assignments...
ns=-1
while (( ( ns += 1 ) < num_sets )) ; do
	x='set_can_nums['$ns']="'
	for c in ${set_cans[ns]} ; do
		can_num $c && x="$x $nc"
	done
	echo $x'"' >>$indexes
done

# Generate set_svc_nums array assignments...
tns=-1
while (( ( tns += 1 ) < num_sets )) ; do
	x='set_svc_nums['$tns']="'
	for s in ${set_svcs[tns]} ; do
		svc_num $s && x="$x $ns"
	done
	echo $x'"' >>$indexes
done

# Generate set_lic_nums array assignments...
ns=-1
while (( ( ns += 1 ) < num_sets )) ; do
	x='set_lic_nums['$ns']="'
	for l in ${set_lics[ns]} ; do
		lic_num $l && x="$x $nl"
	done
	echo $x'"' >>$indexes
done

# Generate lic_pkg_nums array assignments...
nl=-1
while (( ( nl += 1 ) < num_lics )) ; do
	x='lic_pkg_nums['$nl']="'
	for p in ${lic_pkgs[nl]} ; do
		pkg_num $p && x="$x $nnp"
	done
	echo $x'"' >>$indexes
done


# Convert pkg_size's
while read line; do 
	set -- $line
	np=-1
	while (( ( np += 1 ) < num_pkgs )) ; do
		[ "${pkg_code[np]}" = "$1" ] && [[ $2 != *[!0-9]* ]] && {
			echo pkg_size[$np]=$2 >>$indexes
			pkg_size_found[np]=1
			break
		}
	done
done < $pkg_sizes
err=
np=-1
while (( ( np += 1 ) < num_pkgs )) ; do
	[[ -z ${pkg_size_found[np]} ]] && {
		[[ -z $err ]] && { echo ' '; echo -n No size for packages: ;  } 
		echo -n ' '${pkg_code[np]}
		err=1
	}
done
[[ -n $err ]] && { ret=4; echo ' '; }

# Generate pkg_pkg_nums array assignments...
np=-1
while (( ( np += 1 ) < num_pkgs )) ; do
	x='pkg_pkg_nums['$np']="'
	for p in ${pkg_pkgs[np]} ; do
		pkg_num $p && x="$x $nnp"
	done
	[[ $x'@@' != *\"'@@' ]] &&
	echo $x'"' >>$indexes
done

# Generate req_pkg_nums array assignments...
x='req_pkg_nums="'
for p in ${required_pkgs} ; do
	pkg_num $p && x="$x $nnp"
done
echo $x'"' >>$indexes

x='localized_pkg_nums="'
for p in $localized_pkgs ; do
	lang=${p%%:*}
	x="$x $lang"
	p=${p#*:}
	le=${p%%:*}
	pkg_num $le && x="$x:$nnp"
	p=${p#*:}
	pkg_num $p && x="$x:$nnp"
done
echo $x'"' >> $indexes

# Append the can_svc_nums[] and svc_pkg_nums[] stuff to can_ifile...
cat $indexes >> $out

################################################################################
# Read the setinfo file to capture the physical order of packages on the tape.
# The UI modules use this to reorder the packages after package dependencies
# have been expanded.
#
x="(`echo $forbidden_pkgs | tr ' ' '|' `)"
echo setinfo='"'`egrep -v "^$x" $setinfo | awk '/^[a-zA-Z]/{print $1}'`'"' >> $out


[ $ret != 0 ] && { 
	echo ""
	echo $0 found errors. 
#	exit $ret
}
