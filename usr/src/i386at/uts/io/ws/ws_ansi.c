/*	Copyright (c) 1990, 1991, 1992, 1993, 1994, 1995, 1996 Santa Cruz Operation, Inc. All Rights Reserved.	*/
/*	Copyright (c) 1984, 1985, 1986, 1987, 1988, 1989, 1990 AT&T, Inc. All Rights Reserved.	*/
/*	  All Rights Reserved  	*/

/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Santa Cruz Operation, Inc.	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/

#ident	"@(#)ws_ansi.c	1.8"
#ident	"$Header$"


#include <io/ascii.h>
#include <io/ansi/at_ansi.h>
#include <io/kd/kd.h>
#include <io/stream.h>
#include <io/stropts.h>
#include <io/strtty.h>
#include <io/termio.h>
#include <io/ws/tcl.h>
#include <io/ws/vt.h>
#include <io/ws/ws.h>
#include <io/xque/xque.h>
#include <proc/proc.h>
#include <svc/errno.h>
#include <util/cmn_err.h>
#include <util/debug.h>
#include <util/inline.h>
#include <util/param.h>
#include <util/sysmacros.h>
#include <util/types.h>

/*
 * ws_ansi.c
 *
 * This module handles ansi escape sequences generated by the kernel.
 * This is mainly expected to come from kernel debuggers.
 */

/*
 * The state numbers below were copied from ansi/ansi.c, but they do not
 * have to match that file.  Note that bell, shift-in and shift-out are
 * noops.
 */

#define A_STATE_START			0
#define A_STATE_ESC			1
#define A_STATE_CSI			6

#define NO_PARAM			0xffff

STATIC void wsansi_getparams(kdcnops_t *, ws_channel_t *, ushort);
extern wstation_t Kdws;

/*
 * int
 * wsansi_parse(kdcnops_t *, ws_channel_t *, unchar *, int)
 *
 * Calling/Exit State:
 *	None.
 */
int
wsansi_parse(kdcnops_t *cnops, ws_channel_t *chp, unchar *addr, int cnt)
{
	register termstate_t	*tsp = &chp->ch_tstate;
	ushort	ch; 
	int	i;

	while (cnt--) {
	    ch = *addr++ & 0xFF; 

	    if (tsp->t_pstate == A_STATE_START) {	/* Normal state? */ 
		if (ch == A_ESC || ch == A_CSI || 
		    (ch < ' ' && tsp->t_font == ANSI_FONT0)) {
#ifndef NO_MULTI_BYTE
			if (chp->ch_dmode == KD_GRTEXT)
				cnops->cn_gs_ansi_cntl(cnops, chp, tsp, (ushort)ch);
			else
				wsansi_cntl(cnops, chp, tsp, ch);
#else
			wsansi_cntl(cnops, chp, tsp, ch);
#endif /* NO_MULTI_BYTE */

		} else {

#ifndef NO_MULTI_BYTE
			if (chp->ch_dmode == KD_GRTEXT)
				cnops->cn_gcl_norm(cnops, chp, tsp, (ushort)ch);
			else
				tcl_norm(cnops, chp, tsp, ch);
#else
			tcl_norm(cnops, chp, tsp, ch);
#endif /* NO_MULTI_BYTE */
		}

	    } else {			/* In <ESC> sequence */
		if (tsp->t_pstate != A_STATE_ESC) { /* Need to get params? */
			if (tsp->t_pstate == A_STATE_CSI) {
                 		switch(ch) {
                        	case 's':
					tsp->t_saved_row = tsp->t_row;
					tsp->t_saved_col = tsp->t_col;
					tsp->t_pstate = A_STATE_START;
                                	continue;
                        	case 'u':
					tsp->t_row = tsp->t_saved_row;
					tsp->t_col = tsp->t_saved_col;
					tcl_cursor(cnops, chp);
					tsp->t_pstate = A_STATE_START;
                                	continue;
				default:
					break;
                        	}
			}

			wsansi_getparams(cnops, chp, ch);

		} else {			/* Previous char was <ESC> */	

			if (ch == '[') {
				tsp->t_pnum = 0;
				tsp->t_pcurr = 0;
				tsp->t_ppres = 0;

				/* clear the parameters */
				for (i = 0; i < ANSI_MAXPARAMS; i++)
					tsp->t_ppar[i] = NO_PARAM;

				tsp->t_pstate = A_STATE_CSI;
			} else {
				tsp->t_pstate = A_STATE_START;

				if (ch == '7') {
					/* ESC 7 Save Cursor position */
					tsp->t_saved_row = tsp->t_row;
					tsp->t_saved_col = tsp->t_col;
				} else if (ch == '8') {
					/* ESC 8 Restore Cursor position */
					tsp->t_row = tsp->t_saved_row;
					tsp->t_col = tsp->t_saved_col;
					tcl_cursor(cnops, chp);
				} else if (ch < ' ')
					/* check for control chars */
					wsansi_cntl(cnops, chp, tsp, ch);
				else
					tcl_norm(cnops, chp, tsp, ch);
			}
		}
	    }
	}
	return (0);
}


/*
 * int
 * wsansi_cntl(kdcnops_t *, ws_channel_t *, termstate_t *, ushort)
 *
 * Calling/Exit State:
 *	None.
 *
 * Note:
 *	The control characters like the BELL are not processed because
 *	the console switch (conssw) entry points cannot hold any locks.
 *	The problem was caused by the sysmsg driver which now holds the
 *	cmn_err lock before calling the kd console entry points. Since,
 *	the cmn_err lock has the highest hierarchy and any locks acquired
 *	would cause the hierarchy violation. Since kdtone acquires the
 *	mutex lock to process the BELL character, a lock hierarchy
 *	violation occurs. This is the reason the BELL character and
 *	other control characters are ignored in the console entry points.
 */
int
wsansi_cntl(kdcnops_t *cnops, ws_channel_t *chp, termstate_t *tsp, ushort ch)
{
	int i;

	tsp->t_pstate = A_STATE_START;

	switch (ch) {
	case A_BEL:
		/* (*cnops->cn_bell)(&Kdws, chp); */
		break;

	case A_BS:
		tcl_bs(cnops, chp, tsp);
		break;

	case A_HT:
		tcl_ht(cnops, chp, tsp);
		break;

	case A_NL:
	case A_VT:
		if (tsp->t_row == tsp->t_rows - 1) {
			tsp->t_ppar[0] = 1;
			tcl_scrlup(cnops, chp, tsp);
		} else {
			tsp->t_row++;
			tsp->t_cursor += tsp->t_cols;
		}
		(*cnops->cn_setcursor)(chp, tsp);
		break;

	case A_FF:
		tcl_reset(cnops, chp, tsp);
		break;

	case A_CR:
		tsp->t_cursor -= tsp->t_col;
		tsp->t_col = 0;
		(*cnops->cn_setcursor)(chp, tsp);
		break;

	case A_SO:
		/* (*cnops->cn_shiftset)(wsp, chp, 0); */
		break;

	case A_SI:
		/* (*cnops->cn_shiftset)(wsp, chp, 1); */
		break;

	case A_GS:
		tcl_bht(cnops, chp, tsp);
		break;

	case A_ESC:
		tsp->t_pstate = A_STATE_ESC;
		break;

	case A_CSI:
		tsp->t_pnum = 0;
		tsp->t_pcurr = 0;
		tsp->t_ppres = 0;

		/* Clear the parameters */

		for (i = 0; i < ANSI_MAXPARAMS; i++)
			tsp->t_ppar[i] = NO_PARAM;

		tsp->t_pstate = A_STATE_CSI;
		break;

	default:
		break;
	}

	return (0);
}


/* 
 * STATIC void
 * wsansi_setparam(termstate_t *, int, ushort)
 *
 * Calling/Exit State:
 *	None.
 *
 * Description:
 *	if parameters [0..count - 1] are not set, set them 
 *	to the value of newparam.
 */
STATIC void
wsansi_setparam(termstate_t *tsp, int count, ushort newparam)
{
	int	i;

	for (i = 0; i < count; i++) {
		if (tsp->t_ppar[i] == NO_PARAM)
			tsp->t_ppar[i] = newparam;
	}
}


/*
 * STATIC void
 * wsansi_mvcursor(kdcnops_t *cnops, ws_channel_t *, int, int, int, int)
 *
 * Calling/Exit State:
 *	None.
 *
 * Description:
 *	Perform the appropriate action for moving cursor.
 */

STATIC void
wsansi_mvcursor(kdcnops_t *cnops, ws_channel_t *chp,
		int x, int x_type, int y, int y_type)
{
	register termstate_t	*tsp = &chp->ch_tstate;

	if (x_type == TCL_POSABS)
		tsp->t_col = x;
	else
		tsp->t_col += x;

	if (y_type == TCL_POSABS)
		tsp->t_row = y;
	else
		tsp->t_row += y;

	if (tsp->t_col < 0)
		tsp->t_col = 0;

	if (tsp->t_row < 0)
		tsp->t_row = 0;
	
	tcl_cursor(cnops, chp);
}

/*
 * STATIC void
 * wsansi_chkparam(kdcnops_t *cnops, ws_channel_t *, unchar)
 *
 * Calling/Exit State:
 *	None.
 *
 * Description:
 *	Perform the appropriate action for the escape sequence.
 */

STATIC void
wsansi_chkparam(kdcnops_t *cnops, ws_channel_t *chp, unchar ch) 
{
	int	i;
	register termstate_t	*tsp = &chp->ch_tstate;

	switch (ch) {
	case 'm':	/* select terminal graphics mode */
		wsansi_setparam(tsp, 1, 0);
		tcl_sfont(chp->ch_wsp, chp, tsp);
		break;

	case '@':	/* insert char */
		wsansi_setparam(tsp, 1, 1);
		tcl_ichar(cnops, chp, tsp);
		break;

	case 'A':	/* cursor up */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, 0, TCL_POSREL,
				(int)-tsp->t_ppar[0], TCL_POSREL);
		break;

	case 'd':	/* VPA - vertical position absolute */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, 0, TCL_POSREL,
				(int)tsp->t_ppar[0], TCL_POSABS);
		break;

	case 'e':	/* VPR - vertical position relative */
	case 'B':	/* cursor down */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, 0, TCL_POSREL,
				(int)tsp->t_ppar[0], TCL_POSREL);
		break;

	case 'a':	/* HPR - horizontal position relative */
	case 'C':	/* cursor right */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, (int)tsp->t_ppar[0], TCL_POSREL,
				0, TCL_POSREL);
		break;

	case '`':	/* HPA - horizontal position absolute */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, (int)tsp->t_ppar[0], TCL_POSABS,
				0, TCL_POSREL);
		break;

	case 'D':	/* cursor left */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, (int)-tsp->t_ppar[0], TCL_POSREL,
				0, TCL_POSREL);
		break;

	case 'E':	/* cursor next line */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, 0, TCL_POSABS,
				(int)tsp->t_ppar[0], TCL_POSREL);
		break;

	case 'F':	/* cursor previous line */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, 0, TCL_POSABS,
				(int)-tsp->t_ppar[0], TCL_POSREL);
		break;

	case 'G':	/* cursor horizontal position */
		wsansi_setparam(tsp, 1, 1);
		wsansi_mvcursor(cnops, chp, (int)tsp->t_ppar[0] - 1, TCL_POSABS,
				0, TCL_POSREL);
		break;

	case 'f':	/* HVP */
	case 'H':	/* position cursor */
		wsansi_setparam(tsp, 2, 1);
		wsansi_mvcursor(cnops, chp, (int)tsp->t_ppar[1] - 1, TCL_POSABS,
				(int)tsp->t_ppar[0] -1, TCL_POSABS);
		break;

	case 'J':	/* erase screen */
		wsansi_setparam(tsp, 1, 0);
		tcl_escr(cnops, chp, tsp);
		break;

	case 'K':	/* erase line */
		wsansi_setparam(tsp, 1, 0);
		tcl_eline(cnops, chp, tsp);
		break;

	case 'L':	/* insert line */
		wsansi_setparam(tsp, 1, 1);
		tcl_iline(cnops, chp, tsp);
		break;

	case 'M':	/* delete line */
		wsansi_setparam(tsp, 1, 1);
		tcl_dline(cnops, chp, tsp);
		break;

	case 'P':	/* delete char */
		wsansi_setparam(tsp, 1, 1);
		tcl_dchar(cnops, chp, tsp);
		break;

	case 'S':	/* scroll up */
		wsansi_setparam(tsp, 1, 1);
		tcl_scrlup(cnops, chp, tsp);
		break;

	case 'T':	/* scroll down */
		wsansi_setparam(tsp, 1, 1);
		tcl_scrldn(cnops, chp, tsp);
		break;

	case 'X':	/* erase char */
		wsansi_setparam(tsp, 1, 1);
		(*cnops->cn_clrscr)(chp, tsp->t_cursor, tsp->t_ppar[0]);
		break;

	default:
		break;
	}

	tsp->t_pstate = A_STATE_START; 

	return;
}


/*
 * STATIC void
 * wsansi_getparams(kdcnops_t *, ws_channel_t *, ushort)
 *
 * Calling/Exit State:
 *	None.
 *
 * Description:
 *	Gather the parameters of an ANSI escape sequence.
 */

STATIC void
wsansi_getparams(kdcnops_t *cnops, ws_channel_t *chp, ushort ch) 
{
	register termstate_t	*tsp = &chp->ch_tstate;

	if (ch >= '0' && ch <= '9') {
		tsp->t_pcurr = ((tsp->t_pcurr * 10) + (ch - '0'));	
		tsp->t_ppres++;	/* Remember got parameter */
		return;			/* Return immediately */
	}


	if (tsp->t_ppres) {
		/*
		 * Previous number parameter? Save and
		 * point to next free parameter.
		 */
		tsp->t_ppar[tsp->t_pnum] = tsp->t_pcurr;
		tsp->t_pnum++;
	}

	if (ch == ';') {
		/* Multiple param separator? */
		tsp->t_ppres = 0;	/* Restart parameter search */
		tsp->t_pcurr = 0;	/* No parameter value yet */
	} else 	/* Regular letter */
		wsansi_chkparam(cnops, chp, ch);  /* Handle escape sequence */

}


