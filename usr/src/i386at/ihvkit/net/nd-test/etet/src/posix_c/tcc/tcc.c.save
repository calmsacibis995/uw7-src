/*
 * Copyright 1990 Open Software Foundation (OSF)
 * Copyright 1990 Unix International (UI)
 * Copyright 1990 X/Open Company Limited (X/Open)
 * Copyright 1992 SunSoft, Inc. (SunSoft)
 * Copyright 1993 UNIX System Labs, Inc (USL)
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted, provided
 * that the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation,and that the name of OSF, SunSoft, UI, USL or X/Open 
 * not be used in advertising or publicity pertaining to distribution of 
 * the software without specific, written prior permission. OSF, SunSoft, UI, 
 * USL and X/Open make no representations about the suitability of this 
 * software for any purpose. It is provided "as is" without express or 
 * implied warranty.
 *
 * OSF, SunSoft, UI, USL and X/Open 
 * DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO 
 * EVENT SHALL OSF, UI, SunSoft, or X/Open BE LIABLE FOR ANY SPECIAL, INDIRECT 
 * OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF 
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR 
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR 
 * PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef lint
static char sccsid[] = "@(#)TCC 1.10 06/23/92";
#endif

/************************************************************************

SCCS:           @(#)tcc.c    1.10 06/23/92
NAME:           tcc.c
PRODUCT:        TET (Test Environment Toolkit)
AUTHOR:         OSF Validation & SQA
DATE CREATED:   14 May 1991
CONTENTS:

MODIFICATIONS:    
                Changed Phoenix References to TET / 14May91 / jbg

		"TET Rework"
		David G. Sawyer, UniSoft Ltd, July 1991

		Revised show_synopsis().
		Geoff Clare, UniSoft Ltd, 22 Oct 1991

		Added line to explicitly set the env to exe_env before the
		processing of TET_SAVE_FILES.
		David G. Sawyer, UniSoft Ltd, 6 Nov 1991

		Added code to check the validity of tet_root
		David G. Sawyer, UniSoft Ltd, 25 Nov 1991

		Rename getopt() to avoid clash on systems which have it
		Geoff Clare, Unisoft Ltd., 19 Dec 1991

		Error message buffer enlarged to cater for huge error
		messages.
		David G. Sawyer, UniSoft Ltd, 27 Jan 1992

		tc_search replaced by resume_status
		David G. Sawyer, UniSoft Ltd, 13 Feb 1992

		Rewrote tet_malloc() to take advantage of DBGMEM option.
		Added tet_realloc() and tet_free() to support DBGMEM.
		David G. Sawyer, UniSoft Ltd, 13-19 Feb 1992

		Only catch SIGHUP, SIGINT and SIGQUIT if inherited as
		SIG_DFL, so tcc can be run in background and under nohup.
		Geoff Clare, UniSoft Ltd, 4 Mar 1992

		Changed (x == y ? a : b) construct to if else construct
		for SIGINT signal handler assignment
		Modified parameter decalarations for tet_free() and
		tet_realloc() to avaoid ANSI C compilation problems.
		David G. Sawyer, UniSoft Ltd, 5 Apr 1992

		Altered siginthdlr() so that it gives an imformative
		message if you do a SIGINT when no child is active.
		David G. Sawyer, UniSoft Ltd, 5 Apr 1992

		Changed error message generated by sighdlr()
		David G. Sawyer, UniSoft Ltd, 13 Apr 1992

		Added ETET extensions.
        SunSoft TET1.10e update. May 1993.

		Add tetsuite_root_set flag to denote when set in
		environment. Then when looking for the test suite
		you can use the value of tet_suite_root
		Andrew Josey, UNIX System Labs, Inc. May 1993.

		Add etet_extended_mode to denote whether to use
		conforming or extended temporary results file/journal
		behaviour. This is set by querying for TET_EXTENDED
		in the environment.
		Andrew Josey, UNIX System Labs, Inc. May 27 1993.

		Change the usage of TET_EXTENDED to
		implement the extended features only if it is set *and* 
		is set to a True value (first letter=T).
		ETET 1.10.2 Update.
		Andrew Josey, UNIX System Labs, Inc. October 1993.

		If "TET_EXTENDED" is true, then no locking is used.
		By default TET1.10 style locking is used.
		ETET 1.10.2 Update.
		Andrew Josey, UNIX System Labs, Inc. October 1993.

		Force tet_env to exe_env before calling get_rescode_file()
		so that $TET_RESCODES_FILENAME will be associated with the
		exec environment.
		John Birchfield, QualTrak Corporation, November 1993

		Changes for support of a new flag to specify TET API Compliance.
		Based on proposals 1 and 2 of
		(tetworks 397) API compliance & TC name passing (William Turnbow)
		John Birchfield QualTrak Corporation, January 1994.

		Changes for auto-setting of TET_EXTENDED in SUNTEST
		mode when not already set.
		John Birchfield/William Turnbow/Andrew Josey, February 1994

		Simplify TET_RUN tar options to remove alternate SUNTEST
		behaviour.
		Andrew Josey, Novell UNIX System Labs, February 1994

		Remove TET 1.10 code under #ifdef OLD_TMP
		Andrew Josey, Novell UNIX System Labs, March 1994
		
************************************************************************/

#include <tcc_env.h>
#include <tcc_mac.h>
#include <tet_jrnl.h>
#include <tcc_prot.h>

/* Is the journal open */
bool jnl_open_flag = FALSE;

/* Different modes of operation */
bool build_mode = FALSE, exec_mode = FALSE, clean_mode = FALSE;

/* Options to the modes of operation */
bool resume_opt = FALSE, rerun_opt = FALSE;

int resume_status = 0;	      /* Resume option starts of non-active */
int jnl_fd = 0;               /* The journal file descriptor */
int context = 0;              /* The process that made an entry in the jnl */
int debug_suite = FALSE;      /* Has the -d option been used */
int lock_type = 0;            /* The type of lock cuurently used, 0 = None */
int cpid = 0;                 /* Child process id */
int g_timeout = 0;            /* Timeout in seconds, set using -t option */
int interrupted = 0;          /* Has the user generated an interrupt */
int *result_list = NULL;      /* The list of result code nums to look for */
int produce_output = FALSE;   /* Do you want to the tcc doing something */
int alt_exec_set = FALSE;     /* Has the alt_exec_dir been set */
int initialising = TRUE;      /* Used in tet_shutdown() to decide exit status */
int context_status;           /* Used in the tool and execute functions */
int oc_set = FALSE;           /* Is output capture set */
int tet_api_compliant;        /* Is the test TET API Compliant */
int pass_tc_name_to_tool;     /* Do we pass the tc name to the tool */
int eip_set = FALSE;          /* Is exec in place set */
int tet_lock_set = TRUE;      /* Is exclusive locking set */
int etet_ext_set = FALSE;     /* Are we running in ETET extended mode */
int result_mode[3] = {0,0,0}; /* Modes specified in the result code pattern */
int abort_requested = FALSE;  /* Set if a result code requests an Abort */
int scenario_line = 0;        /* line number, used in mode start messages */
int old_line = 0;             /* the scenario line number to resume from */
int scenario_element = 0;     /* element number, used in mode start messages */
int old_element = 0;          /* the scenario element number to resume from */
int tetsuite_root_set = FALSE;  /* Set if TET_SUITE_ROOT is defined */

char *result_pat = NULL;        /* result code pattern, for -m,-r options */
char *jnl_file_name = NULL;     /* journal file name */
char *bld_cfg_file_name = NULL; /* build configuration file */
char *cln_cfg_file_name = NULL; /* clean configuration file */
char *exe_cfg_file_name = NULL; /* execution configuration file */
char *scen_file_name = NULL;    /* scenario file name */
char *suite_name = NULL;        /* actual test suite name */
char *scenario_name = NULL;     /* the scene to look for */
char *etet_extended_mode = NULL; /* etet modes - conforming or extended */
char **yes_list = NULL;         /* Text to match before exeing a scen line */
char **no_list = NULL;          /* Text to match to not exec a scen line */
char **scen_lines = NULL;       /* Explicit scenario lines to be execed */
char **save_files = NULL;       /* Any files we want saving afterwards */

char error_mesg[BIG_BUFFER];    /* Error message buffer */

#ifdef DBGMEM
MEMCHECK *memtable = NULL;      /* Memory allocation checking table */
#endif

ENV_T * tet_env = NULL;         /* the current TET environment */
ENV_T * bld_env = NULL;         /* the build mode environment */
ENV_T * exe_env = NULL;         /* the exe mode environment */
ENV_T * cln_env = NULL;         /* the clean environment */

FILE * old_jnl_fp;              /* old journal file pointer */
struct sigaction sig;           /* signal handling structure */

char results_file[] = TMP_RES_FILE;       /* test case dir 'results' file */

char test_suite_root[_POSIX_PATH_MAX];    /* pretty obvious - I hope */
char results_dir[_POSIX_PATH_MAX];        /* results directory */
char alt_exec_dir[_POSIX_PATH_MAX];       /* alternate execution directory */
char tet_root[_POSIX_PATH_MAX];           /* for $TET_ROOT */
char temp_base_dir[_POSIX_PATH_MAX];      /* temp execution base dir */
char temp_dir[_POSIX_PATH_MAX];           /* temp execution dir */
char old_journal[_POSIX_PATH_MAX];        /* old journal for resume/rerun  */
char start_dir[_POSIX_PATH_MAX];          /* The directory we start in */

/*fdef SUNTEST 				  /* ETET Extension */
char tet_run[_POSIX_PATH_MAX];            /* for $TET_RUN */
char tet_suite_root[_POSIX_PATH_MAX];     /* TET_SUITE_ROOT|TET_RUN/suite */
int tet_run_set = FALSE;      		  /* Has the tet_run dir been set */
int copy_flag = TRUE;         		  /* cp suite to tet_run only once */
/*ndif					  /* ETET extension */

/* recognised options */
char *optstring = "a:bcdef:g:hi:j:l:m:n:pr:s:t:v:x:y:?";

/* Ensure a sensible default value */
#ifndef TET_SIG_IGNORE
#define TET_SIG_IGNORE 0
#endif

/* Ensure a sensible default value */
#ifndef TET_SIG_LEAVE
#define TET_SIG_LEAVE 0
#endif

/* The list of signals that should be ignored or have their action unchanged */
int    sig_ignore[] = { 0, TET_SIG_IGNORE};
int    sig_leave[]  = { 0, TET_SIG_LEAVE};

/* forward declarations */
#ifdef SUNTEST
static void get_artus_env(char *tet_suite_root, char *st_name);
#endif

/*
 *  TCC main routine, a "-?" flag option gives you the correct synopsis
 */
int main(argc,argv)
int argc;
char *argv[];
{
    int ch, ctr, pid, len, num, rc, sig_set, pat_len = 0;
    int exit_val = EXIT_OK, max_res = 0, user_results_dir = FALSE;
    char msg[256], tmp_dir[_POSIX_PATH_MAX];
    char *line_p, *eq_p, *jnl_dir, *tmp_ptr, *cp;
    char *save_pat_p, *pres_sep, *next_sep;
    char *tet_lock_p;

    /* check to see any options were supplied */
    if (argc == 1)
    {
        show_synopsis();
        tet_shutdown();
    }

	{
		time_t tloc;
	    srand((int)time(&tloc));
	}

#ifndef NSIG
#define       NSIG    32
	(void) fprintf(stderr,"Warning: tcc was built without NSIG being defined, default value of 32 was used\n");
#endif

    /* Sort out the signal handling */
    for( num = 1; num < NSIG; num++)
    {
        sig_set = 0;
        if (num == SIGKILL || num == SIGSTOP || num == SIGCHLD)
            continue;

        for(ctr = 0; (sizeof(sig_leave[0])*ctr) <= sizeof(sig_leave); ctr++)
            if(sig_leave[ctr] == num)
            {
                sig_set = 1;
                break;
            }

        if(sig_set)
            continue;

        for(ctr = 0; (sizeof(sig_ignore[0])*ctr) <= sizeof(sig_ignore); ctr++)
            if(sig_ignore[ctr] == num)
            {
                sig.sa_handler = SIG_IGN;
                sig_set = 1;
                break;
            }


        if( ! sig_set)
	{
	    if (num == SIGHUP || num == SIGINT || num == SIGQUIT)
	    {
		struct sigaction osig;
		if (sigaction(num, (struct sigaction *)NULL, &osig) != -1)
		{
		    if (osig.sa_handler == SIG_IGN)
		    {
			sig.sa_handler = SIG_IGN;
			sig_set = 1;
		    }
		}
	    }

	    if( ! sig_set)
	    {
		if( num == SIGINT)
		    sig.sa_handler = (void(*)()) siginthdlr;
		else
		    sig.sa_handler = (void(*)()) sighdlr;
	    }
	}

        sig.sa_flags = 0;
        (void) sigaction(num, &sig, (struct sigaction *)NULL);
    }
    
    /* so that the umask does not effect the creation of files etc */
    (void) umask(000); 

    /* sort out the dir we start off in */
    if( getcwd(start_dir, sizeof(start_dir)) == (char *) NULL)
    {
        perror("getcwd");
        tet_shutdown();
    }

#ifdef TET_ROOT
    /* initialize 'tet_root' from defined value */
    (void) strcpy(tet_root,TET_ROOT);
#endif

    /*
     *  initialize 'tet_root' from environment var $TET_ROOT
     *  (this takes precedence over any compile-time value)
     */  

    line_p = getenv("TET_ROOT");
    if ((line_p != NULL)  && (*line_p == '/'))
        (void) strcpy(tet_root,line_p);

    if ((tet_root == NULL)  || (*tet_root != '/'))
	{
        (void) fprintf(stderr, "TET_ROOT not set or not set to absolute path.  TCC aborts\n");
		exit(3); 
	}

    /*
     * Stop if tet_root has not been defined from either source
     */
    if (tet_root[0] == '\0')
    {
        (void) fprintf(stderr, "No TET_ROOT directory defined\n"); 
        tet_shutdown();
    }

    /*
     * Check the accessability of the tet_root...
     */
    if (chdir(tet_root) == -1)
    {
        BAIL_OUT("tet_root check failed ");
    }
    else
    {
        /* get back to where we were */
        BAIL_OUT_ON(chdir(start_dir),"changing back to starting directory.\n");
    }
#ifdef DBG2
    (void) fprintf(stderr,"tet_root = %s\n", tet_root);
#endif

	build_temp_dir();

/*fdef SUNTEST		/* ETET extension */

    line_p = getenv("TET_SUITE_ROOT");
    if ((line_p != NULL) && (*line_p == '/'))
    {
        (void) strcpy(tet_suite_root,line_p);
	tetsuite_root_set = TRUE;
    }
    else
    {
        /* if tet_suite_root wasn't set, default to tet_root */
#ifdef DBG
        (void) fprintf(stderr,"TET_SUITE_ROOT not set to an absolute path; ");
        (void) fprintf(stderr,"will look for test suite on $TET_ROOT\n");
#endif
        (void) strcpy(tet_suite_root,tet_root);
    }

    if ((line_p = getenv("TET_RUN")) != NULL)
        (void) strcpy(tet_run,line_p);

    /*
     * Check for the existence and accessibility of tet_suite_root & tet_run
     */
 
    if (access(tet_suite_root, F_OK) != 0)
    {
        (void) fprintf(stderr,"tet_root or tet_suite_root not accessible\n");
        exit(3);
    }
    if ((tet_run[0] != '\0') && strcmp(tet_run, tet_suite_root))
        if (access(tet_run, F_OK) != 0)
            if (do_mkdir(tet_run) == FAILURE)
            {
                (void) fprintf(stderr, "can't mkdir tet_run\n");
                exit(3);
            }
            else tet_run_set = TRUE;
        else tet_run_set = TRUE;
    else if (!strcmp(tet_run, tet_suite_root))
        (void) fprintf(stderr,
            "Warning: TET_RUN's identical to TET_SUITE_ROOT, TET_RUN not in effect\n");

/*ndif			/* ETET extension */

    /* Set flag to denote which temporary results file/journal file
     * behaviour to use. If TET_EXTENDED is set and is true, then the ETET
     * direct to journal file behaviour is used. The default behaviour
     * is to write to tet_xres, and then copy that to the journal.
     */
#ifdef SUNTEST
    etet_ext_set=TRUE;
#endif	
    etet_extended_mode = getenv("TET_EXTENDED");
    if (etet_extended_mode != NULL) 
	{
		if (toupper(*etet_extended_mode) == 'T')
		{
	 		etet_ext_set = TRUE;
     	} 
		else 
		{
	 		etet_ext_set = FALSE;
     	}
    }
#ifdef SUNTEST
	else 
	{
		etet_extended_mode="T";
	}
	/* make sure the value of TET_EXTENDED is exported in the SUNTEST case */
	{
		static char line[20];
		sprintf(line,"TET_EXTENDED=%c",(etet_ext_set)?'T':'F');
		putenv(line);
	}
#endif


    /* 
     *  Initialise the mode environments.
     */
    bld_env = (ENV_T *) TET_MALLOC2((size_t)(ENV_BIGGER*sizeof(ENV_T)));
    for(ctr = 0; ctr < ENV_BIGGER; ctr++)
        bld_env[ctr].name = NULL;

    exe_env = (ENV_T *) TET_MALLOC2((size_t)(ENV_BIGGER*sizeof(ENV_T)));
    for(ctr = 0; ctr < ENV_BIGGER; ctr++)
        exe_env[ctr].name = NULL;

    cln_env = (ENV_T *) TET_MALLOC2((size_t)(ENV_BIGGER*sizeof(ENV_T)));
    for(ctr = 0; ctr < ENV_BIGGER; ctr++)
        cln_env[ctr].name = NULL;

    /*
     *  process all command line options.
     *  options used to date:
     *                        a,b,c,d,e,f,g,h,i,j,l,m,n,p,r,s,t,v,x,y,?
     */
    while (( ch = optget(argc,argv,optstring) ) != EOF)
    {
        switch ((char)ch)
        {
            /* The alternate execution directory */
        case 'a':
            /*
             * When the alt_exec_dir is specified by this option we 
             * must make sure it is stored as a full path.
             */
            if(optarg[0] != DIR_SEP_CHAR)
                (void) sprintf(alt_exec_dir,"%s/%s",start_dir,optarg);
            else
                (void) strcpy(alt_exec_dir,optarg);
            break;

            /* Build mode */
        case 'b':
            build_mode = TRUE;
            break;

            /* Clean mode */
        case 'c':
            clean_mode = TRUE;
            break;

            /* Enable debugging break points */
        case 'd':
            debug_suite = TRUE;
            break;

            /* Exec mode */
        case 'e':
            exec_mode = TRUE;
            break;

            /* Specific clean config file */
        case 'f':
            cln_cfg_file_name = (char *)TET_MALLOC(strlen(optarg) + 1);
            (void) strcpy(cln_cfg_file_name,optarg);
            break;

            /* Specific build config file */
        case 'g':
            bld_cfg_file_name = (char *)TET_MALLOC(strlen(optarg) + 1);
            (void) strcpy(bld_cfg_file_name,optarg);
            break;

            /* Intermediate Results Dir. (working dir.) */
        case 'i':
            (void) strcpy(results_dir,optarg);
            user_results_dir = TRUE;
            break;

            /* journal file name */
        case 'j':

/*f SUNTEST			/* ETET extension */

	    if (optarg != NULL && optarg[0] != '/') 
		{
			jnl_file_name = (char *)TET_MALLOC(strlen(start_dir)+1+strlen(optarg)+1);
			(void) strcpy(jnl_file_name,start_dir);
			(void) strcat(jnl_file_name,"/");
			(void) strcat(jnl_file_name,optarg);
	    } 
		else 
		{
			jnl_file_name = (char *)TET_MALLOC(strlen(optarg)+1);
			(void) strcpy(jnl_file_name,optarg);
	    }
/*else
            jnl_file_name = (char *)TET_MALLOC(strlen(optarg)+1);
            (void) strcpy(jnl_file_name,optarg);
/*ndif		 		/* ETET extension */

            break;

            /* use this specific scenario line */
        case 'l':
            if( scen_lines == NULL)
            {
                scen_lines = (char **) TET_MALLOC((size_t)(sizeof(char *)*10));
                for(num = 0; num < 10; num++)
                    scen_lines[num] = NULL;
            }
            for(num = 0; scen_lines[num] != NULL; num++);
            if((num % 10) == 9)
            {
                scen_lines = (char **) TET_REALLOC((void *)scen_lines, (size_t)(sizeof(char *)*(num+11)));
                for(ctr = num; ctr < (num + 11); ctr++)
                    scen_lines[ctr] = NULL;
            }
            scen_lines[num] = (char *) TET_MALLOC(strlen(optarg)+1);
            (void) strcpy(scen_lines[num],optarg);
            break;

            /*  Resume option, record the result codes to look for and
             *  note that we need to look for a specific test case before
             *  processing the rest of the scenario file.
             */
        case 'm':
            resume_opt = TRUE;
            resume_status = 1; 					/* active */
            result_pat = (char *)TET_MALLOC2(strlen(optarg)+1);
            (void) strcpy(result_pat,optarg);
            break;

            /* If this text occurs in a scenario line don't exec it */
        case 'n':
            if( no_list == NULL)
            {
                no_list = (char **) TET_MALLOC((size_t)(sizeof(char *)*10));
                for(num = 0; num < 10; num++)
                    no_list[num] = NULL;
            }
            for(num = 0; no_list[num] != NULL; num++);
            if((num % 10) == 9)
            {
                no_list = (char **) TET_REALLOC((void *)no_list, (size_t)(sizeof(char *)*(num+11)));
                for(ctr = num; ctr < (num + 11); ctr++)
                    no_list[ctr] = NULL;
            }
            no_list[num] = (char *) TET_MALLOC(strlen(optarg)+1);
            (void) strcpy(no_list[num],optarg);
            break;

            /* Produce minimal output to give the user something to look at */
        case 'p':
            produce_output = TRUE;
            break;

            /* Rerun option, record the result codes to look for */
        case 'r':
            rerun_opt = TRUE;
            result_pat = (char *)TET_MALLOC2(strlen(optarg)+1);
            (void) strcpy(result_pat,optarg);
            break;

            /* scenario file name */
        case 's':
            scen_file_name = (char *)TET_MALLOC(strlen(optarg)+1);
            (void) strcpy(scen_file_name,optarg);
            break;

            /* timeout, in seconds */
        case 't':
            g_timeout = atoi(optarg);
            break;

            /* Define a configuration variable on the command line */
        case 'v':
            line_p = (char *)TET_MALLOC(strlen(optarg)+1);
            (void) strcpy(line_p,optarg);
            eq_p = strchr(line_p,CFG_SEP_CHAR);
            if (eq_p == NULL)
            {
                (void) fprintf(stderr,"-v option requires %c\n",CFG_SEP_CHAR);
                TET_FREE((void *)line_p);
                continue;
            }
            /* delimit variable name */
            *eq_p = '\0'; 
            if( *(eq_p+1) != '\0')
            {
                /* put the variable into each of the environments */
                tet_env = bld_env;
                add_tetenv(line_p,eq_p+1,CFG_PERM_VAL);
                tet_env = exe_env;
                add_tetenv(line_p,eq_p+1,CFG_PERM_VAL);
                tet_env = cln_env;
                add_tetenv(line_p,eq_p+1,CFG_PERM_VAL);
            }
            TET_FREE((void *)line_p);
            break;

            /* Specific execution config file */
        case 'x':
            exe_cfg_file_name = (char *)TET_MALLOC(strlen(optarg) + 1);
            (void) strcpy(exe_cfg_file_name,optarg);
            break;

            /* Only exec a scenario line if this text occurs in it */
        case 'y':
            if( yes_list == NULL)
            {
                yes_list = (char **) TET_MALLOC((size_t)(sizeof(char *)*10));
                for(num = 0; num < 10; num++)
                    yes_list[num] = NULL;
            }
            for(num = 0; yes_list[num] != NULL; num++);
            if((num % 10) == 9)
            {
                yes_list = (char **) TET_REALLOC((void *)yes_list, (size_t)(sizeof(char *)*(num+11)));
                for(ctr = num; ctr < (num + 11); ctr++)
                    yes_list[ctr] = NULL;
            }
            yes_list[num] = (char *) TET_MALLOC(strlen(optarg)+1);
            (void) strcpy(yes_list[num],optarg);
            break;

            /* print a synopsis for the TCC */
        case '?':
	case 'h':
        default:
            show_synopsis();
            tet_shutdown();
        }
    }

    /* Has the alternative execution directory been set */
    if ( alt_exec_dir[0] != '\0')
        alt_exec_set = TRUE;

#ifdef DBG2
    (void) fprintf(stderr,"alt_exec_dir = %s\n",((alt_exec_set == TRUE) ? alt_exec_dir : "NULL"));
#endif

    /* Must specify at least one mode */
    if( exec_mode == FALSE && build_mode == FALSE && clean_mode == FALSE)
    {
        (void) fprintf(stderr,"Must specify at least one mode of operation.\n");
        tet_shutdown();
    }

    /* Not allowed to have both resume and rerun enabled */
    if ( (resume_opt == TRUE) && (rerun_opt == TRUE) )
    {
        (void) fprintf(stderr,"Can't have both rerun and resume options set\n");
        tet_shutdown();
    }

    /* If we have rerun or resume option we need to know the old_jnl name */
    if ( (resume_opt == TRUE) || (rerun_opt == TRUE) )
    {
        if ( (argc - optind) < 1 )
        {
            (void) fprintf(stderr,"old journal file is a required argument.\n");
            tet_shutdown();
        }

        (void) strcpy(old_journal,argv[optind]);

        old_jnl_fp = fopen(old_journal,"r");
        if (old_jnl_fp == NULL)
        {
            (void) fprintf(stderr,"Failed to open old journal %s.\n",old_journal);
            BAIL_OUT("fopen of old journal");
        }

        /* make sure the file descriptor is closed on an exec call */
        (void) fcntl(fileno(old_jnl_fp), F_SETFD, FD_CLOEXEC);
        
        optind++;
    }

    /*
     *  Determine whether the suite_name and the scene name have been given
     *  and if not try and calculate their defaults.
     */
    if ((argc - optind) < 2)
    {
        /* If -l is null or scen_file_name has been specified */
        if( (scen_lines == NULL) || (scen_file_name != NULL))
        {
            /* default scene name */
            scenario_name = (char *)TET_MALLOC2(strlen("all")+1);
            (void) strcpy(scenario_name,"all");
        }

        if((argc - optind) < 1)
        {
            /* Don't want to mess with start_dir */
            (void) strcpy(tmp_dir, start_dir);

            /* try to establish suite_name, as per spec. */
            if(strncmp(tet_root,tmp_dir,strlen(tet_root)) == 0)
            {
                if((tmp_ptr = strchr(&tmp_dir[strlen(tet_root)+1],DIR_SEP_CHAR))
                            != NULL)
                {
                    *tmp_ptr = '\0';
                    suite_name = (char *) TET_MALLOC(
                                     strlen(&tmp_dir[strlen(tet_root)+1]) + 2);
                    (void) strcpy(suite_name, &tmp_dir[strlen(tet_root)+1]);
                }
                else
                {
                    if((tmp_dir[strlen(tet_root)+1] != '\0') && 
                        (! isspace(tmp_dir[strlen(tet_root)+1])))
                    {
                        suite_name = (char *) TET_MALLOC2(strlen(&tmp_dir[strlen(tet_root)+1]) + 2);
                        (void) strcpy(suite_name, &tmp_dir[strlen(tet_root)+1]);
                    }
                    else
                    {
 			if (tetsuite_root_set)
                            strcpy(test_suite_root, tet_suite_root);
                        else
                        {
                            (void) fprintf(stderr,"No test suite name supplied, and unable to establish default.\n");
                            tet_shutdown();
			}
                    }
                }

                /* build up the test suite root */
                (void) sprintf(test_suite_root,"%s/%s", tet_root, suite_name);
            }
            else
            {
 		if (tetsuite_root_set)
                    strcpy(test_suite_root, tet_suite_root);
                else
                {
                    (void) fprintf(stderr, "No test suite name supplied, and unable to establish default.\n");
                    tet_shutdown();
		}
            }

        }
        else
        {
            suite_name = (char *)TET_MALLOC2(strlen(argv[optind])+1);
            /* set the test suite name */
            (void) strcpy(suite_name,argv[optind]);      

            if(suite_name[0] != DIR_SEP_CHAR)
/*fdef SUNTEST			/* ETET extension */
                (void) sprintf(test_suite_root,"%s/%s", 
                     tet_suite_root, suite_name);
/*lse
                (void) sprintf(test_suite_root,"%s/%s", tet_root, suite_name);
/*ndif				/* ETET extension */

            else
                (void) strcpy(test_suite_root, suite_name);
        }
    }
    else
    {
        suite_name = (char *)TET_MALLOC(strlen(argv[optind])+1);
        /* set the test suite name */
        (void) strcpy(suite_name,argv[optind]);      

        if(suite_name[0] != DIR_SEP_CHAR)
/*fdef SUNTEST			/* ETET extension */
            (void) sprintf(test_suite_root,"%s/%s", tet_suite_root, suite_name);
/*lse
            (void) sprintf(test_suite_root,"%s/%s", tet_root, suite_name);
/*ndif				/* ETET extension */
        else
            (void) strcpy(test_suite_root, suite_name);

        optind++;
        scenario_name = (char *)TET_MALLOC(strlen(argv[optind])+1);
        /* set the scene name */
        (void) strcpy(scenario_name,argv[optind]);      
    }

/*fdef SUNTEST			/* ETET extension */
    if (tet_run_set == TRUE)
    {
        /* rm old trace and copy new suite for the first time */
        (void) sprintf(tmp_dir, "%s/%s", tet_run, suite_name);
        if ((build_mode == TRUE) && (copy_flag == TRUE))
        {
            if (access(tmp_dir, F_OK) == 0)
                do_rm(tmp_dir);
            if (do_mkdir(tmp_dir) == FAILURE)
            {
                (void) fprintf(stderr,"ERROR: can't mkdir tet_run/tet_suite\n");                exit(3);
            }
            (void) fprintf(stderr,"Transferring testsuite to tet_run dir...\n");
#ifdef SunOS41
            /* use bar on 4.1 because tar bug doesn't take long path */
            (void) sprintf(msg,
                "cd %s/%s; bar cf - ./. | (cd %s/%s; bar xfBp -)",
                    tet_suite_root, suite_name, tet_run, suite_name);
#else
            (void) sprintf(msg,
                "cd %s/%s; tar cf - ./. | (cd %s/%s; tar xfp -)",
                    tet_suite_root, suite_name, tet_run, suite_name);
#endif
            (void) system (msg);
            copy_flag = FALSE;
        }
        /* test_suite_root is now on tet_run/suite */
        (void) strcpy(test_suite_root, tmp_dir);
    }
/*ndif				/* ETET extension */

#ifdef DBG2
    (void) fprintf(stderr,"test_suite_root = %s\n", test_suite_root);
#endif

    if(scen_lines != NULL)
    {
        if((scenario_name != NULL) && (scen_file_name == NULL))
        {
            (void) fprintf(stderr,"Need to set the scenario file name if you wish to use a \nscenario with specific scenario lines.\n");
            tet_shutdown();
        }
        /* Not allowed resume or rerun enabled with specific scen lines */
        if ( (resume_opt == TRUE) || (rerun_opt == TRUE) )
        {
            (void) fprintf(stderr,"Can't have rerun or resume options set, with specific scenario lines.\n");
            tet_shutdown();
        }
    }

    /*
     *  Build the path to the 'results' dir,  adding "/"
     *  chars between tet_root, suite_name, & "results" 
     */
    if (results_dir[0] == '\0')
        (void) sprintf(results_dir,"%s/results",test_suite_root);

    /* create results dir. if necessary */
    if (do_mkdir(results_dir) == FAILURE)
    {
        (void) fprintf(stderr,"Cannot make results directory %s\n",results_dir);
        tet_shutdown();
    }

    /*
     * If the user did not supply a results directory
     * on the command line then we need to sort out the sub-directory
     * beneath the "results" directory.
     */
    if( user_results_dir == FALSE)
    {
        /* get_jnl_dir() uses results_dir */
        jnl_dir = get_jnl_dir();
        if (jnl_dir == (char *) NULL)
        {
            (void) fprintf(stderr, "Failed to obtain dir for journal file\n");
            tet_shutdown();
        }

        (void) strcpy(results_dir, jnl_dir);
    }

#ifdef DBG2
    (void ) fprintf(stderr,"results_dir = %s\n", results_dir);
#endif

    /* determine journal file name, if none given on command line */
    if (jnl_file_name == NULL)
    {
        jnl_file_name = (char *) TET_MALLOC2(strlen(results_dir) + 3 + strlen("journal"));
        (void) strcpy(jnl_file_name,results_dir);
        (void) strcat(jnl_file_name,DIR_SEP_STR);
        (void) strcat(jnl_file_name,"journal");
    }

    /* Create the journal */
    if ((jnl_fd = open(jnl_file_name,O_WRONLY|O_CREAT|O_EXCL|O_APPEND,
               (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH))) == FAILURE)
    {
        (void) fprintf(stderr,"Error opening journal file %s\n",jnl_file_name);
        perror("open");
        tet_shutdown();
    }
    else
    {
        /* display the journal name as per Spec. - well sort of... */
        (void) printf("journal file name is: %s\n", jnl_file_name);
        (void) fflush(stdout);
        jnl_open_flag = TRUE;

        /* make sure the file descriptor is closed on an exec call */
        (void) fcntl(jnl_fd, F_SETFD, FD_CLOEXEC);
    }

    /*
     * Put a copy of the command line into the "TCC Start" journal message
     */
    (void) strcpy(msg,"TCC Start, Command Line: ");
    ctr = 0;
    while ((ctr<argc) && ((int) (strlen(msg) + strlen(argv[ctr] + 1)) < 256))
    {
        (void) strcat(msg,argv[ctr++]); 
        (void) strcat(msg," ");
    }

    /* write the TCC start message to the journal file */
    (void) jnl_entry_tcc_start(msg);

    /*
     *  Now we sort out all the configuration file names.
     */

    /* default build cfg file */
    default_cfg_file(&bld_cfg_file_name,"tetbuild.cfg");

    /* default exec cfg file */
    default_cfg_file(&exe_cfg_file_name,"tetexec.cfg");

    /* default clean cfg file */
    default_cfg_file(&cln_cfg_file_name,"tetclean.cfg");

    /* default scenario file */
    default_cfg_file(&scen_file_name,"tet_scen");

#ifdef SUNTEST
    /* get environment for ARTUS test suite */
    (void) get_artus_env(tet_suite_root, suite_name);
#endif

    /* 
     *  Load in the environment for each of the modes selected, this is also
     *  the point where the configuration variables get written to the jnl.
     */
    if (build_mode == TRUE)
    {
        init_config(MODE_BLD);
        do_config_file(bld_cfg_file_name,MODE_BLD);
    }

    if (exec_mode == TRUE)
    {
        init_config(MODE_EXEC);
        do_config_file(exe_cfg_file_name,MODE_EXEC);
    }

    if (clean_mode == TRUE)
    {
        init_config(MODE_CLN);
        do_config_file(cln_cfg_file_name,MODE_CLN);
    }

	/*	
	 * The result code file name will NOT be the same in each env -
	 * can be changed by the user in an arbitrary fashion in the
	 * respective .cfg file.  Therefore - I'm forcing it to the
	 * exe_env since that's where it makes the most sense to be.
	 */
	tet_env = exe_env;

    /* Get the result codes and their actions from the appropriate file */
    if(get_rescode_file() == FAILURE)
    {
        (void) fprintf(stderr, "Failure to successfully process TET result code file\n");
        tet_shutdown();
    }

    /* 
     *  Now that we have the result codes, convert the result pattern names
     *  into numbers.
     */
    if( result_pat != NULL)
    {
        result_list = (int *) TET_MALLOC2((size_t)(sizeof(int)*10));
        for(ctr = 0; ctr < 10; ctr++)
	    result_list[ctr] = -1;

        /* Get an array of results codes from the comma seperated list */
        for( cp = result_pat; cp != NULL; )
        {
	    ch = 0;
            /* The results code name is stored internally with quotes round
             * it so we add our own to the word we're checking.
             */
            tmp_ptr = (char *) TET_MALLOC( strlen(cp) + 5);
            tmp_ptr[0] = '"';
            (void) strcpy(&tmp_ptr[1], cp);

            if((cp = strchr(cp,',')) != NULL)
            {
                tmp_ptr[strlen(tmp_ptr) - strlen(cp)] = '\0';
                /* advance the pointer to the next position after the comma */
                cp++;
            }
            (void) strcat(tmp_ptr, "\"");

	    /* check for mode specifiers in the list */
	    if(strlen(tmp_ptr) == 3) /* ie a single letter in quotes */
	    {
		switch((int) tmp_ptr[1])
		{
			case 'b':
				result_mode[0] = 1;
				ch = 1;
				break;
			case 'e':
				result_mode[1] = 1;
				ch = 1;
				break;
			case 'c':
				result_mode[2] = 1;
				ch = 1;
				break;
			default:
				break;
		}
		if( ch == 1)
		{
			TET_FREE((void *) tmp_ptr);
			continue;
		}
	    }

            rc = rescode_name_to_num(tmp_ptr);
            if(rc == FAILURE)
            {
                (void) fprintf(stderr,"Invalid result code name: %s\n",tmp_ptr);
                tet_shutdown();
            }
            else
            {
                if((max_res % 10) == 9)
                {
                    result_list = (int *) TET_REALLOC((void *)result_list, (size_t)(sizeof(int)*(max_res+11)));
                    for(ctr = max_res; ctr < (max_res + 11); ctr++)
                        result_list[ctr] = -1;
                }
                result_list[max_res] = rc;
                ++max_res;
            }

            TET_FREE((void *) tmp_ptr);
        }
        if(max_res == 0 && result_mode[0] == 0 && result_mode[1] == 0 &&
		result_mode[2] == 0)
        {
            (void) fprintf(stderr,"Couldn't get any result codes from command line.\n");
            tet_shutdown();
        }
        else
            result_list[max_res] = -1;
    }

	/*  locking defaults to TET1.10 compatible unless TET_LOCK is
	 *  is set to FALSE or TET_EXTENDED is set to True
	 */

    tet_lock_set = TRUE;
/*-*/
    tet_lock_p = get_tetenv("TET_LOCK");
    if ( (tet_lock_p != NULL) && (toupper(*tet_lock_p) == 'F') )
		tet_lock_set = FALSE;

    if (etet_ext_set == TRUE)
		tet_lock_set = FALSE;


    /* 
     * Sort out the save files - if there are any
     * Note: tet_env is still set at this stage !
     */

    /* Make sure we using the exe env for the save files setup code */
    tet_env = exe_env;

    /* get the comma seperated list of files that should be saved */
    save_pat_p = get_tetenv("TET_SAVE_FILES");

    if(save_pat_p != NULL)
        pat_len = strlen(save_pat_p);
    if(pat_len != 0)
    {
        save_files = (char **) TET_MALLOC((size_t)(sizeof(char *) * 10));
        for(num = 0; num < 10; num++)
            save_files[num] = NULL;
        pres_sep = save_pat_p;
        ctr = 0;

        do
        {
            if ((next_sep = strchr(pres_sep, NAME_SEP_CHAR)) != NULL)
                *next_sep = '\0';
            save_files[ctr] = (char *) TET_MALLOC((size_t)(strlen(pres_sep)+1));
            save_files[ctr++] = pres_sep;

            if((ctr % 10) == 9)
            {
                save_files = (char **) TET_REALLOC((void *)save_files, (size_t)(sizeof(char *) * (ctr + 11)));
                for(num = ctr; num < (ctr + 11); num++)
                    save_files[num] = NULL;
            }
            if (next_sep != NULL)
                pres_sep = next_sep + 1;
        }
        while ( next_sep != NULL);
    }

    /* tet_env is not set until explicitly needed - helps debugging */
    tet_env = NULL;

    /* Everything is now set up ! */
    initialising = FALSE;

    /*
     *  Depending on what modes and options were selected we now call
     *  some heavy duty functions.
     */
    if (rerun_opt == TRUE)
    {
        /*
         *  do_again(RERUN) looks in the old journal file and reruns any 
         *  invocation cases that match the right results code, mode, etc..
         */
        if(do_again(RERUN) == FAILURE)
            exit_val = EXIT_BAD_MISC;
    }
    else
    {
        if (resume_opt == TRUE)
        {
            /*
             *  do_gain(RESUME) discovers the test case line (tc_line) and
             *  the invocable component number (ic_num) from which to
             *  continue processing from in the scenario file.
             */
            if(do_again(RESUME) == FAILURE)
                exit_val = EXIT_BAD_MISC;
            else
            {
                /* Process the scenario file */
                if(perform_scen() == FAILURE)
                    exit_val = EXIT_BAD_MISC;
            }
        }
        else 
        {
                if( scen_lines != NULL)
                {
                    /* Process specific scenario lines, if any */
                    for(num = 0; scen_lines[num] != NULL; num++)
                    {
                        process_line(scen_lines[num]);
			if (abort_requested == TRUE)
			    break;
                    }
                }

                /* Process the scenario file */
		if(abort_requested != TRUE)
                    if(scenario_name != NULL)
                        if(perform_scen() == FAILURE)
                            exit_val = EXIT_BAD_MISC;
        }
    }

    /* write the TCC end message to the journal file */
    (void) strcpy(msg,"TCC End");
    (void) jnl_entry_tcc_end(msg);
    (void) close(jnl_fd);

    tet_cleanup();

#ifdef DBGMEM
#ifdef DBGMEM2
    memory_table(1);
#else
    memory_table(0);
#endif
#endif

    exit(exit_val);

    /* NOTREACHED */
}


void build_temp_dir()
{
    /*
     * generate a unique name sub-directory under the TET
     * temporary directory named $$c, where $$ is process id, and
     * 'c' is a single letter (if directory with 'a' exists,
     * a retry with 'b' is done and so on).
     */
    pid_t pid = (getpid() % 100000);
    char ch = 'a', *line_p;
    int len,num,rc;

    /* make base dir string if we have not already done so */
    if(temp_base_dir[0] == '\0') {
	/* initialize 'temp_dir' from environment var $TET_TMP_DIR */
	if ((line_p = getenv("TET_TMP_DIR")) != NULL)
	    (void) strcpy(temp_base_dir,line_p);

	/* initialize 'alt_exec_dir' from environment var $TET_EXECUTE */
	line_p = getenv("TET_EXECUTE");
	if ( ! ((line_p == NULL) || (*line_p == '\0')))
	    (void) strcpy(alt_exec_dir,line_p);

	/*
	 *  If a tet tmp directory was not specified in the environment then 
	 *  create a directory under the tet root called "tet_tmp_dir".
	 */
	if(temp_base_dir[0] == '\0')
	{
	    /* The temporary directory will be created under tet_root. */
	    (void) sprintf(temp_base_dir,"%s/%s", tet_root, "tet_tmp_dir");
	}
    }

    /* build the base_dir if it doesn't exist */
    if (access(temp_base_dir,F_OK) != 0)
    {
        if (do_mkdir(temp_base_dir) == FAILURE)
        {
            (void) fprintf(stderr, "Cannot make TET tmp directory\n"); 
            tet_shutdown();
        }
    }


    (void) sprintf(temp_dir, "%s/%d%c", temp_base_dir, pid, ch);
#ifdef DBG
    (void) fprintf(stderr, "build_temp_dir(): {%s} %s\n", temp_base_dir, temp_dir);
#endif
    len = strlen(temp_dir);
    for (num = 0; num < 10; num++)
    {
        errno = 0;
        rc = do_mkdir(temp_dir);
        if (rc == FAILURE && errno == EEXIST)
        {
            ch++;
            temp_dir[len - 1] = ch;
            continue;    /* Try again if dir already exists */
        }
        else
            break;    /* Succeeded, or failed for another reason */
    }
    if (rc == FAILURE)
    {
        (void) fprintf(stderr,"Cannot make tet tmp sub-directory\n"); 
        tet_shutdown();
    }

}

/*
 * This routine determines the name of the config. file to open.  This
 * is based on the "priority" scheme in the spec.
 *
 * The "priorities" are:
 * 1) user specified file name  - use it (the name was already stored
 *     in *var by the command arg. parser)
 * 2) config. file in alternate exec. dir. - if it exists,  use it
 * 3) config. file in test suite root directory
 *
 * This routine just concerns itself with stuffing the name of the file
 * to parse in *var.
 */
void default_cfg_file(var, name)
char **var;
char *name;
{
#ifdef DBG
    (void) fprintf(stderr, "default_cfg_file(var, %s)\n", name);
#endif

    if (*var != NULL)  /* if user specified file name */
        return;

    if (alt_exec_set == TRUE)  /* if there is an alt. exec. dir. */
    {
        *var = (char *)TET_MALLOC(strlen(alt_exec_dir)+strlen(name)+4);
        (void) strcpy(*var,alt_exec_dir);

        if ((*var)[strlen(*var)-1] != DIR_SEP_CHAR)  
            (void) strcat(*var,DIR_SEP_STR);

        (void) strcat(*var,name);

        /* check to see that the file is there */
        if (access(*var,F_OK) == 0)
            return;
        else
            TET_FREE((void *)*var);
    }

    /*
     *  Build up the name of the file in the test suite root dir, +2 covers 
     *  the null char. at end,  plus potentially missing "dir. sep. char."
     */

    *var = (char *)TET_MALLOC2(strlen(test_suite_root)+strlen(name)+2);
    (void) strcpy(*var,test_suite_root);

    if ((*var)[strlen(*var)-1] != DIR_SEP_CHAR)  
        (void) strcat(*var,DIR_SEP_STR);

    (void) strcat(*var,name);

    return;
}

static int in_shutdown=0;

/*
 *  Something has gone wrong - we now attempt to exit gracefully. 
 *  NOTE: No BAIL_OUTS are permitted in this function !
 */
void tet_shutdown()
{
#ifdef DBG
    (void) fprintf(stderr, "tet_shutdown()\n");
#endif

    if (!in_shutdown) {
	in_shutdown++;
    	tet_cleanup();
    	if(initialising)
    	    exit(EXIT_BAD_INIT);
    	else
            exit(EXIT_BAD_MISC);
        in_shutdown--;
    }
}


/*
 *  Timeout during a Test Case - SIGALRM has been generated.
 */
/*ARGSUSED*/
void exec_sig_hdlr(throw_away)
int throw_away;
{
    int statloc,rc;

#ifdef DBG
    (void) fprintf(stderr, "exec_sig_hdlr(%d)\n", throw_away);
#endif

    if (cpid != 0)
    {
        (void) kill((pid_t)cpid,SIGTERM);

        rc = waitpid((pid_t)cpid,&statloc,0);
        COMPLAIN_ON(rc,"waitpid child in timeout handler ");

        cpid = 0;

        siglongjmp(jmpbuf,0);
    }

}


/*
 *  Timeout during a Tool Execution - SIGALRM has been generated.
 */
/* ARGSUSED */
void tool_sig_hdlr(throw_away)
int throw_away;
{
    int statloc;
    int rc;

#ifdef DBG
    (void) fprintf(stderr, "tool_sig_hdlr(%d)\n", throw_away);
#endif

    if (cpid != 0)
    {
         (void) kill((pid_t)cpid,SIGTERM);

         rc = waitpid((pid_t)cpid,&statloc,0);
         COMPLAIN_ON(rc,"waitpid child in timeout handler ");

         cpid = 0;

         siglongjmp(jmpbuf,0);
    }
}


/*
 *  What do we do in the event of a SIGINT - we don't panic thats what we do
 */
/* ARGSUSED */
void siginthdlr(throw_away)
int throw_away;
{
    int rc;

#ifdef DBG
    (void) fprintf(stderr, "siginthdlr(%d)\n", throw_away);
#endif

    /*
     * The interrupted flag is needed to check that a child recived a
     * SIGTERM due to the TCC and not some other source.
     */

    if(cpid != 0)
    {
        rc = kill((pid_t) cpid, SIGTERM);
        if(rc == -1 && errno == ESRCH)
            interrupted = 1;
        else
            interrupted = 2;

/*fdef SUNTEST		/* ETET extension */
    }
    (void) jnl_user_abort("User Abort");
    (void) fprintf(stderr,"\n**** TCC USER INTERRUPT ****\n\n");
    tet_shutdown();
/*lse
        (void) jnl_user_abort("User Abort");
        (void) fprintf(stderr,"\n**** TCC USER INTERRUPT ****\n\n");
    }
    else
	(void) fprintf(stderr,"\nNo child process available to interrupt !\n\nTry SIGQUIT if you wish to abort the tcc.\n\n");

/*ndif			/* ETET extension */

}

/* 
 *  What we do when we recieve any signal other than a SIGINT or SIGALRM
 */
void sighdlr(throw_away)
int throw_away;
{
#ifdef DBG
    (void) fprintf(stderr, "sighdlr(%d)\n", throw_away);
#endif

    if(cpid != 0)
        (void) kill((pid_t)cpid,SIGTERM);

    (void) sprintf(error_mesg,"**** TCC SHUTDOWN DUE TO SIGNAL %d ****\n",throw_away);

    (void) fprintf(stderr,"%s", error_mesg);
    (void) jnl_tc_message(error_mesg);

    tet_shutdown();
}


/*
 * A function to return the basename from a pathname, being careful
 * never to return a null pointer.
 * Arguments:
 * pointer to pathname string
 * Returns:
 * pointer to 'leafname' of the string
 */
char *basename(path)
char *path;
{
    char *sp;

    if ((sp = strrchr(path, DIR_SEP_CHAR)) != (char *) NULL)
    {
        if (*(sp + 1) != '\0')
            return(++sp);
        else
            return(sp);
    }
    else
        return(path);
}


/*
 * Try and remove any lock files and any temporary files.
 *  NOTE: No BAIL_OUTS are permitted in this function !
 */
void tet_cleanup()
{
#ifdef DBG
    (void) fprintf(stderr, "tet_cleanup()\n");
#endif

    switch(lock_type)
    {
    case 0:
    default:
        /* no lock set */
        break;
    case 1:
        release_exe_shrd_lock();
        break;
    case 2:
        release_exe_excl_lock();
        break;
    case 3:
        release_tool_lock();
        break;
    }
    if(temp_dir[0] != '\0')
        do_rm(temp_dir);

    /* Get back to where we started */
    (void) chdir(start_dir);

/*fdef SUNTEST			/* ETET extension */
    copy_flag = TRUE;
/*ndif				/* ETET extension */
}


/*
 * Pretty obvious from the name I hope ....
 */
void show_synopsis()
{
#ifdef DBG
    (void) fprintf(stderr, "show_synopsis()\n");
#endif

    (void) fprintf(stderr, "\n%s\n%s\n%s\n%s\n%s\n\n",
"Usage: tcc [ -b ] [ -e ] [ -c ] [ -a Alt_exec_dir ] [ -f Clean_cfg_file ]",
"    [ -g Build_cfg_file ] [ -i Int_results_dir ] [ -j Journal_file]",
"    [ -l Scenario_line ] [ -p ] [ -n Search_string ] [ -s Scenario_file]",
"    [ -t Timeout ] [ -v Variable=value ] [ -x Exec_cfg_file ]",
"    [ -y Search_string ] [ Test_suite [ Scenario ] ]");

    (void) fprintf(stderr, "%s\n\n%s\n",
"OR: tcc -m Code_list [ options ] Old_journal_file [ Test_suite [ Scenario ] ]",
"OR: tcc -r Code_list [ options ] Old_journal_file [ Test_suite [ Scenario ] ]"
	);
}


/*
 * A routine that allows more than one go at mallocing something
 */
void * tet_malloc(size_wanted, file_name, line_no, flag)
size_t size_wanted;
char * file_name;
int    line_no;
int    flag;
{
    char *mall_ptr;
    int tries = 0;

#ifdef DBGMEM
    mem_setup();
#endif

    while(tries < 5)
    {
        mall_ptr = (char *) malloc((size_t) size_wanted);
        if(mall_ptr != NULL)
            break;
        tries++;
        (void) sleep(2);
    }
    if(tries >= 5)
    {
        (void) fprintf(stderr,"Malloc failed. source file %s line %d\n", file_name, line_no);
        tet_shutdown();
    }

#ifdef DBGMEM
    {
        int memctr;

        for(memctr=0; memtable[memctr].line != -1; memctr++)
        {
            if (memtable[memctr].line == 0)
            {
                memtable[memctr].ptr = (long) mall_ptr;
                memtable[memctr].vol = (int) size_wanted;
                memtable[memctr].line = line_no;
		if (flag)
		{
                     (void) strcpy(memtable[memctr].file, "* ");
                     (void) strcat(memtable[memctr].file, file_name);
		}
		else
                     (void) strcpy(memtable[memctr].file, file_name);
                break;
            }
        }
#ifdef DBGMEM3
	(void) fprintf(stderr, "%-11s(%12ld %8d %20s %15d)\n", "tet_malloc",memtable[memctr].ptr, memtable[memctr].vol, memtable[memctr].file, memtable[memctr].line);
#endif
    }
#else
    tries = flag; /* silly little assignment to shut lint up */
#endif

    return((void *)mall_ptr);
}


/* ARGSUSED */
void tet_free( ptr, file_name, line_no)
#ifdef __STDC__
void *ptr;
#else
char *ptr;
#endif
char *file_name;
int line_no;
{
#ifdef DBGMEM
    int memctr;

    for(memctr=0; memtable[memctr].line != -1; memctr++)
    {
        if (memtable[memctr].ptr == (long) ptr)
        {
#ifdef DBGMEM3
	    (void) fprintf(stderr, "%-11s(%12ld %8d %20s %15d)\n", "tet_free",memtable[memctr].ptr, memtable[memctr].vol, memtable[memctr].file, memtable[memctr].line);
#endif
            memtable[memctr].line = 0;
            memtable[memctr].ptr = 0;
            break;
        }
    }
    if (memtable[memctr].line == -1)
        (void) fprintf(stderr,"Attempt to free pointer in source file %s line %d\nthat is not in memory table\n", file_name, line_no);
    else
        free((void *) ptr);
#else
        free((void *) ptr);
#endif
}


/*
 * A routine that allows more than one go at reallocing something
 */
void * tet_realloc(ptr, size_wanted, file_name, line_no, flag)
#ifdef __STDC__
void * ptr;
#else
char * ptr;
#endif
size_t size_wanted;
char * file_name;
int    line_no;
int    flag;
{
    char *mall_ptr;
    int tries = 0;

#ifdef DBGMEM
    mem_setup();
#endif

    while(tries < 5)
    {
        mall_ptr = (char *) realloc((void *) ptr, (size_t) size_wanted);
        if(mall_ptr != NULL)
            break;
        tries++;
        (void) sleep(2);
    }
    if(tries >= 5)
    {
        (void) fprintf(stderr,"Realloc failed. source file %s line %d\n", file_name, line_no);
        tet_shutdown();
    }

#ifdef DBGMEM
    {
        int memctr;

        for(memctr=0; memtable[memctr].line != -1; memctr++)
        {
            if (memtable[memctr].ptr == (long) ptr)
                break;
        }

        if (memtable[memctr].line == -1)
        {
            for(memctr=0; memtable[memctr].line != -1; memctr++)
            {
                if (memtable[memctr].line == 0)
                    break;
            }
        }
        memtable[memctr].ptr = (long) mall_ptr;
        memtable[memctr].vol = (int) size_wanted;
        memtable[memctr].line = line_no;
	if (flag)
	{
            (void) strcpy(memtable[memctr].file, "* ");
            (void) strcat(memtable[memctr].file, file_name);
	}
	else
            (void) strcpy(memtable[memctr].file, file_name);
#ifdef DBGMEM3
	(void) fprintf(stderr, "%-11s(%12ld %8d %20s %15d)\n", "tet_realloc",memtable[memctr].ptr, memtable[memctr].vol, memtable[memctr].file, memtable[memctr].line);
#endif
    }
#else
    tries = flag; /* silly little assignment to shut lint up */
#endif
    return((void *) mall_ptr);
}


#ifdef DBGMEM
void memory_table( flag)
int flag;
{
    int memctr, found_one = 0;

    for(memctr = 0; memtable[memctr].line != -1; memctr++)
    {
        if (memtable[memctr].line != 0)
        {
	    if ((flag == 0 && *(memtable[memctr].file) != '*') || (flag == 1))
	    {
                if (! found_one++)
                    (void) fprintf(stderr, "\n%40s\n%40s\n\n%12s %8s %20s %15s\n", "Memory Table Contents", "~~~~~~~~~~~~~~~~~~~~~", "Pointer", "Size", "Source File", "Line Number");
                (void) fprintf(stderr, "%12ld %8d %20s %15d\n", memtable[memctr].ptr, memtable[memctr].vol, memtable[memctr].file, memtable[memctr].line);
	    }
        }
    }
}
#endif


#ifdef DBGMEM
void mem_setup()
{
    int memctr, newctr;

    if (memtable == NULL)
    {
        if ((memtable = (MEMCHECK *) malloc((size_t) (sizeof(MEMCHECK) * 50))) == NULL)
        {
            (void) fprintf(stderr,"Malloc failed. source file %s line %d\n", __FILE__, __LINE__);
            tet_shutdown();
        }
        for(memctr = 0; memctr < 49; memctr++)
            memtable[memctr].line = 0;
        memtable[memctr].line = -1;
    }
    else
    {
        for(memctr = 0; (memtable[memctr].line != 0) && (memtable[memctr].line != -1); memctr++);
        if (memtable[memctr].line == -1) /* full */
        {
            if ((memtable = (MEMCHECK *) realloc((void *) memtable, (size_t) (sizeof(MEMCHECK) * (50+memctr+1)))) == NULL)
            {
                 (void) fprintf(stderr,"Realloc failed. source file %s line %d\n", __FILE__, __LINE__);
                 tet_shutdown();
            }
            for(newctr = memctr; newctr < (memctr+49); newctr++)
                memtable[newctr].line = 0;
            memtable[newctr].line = -1;
        }
    }
}
#endif


/*
 * get_artus_env() is used especially in ARTUS test suite.
 * It gets the environment setup for the test suite.
 */

#ifdef SUNTEST
static void
get_artus_env(char *tet_suite_root, char *st_name)
{
	char *envir_file;
	FILE *envir_fp;
	char *schar;
	char *buffer1;
	char *buffer2;

	buffer1 = (char *)malloc(1024);
	envir_file = (char *)malloc(strlen(tet_suite_root) + strlen(st_name)
            + strlen("/bin/") + strlen(".envir") + 3);
	schar =  &tet_suite_root[strlen(tet_suite_root) - 1];
	if ( *schar != '/')
		strcat(strcat(strcat(strcat(strcpy(envir_file, tet_suite_root),
			"/"), st_name), "/bin/"), ".envir");
	else
		strcat(strcat(strcat(strcpy(envir_file, tet_suite_root), st_name),
            "/bin/"), ".envir");
 
	if (access(envir_file,F_OK) == 0)
	{
		if ((envir_fp = fopen(envir_file, "r")) != NULL)
		{
			while((schar = fgets(buffer1, 1024, envir_fp)) != NULL)
			{
				buffer2 = (char *)malloc(strlen(buffer1));
				schar = strchr(buffer1, '\n');
				*schar = '\0';
				strcpy(buffer2, buffer1);
				tet_putenv(buffer2);
			}
			fclose(envir_fp);
			free(buffer1);
			free(envir_file);
		}
		else
		{
			free(buffer1);
			free(envir_file);
		}
	}
	else
		free(envir_file);
}
#endif
