#ident	"@(#)cplusbe:common/elfdebug.c	1.9"

/* Define db_curline whether or not LINT is defined since it is used
 * in lex.c and aclex.l.
 */

int db_curline = 0;		/* start line of current statement */

#ifndef LINT

/* Code to support standard debugging output in ELF format.  The various
** flavors of output that are supported are:
**
**	1)  Start and end of function.
**	2)  Start and end of block.
**	3)  Symbol.
**	4)  Line number.
**
*/


#include "p1.h"

#undef FIXED_FRAME     /*   FOR NOW */

#include "err.h"
#include "file.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/param.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "dwarf.h"
#include "dwarf2.h"
#include "abbrev.h"
#include "elfdebug.h"

/* definitions needed for dwarf_gen.h */

#define COMMENTS_IN_DEBUG	(s1debug)
#define ERROR_FUNCTION		cerror
#define ADDR_SIZE		(SZPOINT/SZCHAR)
#define DBOUT			dbout

/* These data support a stack of entries that holds the label numbers
** for the current information entry and its sibling pointer at each level.
** Used only for concrete inlined instance trees
*/
#ifndef INI_DBSTACK
#define INI_DBSTACK 5		/* initial maximum depth of stack */
#endif

typedef struct {
    int db_infolab;		/* label of current info entry */
    int db_sibling;		/* sibling of current entry */
} db_stack;
TABLE(Static, td_dbstack, static, db_stack_init,
		db_stack, INI_DBSTACK, 0, "debug sibling stack");
#define DB_CURINFOLAB \
	(TD_ELEM(td_dbstack,db_stack,TD_USED(td_dbstack)).db_infolab)
#define DB_CURSIBLING \
	(TD_ELEM(td_dbstack,db_stack,TD_USED(td_dbstack)).db_sibling)

static FILE * dbout = stdout;
static char * db_dbg_sec_name;
static char * db_line_sec_name;

/* Dwarf 2 - Line number state machine variables */
static int dw2_prev_line_label = 0;	/* label number of the previous .LN */
static int dw2_curr_line_label = 0;	/* label number of the current .LN */
static int dw2_file_index = 1;		/* index into the file name sequence. */
static int dw2_line_number = 1;		/* current line number. */

#include <dwarf_gen.h>

#define IS_BLOCK(x) ((x) == db_il_block || (x) == db_il_try_block \
			|| (x) == db_il_catch_block)

int db_symlevel = DB_LEVEL2;	/* symbol debugger info level */
static char * db_filename = "";	/* name of file for debug info */
static char * db_funcname = "";	/* name of function to generate label */
static int db_lastlineno;	/* line number at last line number output */

int db_format = DB_DWARF_2;	/* default debugging format */

int db_name_lookup = 0;		/* Dwarf 2 - name lookup section generation
					   - off by default (for now) */

int db_addr_ranges = 0;		/* Dwarf 2 - address range section generation
					   - off by default (for now) */

static SX		curr_function;

static int code_gen_in_diff_wd = 0;
				/* True (non-zero) if the code generation
				   is being done in a different working
				   directory than the preprocessing.
				   (i.e. the preprocessed file was moved or
				   using a relative path to get to the .i
				   file.) */

/* Used by the static function db_conv_seq_to_file_line() to store
   the results of converting a sequence number to a file and line number.
   Available for both Dwarf 1 and Dwarf 2 as needed. */
static int  db_curr_file_index;	/* the file index return for a specific
				   line sequence number. */
static int  db_curr_lineno;	/* the actual line number with in a file for 
				   a specific line sequence number. */
static int  db_artificial_function;	/* True (non-zero) indicates that the
					   current function is a compiler
					   generated function - no line
					   number information. */

#ifndef INI_ILSTACK
#define INI_ILSTACK 5		/* initial maximum depth of stack */
#endif

const char	*db_symbols_file;
static FILE	*db_sym_in;
static int	inline_lab_no;
static int	db_in_inline;	/* creating debug entries for an inlined instance */
static int	db_inline_needs_label; /* put out label at first call to db_s_block */
static int	db_create_entry; /* creating debug entries for an out-of-line instance */


#ifdef DBLINE
/* The i860 CG saves up trees in a basic block and then produces code for the
   block. acomp calls cgsync at the beginning and end of lexical blocks that
   declare local variables, to force the CG to generate the code for the
   lexical block between the markers for the block generated by db_s_block
   and db_e_block.

   We implement the policy described above by a finite state machine which
   keeps track of the lexical block markers and whether variables have
   been declared in the lexical block in db_state.  The values for db_state 
   are listed below.
*/

#define DB_INIT 0	
#define DB_START 1	
#define DB_CLEAR 2
static int db_state = DB_INIT;
static int db_func_start;

/* transitions for the finite statement machine are:
*,  	  db_s_block-> DB_START 
	  db_s_block && db_func_start == 1 -> DB_INIT (call cgsync)
DB_INIT,  db_sy_clear->DB_CLEAR   (call cgsync)
DB_START, db_symbol->  DB_INIT    (call cgsync)
*, 	  db_e_block-> DB_INIT
*/
#endif

/* Dwarf 2
**	Abbreviation Table Macros
*/
#define DB_DW2_END	0
#define DB_DW2_VERSION	2
#define DB_DW2_LINE_BASE	-100
#define DB_DW2_LINE_RANGE	220
#define DB_DW2_OPCODE_BASE	(DW_LNS_fixed_advance_pc + 1)


static void db_uclineno();
static void db_conv_seq_to_file_line(int);
static void db_dw2_upd_statement_prog(void);
static void db_add_src_file_to_table(char *, int);

extern int db_curline;		/* current statement line */

/* Table of include directories used in this compilation. */
#ifndef INI_DBINCDIR
#define INI_DBINCDIR 4
#endif  /* INI_DBINCDIR */

typedef struct {
    char  *dir_name;		/* include directory path name. */
    short  debug_index;		/* index assigned in the debugging line
				   statement prologue. */
} db_incdir;
TABLE(Static, td_dbincdir, static, db_incdir_init,
		db_incdir, INI_DBINCDIR, 0, "debug include directories");
#define DB_INCDIR_NAME(index) \
	(TD_ELEM(td_dbincdir, db_incdir, (index)).dir_name)
#define DB_INCDIR_DBINDEX(index) \
	(TD_ELEM(td_dbincdir, db_incdir, (index)).debug_index)
#define DB_INCDIR_USED	(TD_USED(td_dbincdir))

/* Table of source files used in this compilation. */
#ifndef INI_DBSRCFILE
#define INI_DBSRCFILE 10
#endif  /* INI_DBSRCFILE */

typedef struct {
    char   *pathname;		/* pathname used to open the file. */
    char   *filename;		/* source file name */
    off_t   byte_size;		/* file size in bytes */
    time_t  last_mod_time;	/* time file last modified. */
    short   dir_index;		/* index of include directory */
    short   debug_index;	/* index assigned in the debugging line
				   statement prologue. */
} db_srcfile;
TABLE(Static, td_dbsrcfile, static, db_srcfile_init,
		db_srcfile, INI_DBSRCFILE,0, "debug source files");
#define DB_SRCFILE_PATH(index) \
	(TD_ELEM(td_dbsrcfile, db_srcfile, (index)).pathname)
#define DB_SRCFILE_DBINDEX(index) \
	(TD_ELEM(td_dbsrcfile, db_srcfile, (index)).debug_index)
#define DB_SRCFILE_USED (TD_USED(td_dbsrcfile))

/* Data structure for tree of symbols and scopes to be updated in the
** debugging information.  This is used both for filling in location
** information in the children on regular functions and for creating
** whole new entries for inline functions.
*/
typedef struct db_info
{
	struct db_info		*next;
	struct db_info		*child;
	db_il_type		type;
	long			offset;
	union
	{
		struct
		{
			SX	symbol;
			int	low_pc;	/* high and low pc are label numbers */
			int	high_pc;
		} func;
		struct
		{
			int	scope;	/* unique scope id */
			int	low_pc;
			int	high_pc;
		} block;
		struct
		{
			SX	symbol;
			SX	new_symbol;	/* non-zero for concrete instance */
			char	addr_only;	/* put out just address, not full
						   location attribute */
			char	return_val_opt; /* return value optimization applies */
		} sym;
	} extra;
} db_info;

/* These data support a stack for creating lists of symbols to be updated
** for inline functions. 
*/
typedef struct
{
	db_info		*curr_scope;
	db_info		*head;
	db_info		*tail;
} update_stack;
TABLE(Static, td_update_stack, static, update_stack_init,
		update_stack, INI_DBSTACK, 0, "inline function stack");
#define DB_CURSCOPE \
	(TD_ELEM(td_update_stack,update_stack,TD_USED(td_update_stack)).curr_scope)
#define DB_HEAD \
	(TD_ELEM(td_update_stack,update_stack,TD_USED(td_update_stack)).head)
#define DB_TAIL \
	(TD_ELEM(td_update_stack,update_stack,TD_USED(td_update_stack)).tail)

static long prev_offset;
static void db_create_inline_func(int parent_id, db_info *);
static void db_walk_update_list(int parent_id, db_info *);
static void db_sym_location(SX sym, int addr_only, int return_val_opt);

static void
db_local_location(SX sid, int return_val_opt)
/* Generate an expression attribute for a parameter or local variable */
{
	const char *attr_name = "DW_AT_location";
	if (!sid) {
		/* Variable or parameter to inlined function that is not used in
		   the concrete instance.  A location attribute is not needed for
		   Dwarf1.  A null location is needed for Dwarf2 so that the
		   entry matches the abbreviation table entry. */
		if (IS_DWARF_2())
			dw2_out_loc_desc(attr_name, DW_FORM_block1, DB_DW2_END);
	} else if (SY_REGNO(sid) == SY_NOREG) {
		SY_CLASS_t	sid_class = SY_CLASS(sid);
		int		basereg = (sid_class == SC_AUTO)
					? DB_FRAMEPTR : DB_ARGPTR;
		int		offset = (sid_class == SC_AUTO)
					? SY_OFFSET(sid)
					: PARM_OFFSET(SY_OFFSET(sid));
		if (IS_DWARF_1()) {
			/* Dwarf 1 */
			const char *fr;
			int len = 1+4+1+4+1;
			if (return_val_opt)
				++len;
#ifdef FIXED_FRAME
			if (fixed_frame())
				++len;
#endif
			dwarf_out("\tH\txC", AT_location, "AT_location");
			dwarf_out("\tH\td; B x; W d; B x; W d;",
				len, OP_BASEREG, basereg, OP_CONST, offset);
#ifdef FIXED_FRAME
			if (fixed_frame())
				dwarf_out("s;", PLUS_FRAME_OFFSET_STRING);
#endif
			dwarf_out("B x;",OP_ADD);
			if (return_val_opt)
				dwarf_out("B x;", OP_DEREF);
			dwarf_out("C",OP_ADD, "OP_BASEREG OP_CONST [OP_DEREF] OP_ADD");
		} /* if */
#ifdef FIXED_FRAME
		else if (fixed_frame())
			dw2_out_loc_desc(attr_name, DW_FORM_block1,
					DW_OP_breg0 + basereg, offset,
					DW_OP_consts_as_string,
					PLUS_FRAME_OFFSET_STRING,
					return_val_opt ? DW_OP_deref : DB_DW2_END,
					DB_DW2_END);
#endif
		else
			dw2_out_loc_desc(attr_name, DW_FORM_block1,
					DW_OP_breg0 + basereg, offset,
					return_val_opt ? DW_OP_deref : DB_DW2_END,
					DB_DW2_END);
	} else {
		int regno = DB_OUTREGNO(SY_REGNO(sid));
		T1WORD t = TY_UNQUAL(SY_TYPE(sid));
		if (IS_DWARF_1()) {
			dwarf_out("\tH\txC", AT_location, "AT_location");
			if (t == TY_LLONG || t == TY_ULLONG || t == TY_SLLONG) {
				dwarf_out("\tH\td; B x; W d,dC",
					1+4+4, OP_SCO_REG_PAIR, regno, regno+1,
					"OP_SCO_REG_PAIR");
			} else {
				dwarf_out("\tH\td; B x; W dC",
					1+4, OP_REG, regno, "OP_REG");
			} /* if */
		} else {
			if (t == TY_LLONG || t == TY_ULLONG || t == TY_SLLONG) {
				dw2_out_loc_desc(attr_name, DW_FORM_block1,
					DW_OP_SCO_reg_pair, regno, regno+1, DB_DW2_END);
			} else if (regno >= (DW_OP_reg31 - DW_OP_reg0)) {
				/* This check may be overly cautious! */
				dw2_out_loc_desc(attr_name, DW_FORM_block1,
					DW_OP_regx, regno, DB_DW2_END);
			} else {
				dw2_out_loc_desc(attr_name, DW_FORM_block1,
					DW_OP_reg0 + regno, DB_DW2_END);
			} /* if */
		} /* if */
	}  /* if */
} /* db_local_location */

static void
db_push(void)
/* Start new level on debug stack.  New sibling label number is 0. */
{
    ++TD_USED(td_dbstack);		/* want to use another element */
    TD_NEED1(td_dbstack);
    TD_CHKMAX(td_dbstack);
    DB_CURSIBLING = 0;			/* no sibling yet */
}

static void
db_pop(int parent_id)
/* Exit current debug stack level. */
{
	/* generate sibling label */
	if (DB_CURSIBLING)
		dwarf_out("LI:\n", parent_id, DB_CURSIBLING);
	if (--TD_USED(td_dbstack) < 0)
		cerror("debug stack underflow");
}

static void
db_copy_infile(long prev_position, long position)
/* copy a subset of the debugging info to the assembly file */
{
	char	buf[BUFSIZ];
	long	len;

	if (prev_position > position)
		cerror("db_copy_infile(): update entries not in order");

	len = position - prev_position;
	while (len)
	{
		size_t	bytes_to_read = (len < BUFSIZ) ? len : BUFSIZ;

		if (fread(buf, sizeof(char), bytes_to_read, db_sym_in) <= 0)
			break;
		fwrite(buf, sizeof(char), bytes_to_read, dbout);
		len -= bytes_to_read;
	}
} /* db_copy_infile */

/* Label number used in creating entries for inline functions.  Labels take the
** form function_id.local_label to avoid conflicts with the debugging entries
** generated by the front end.
*/
static int local_label;

static void db_s_entry(int parent_id, int tag)
{
	int sibling;

	if ((sibling = DB_CURSIBLING) == 0)
		sibling = ++local_label;
	DB_CURINFOLAB = sibling;
	DB_CURSIBLING = ++local_label;
	dwarf_out("LI:\n", parent_id, DB_CURINFOLAB);
	dwarf_out("\tluC", tag, "abbrev table index");
} /* db_s_entry */

static void db_inline_sym(SX sid, SX new_sid, int parent_id)
/* Create a new debugging entry for a parameter or local variable in a function
** being inlined.  This deals only with Dwarf2, since the compiler is not dealing
** with inlines when generating Dwarf1.
*/
{
	SY_CLASS_t	sy_class;
	const char	*name;
	int		tag;

	sy_class = SY_CLASS(sid);
	name = SY_NAME(sid);
	if (s1debug)
		fprintf(dbout, "/ sym (%d) = %s:\n", sid, name ? name : "");
	switch (sy_class) {
	case SC_LABEL:
		if (!new_sid) /* not replicated in inlined instance */
			return;
		db_s_entry(parent_id, DW2_label_concrete);
		dwarf_out("\tW\tLd-sC", SY_DEBUG_ID(sid),
			LAB_INFOBEGIN, "DW_AT_abstract_origin");
		dwarf_out("\tW\tLLC", SY_OFFSET(new_sid), "DW_AT_low_pc");
		break;

	case SC_EXTERN:
	case SC_STATIC:
		/* Could have a static variable declarated within an inline function */
		db_s_entry(parent_id, DW2_variable_concrete);
		dwarf_out("\tW\tLd-sC", SY_DEBUG_ID(sid),
			LAB_INFOBEGIN, "DW_AT_abstract_origin");
		db_sym_location(sid, 0, 0);
		break;

	case SC_PARAM:
		tag = DW2_formal_param_concrete;
		goto do_local;

	default:
		tag = DW2_variable_concrete;
do_local:
		db_s_entry(parent_id, tag);
		dwarf_out("\tW\tLd-sC", SY_DEBUG_ID(sid), LAB_INFOBEGIN,
			"DW_AT_abstract_origin");
		db_local_location(new_sid, 0);
		break;
	} /* switch */
} /* db_inline_sym */

static void db_sym_location(SX sym, int addr_only, int return_val_opt)
/* Generate a location attribute for a symbol */
{
	if (!sym) {
		/* A symbol that is not assigned a location  */
		if (IS_DWARF_2()) {
			if (addr_only)
				dwarf_out("\tW x\n", 0);
			else
				dw2_out_loc_desc("DW_AT_location",
					DW_FORM_block1, DB_DW2_END);
		} /* if */
		return;
	} /* if */

	switch (SY_CLASS(sym)) {
	case SC_LABEL:
		if (IS_DWARF_1()) {
			/* Dwarf 1 */
			if (!addr_only)
				dwarf_out("\tH\tx;", AT_low_pc);
			dwarf_out("\tW LLC", SY_OFFSET(sym), "AT_low_pc");
		} else {
			/* Dwarf 2 */
			dwarf_out("\tW\tLLC", SY_OFFSET(sym), "DW_AT_low_pc");
		} /* if */
		break;
	case SC_EXTERN:
	case SC_STATIC:
		if IS_DWARF_1() {
			/* Dwarf 1 */
			if (addr_only) {
				dwarf_out("\tW s\n", cg_extname(sym));
			} else {
				dwarf_out("\tH\txC", AT_location, "AT_location");
				dwarf_out("\tH\td; B x; W sC", 1+4, OP_ADDR, cg_extname(sym),
				"OP_ADDR");
			} /* if */
		}  else {
			/* Dwarf 2 */
			if (addr_only) {
				dwarf_out("\tW s\n", cg_extname(sym));
			} else {
				dw2_out_loc_desc("DW_AT_location",
					DW_FORM_block1,  /* should hold it  */
					DW_OP_addr, cg_extname(sym), DB_DW2_END);
			} /* if */
		} /* if */
		break;
	default:
		db_local_location(sym, return_val_opt);
		break;
	} /* switch */
} /* db_sym_location */

static void
db_update_sym(int parent_id, db_info *entry)
{
	if (db_in_inline) {
		if (entry->extra.sym.symbol)
			db_inline_sym(entry->extra.sym.symbol,
				entry->extra.sym.new_symbol, parent_id);
	} else if (db_create_entry) {
		if (entry->extra.sym.symbol)
			db_inline_sym(entry->extra.sym.symbol,
				entry->extra.sym.symbol, parent_id);
	} else {
		db_copy_infile(prev_offset, entry->offset);
		prev_offset = entry->offset;
		db_sym_location(entry->extra.sym.symbol,
				entry->extra.sym.addr_only,
				entry->extra.sym.return_val_opt);
	} /* if */
} /* db_update_sym */

static void
db_gen_inline_block(int parent_id, db_info *entry)
/* Create a new debugging entry for a block scope in an inlined function */
{
	int tag;
	if (entry->type == db_il_block)
		tag = DW2_lexical_block_concrete;
	else if (entry->type == db_il_try_block)
		tag = DW2_try_block_concrete;
	else
		tag = DW2_catch_block_concrete;
	db_s_entry(parent_id, tag);
	dwarf_out("\tW\tLI-sC", parent_id, DB_CURSIBLING, LAB_INFOBEGIN,
			"DW_AT_sibling");
	dwarf_out("\tW\tLS-sC", entry->extra.block.scope, LAB_INFOBEGIN,
			"DW_AT_abstract_origin");
	if (entry->extra.block.low_pc) {
		dwarf_out("\tW\tLLC", entry->extra.block.low_pc, "DW_AT_low_pc");
		dwarf_out("\tW\tLLC", entry->extra.block.high_pc, "DW_AT_high_pc");
	} else {
		dwarf_out("\tW\tLlC", entry->extra.block.scope, "DW_AT_low_pc");
		dwarf_out("\tW\tLhC", entry->extra.block.scope, "DW_AT_high_pc");
	}
} /* db_gen_inline_block */

static void
db_update_block_entries(int parent_id, db_info *entry)
{
	db_info	*list = entry->child;
	db_info	*prev = 0;

	if (db_in_inline || db_create_entry)
		db_gen_inline_block(parent_id, entry);

	if (list) {
		db_push();
		while (list) {
			if (list->type == db_il_symbol) {
				db_update_sym(parent_id, list);
			} else if (list->type == db_il_function) {
				break;
			} else {
				db_update_block_entries(parent_id, list);
			} /* if */

			prev = list;
			list = list->next;
			free(prev);
		} /* for */
	} /* if */
	
	if (!db_in_inline && !db_create_entry) {
		db_copy_infile(prev_offset, entry->offset);
		prev_offset = entry->offset;
	} /* if */
	dwarf_out("C", "inline entries, if any, go here");
	db_walk_update_list(parent_id, list);
	
	if (entry->child) {
		db_pop(parent_id);
		if (db_in_inline || db_create_entry)
			dwarf_out("\tB\txC", DB_DW2_END, "end sibling chain");
	} /* if */
} /* db_update_block_entries */

static void
db_create_inline_func(int parent_id, db_info *entry)
/* Create debugging entries for an inlined function and all its children */
{
	debug_updates	*header;
	const char	*name;
	long		*offset;	/* unused */

	if (IS_DWARF_1())
		return;

	++db_in_inline;
	header = region_updates[SY_DEBUG_ID(entry->extra.func.symbol)];
	name = SY_NAME(entry->extra.func.symbol);

	if (s1debug)
		fprintf(dbout, "/ sym (%d) = %s:\n", entry->extra.func.symbol,
				name ? name : "");
	db_s_entry(parent_id, DW2_inlined_subroutine);
	dwarf_out("\tW\tLI-sC", parent_id, DB_CURSIBLING, LAB_INFOBEGIN, "DW_AT_sibling");
	dwarf_out("\tW\tLd-sC", header->debug_id, LAB_INFOBEGIN, "DW_AT_abstract_origin");
	dwarf_out("\tW\tLiC", entry->extra.func.low_pc, "DW_AT_low_pc");
	dwarf_out("\tW\tLiC", entry->extra.func.high_pc, "DW_AT_high_pc");

	if (entry->child) {
		db_push();
		db_walk_update_list(parent_id, entry->child);
		db_pop(parent_id);
	} /* if */
	dwarf_out("\tB\txC", DB_DW2_END, "end sibling chain");
	--db_in_inline;
} /* db_create_inline_func */

static void
db_walk_update_list(int parent_id, db_info *list)
/* Walk the list of entries needing updating, generating location attributes,
** or if in an inlined function, creating new entries
*/
{
	while (list) {
		db_info	*prev;

		switch (list->type) {
		case db_il_function:
			db_create_inline_func(parent_id, list);
			break;

		case db_il_block:
		case db_il_try_block:
		case db_il_catch_block:
			db_update_block_entries(parent_id, list);
			break;

		case db_il_symbol:
			db_update_sym(parent_id, list);
			break;
		} /* switch */

		prev = list;
		list = list->next;
		free(prev);
	} /* for */
} /* db_walk_update_list */

static void
db_create_out_of_line_instance(SX sid, db_info *updates)
{
	int		region = SY_DEBUG_ID(sid);
	debug_updates	*node = region_updates[region];
	const char	*name;

	if (IS_DWARF_1() || !node || !node->debug_id) {
		/* compiler-generated function, like __sti__*, or generating
		** Dwarf 1, and not attempting to handle inlines */
		return;
	} /* if */

	dwarf_out("Sd");
	name = SY_NAME(sid);
	if (s1debug)
		fprintf(dbout, "/ sym (%d) = %s:\n", sid, name ? name : "");
	node->out_of_line_instance = 1;
	local_label = 0;

	dwarf_out("\tluC", DW2_out_of_line_instance, "abbrev table index");
	dwarf_out("\tW\tLI-sC", region, 0, LAB_INFOBEGIN, "DW_AT_sibling");
	dwarf_out("\tW\tLd-sC", node->debug_id, LAB_INFOBEGIN,
		"DW_AT_abstract_origin");
	dwarf_out("\tW\tsC", cg_extname(sid), "DW_AT_low_pc");
	dwarf_out("\tW\tLHC", (int)sid, "DW_AT_high_pc");
	if (updates) {
		db_push();
		db_create_entry = 1;
		db_walk_update_list(region, updates);
		db_create_entry = 0;
		db_pop(region);
	} /* if */
	dwarf_out("\tB\txC", DB_DW2_END, "end sibling chain");
	dwarf_out("LI:C", region, 0, "routine entry sibling");
	dwarf_out("St");			/* force to .text */
} /* db_create_out_of_line_instance */

void
db_apply_updates(SX sid, db_info *updates, db_info *inlines)
/* db_apply_updates is called after the code for a function has been generated.
** It copies the debugging entries for the function to the intermediate file,
** in the process adding in locations for local variables and blocks, and
** generating enries for inlined functions.  inlines is the list of functions
** inlined at function scope.  updates is the list of locals
** and blocks, which may themselves have contain lists of inlined functions.
*/
{
	debug_updates	*header;
	long		region;
	int		debug_id;

	if (db_symlevel != DB_LEVEL2 || !db_sym_in)
		return;

	region = sid ? SY_DEBUG_ID(sid) : 1;
	debug_id = sid ? SY_DEBUG_ID(sid) : 0;
	header = region_updates[region];
	if (!header)
		return;
	if (sid && !header->routine_offset) {
		/* inline function */
		db_create_out_of_line_instance(sid, updates);
		return;
	} /* if */

	fseek(db_sym_in, header->first_offset, SEEK_SET);
	dwarf_out("Sd");
	db_copy_infile(header->first_offset, header->routine_offset);

	/* put out high and low pc values for function */
	if (IS_DWARF_1()) {
		/* Dwarf 1 */
		/* Low pc for a function is the same as the function's label. */
		dwarf_out("\tH\tx; W\tsC", AT_low_pc, cg_extname(sid), "AT_low_pc");
		dwarf_out("\tH\tx; W\tLHC", AT_high_pc, (int)sid, "AT_high_pc");
	} else {
		/* Dwarf 2 */
		dwarf_out("\tW\tsC", cg_extname(sid), "DW_AT_low_pc");
		dwarf_out("\tW\tLHC", (int)sid, "DW_AT_high_pc");
	} /* if */
	prev_offset = header->routine_offset;

	local_label = 0;
	db_push();
	db_walk_update_list(debug_id, updates);
	if (inlines) {
		db_copy_infile(prev_offset, header->inline_insert);
		prev_offset = header->inline_insert;
		db_walk_update_list(debug_id, inlines);
	} /* if */
	db_pop(debug_id);
	db_copy_infile(prev_offset, header->last_offset);
	dwarf_out("St");			/* force to .text */
} /* db_apply_updates */

static void
db_dw2_init_line_section(void)
/* Generate the Statement Program Prologue as defined in 6.2.4 of the
   Dwarf Debugging Information Format 2.0. Also initialize the variables
   used to represent the "current" values of the line number state 
   machine.
*/
{
    int index, limit;
    int index_assigned;

    /* First generate the prologue which will have the following format.

	.section .debug_line
      ..line_b:
	.uaword ..line.e-..line_b-4	/ length of statement info
	.uahalf 0x2			/ version 2
	.uaword ..LN.e-..LN.b		/ statement program prologue length
      ..LN.b:
	.uabyte 0x1			/ minimum instruction length
	.uabyte 0x1			/ default - is statement
	.uabyte aaa			/ line base
	.uabyte bbb			/ line range
	.uabyte ccc			/ opcode base
	.uabyte n n n n...		/ standard_opcode operand counts
	.string "xxxx"			/ sequence of include directory
	.string .......			/     path names
	.uabyte 0x0			/ include directory sequence termination
	.string "<file_name>"		/ sequence of file entries - name
	.leb128 0xnnn			/     directory index
	.leb128 <file_last_mod_date>	/     write date of file
	.leb128 <file_length>		/     file byte length
	.uabyte 0x0			/ file entry sequence termination
      ..LN.e:
    */
    dwarf_out("Sl.b\tW\tLe-Lb-4C\tH\txC\tW\tLP-LpCLp:\n\tB\txC\tB\txC\tB\tdC\tB\tdC\tB\tdC",
	   "Dwarf 2 - start line number section",
	   DB_DW2_VERSION /*version 2*/, "version 2",
	   "statement program prologue length",
	   1, "minimum instruction length",
	   1, "default - is statement",
	   DB_DW2_LINE_BASE, "line base",
	   DB_DW2_LINE_RANGE, "line range",
	   DB_DW2_OPCODE_BASE, "opcode base");
    /* Output the array of bytes representing the operand count for each
       standard opcode (opcode_base - 1 bytes) */
    dwarf_out("\tB\td,d,d,d,d,d,d,d,dC", 0, 1, 1, 1, 1, 0, 0, 0, 1,
	   "standard opcode operand counts");
    /* Output a sequence of names representing the set of include 
       directories used by the compiler.  The "current" working directory
       is represented at index ZERO and is not emitted in DWARF 2. */
    for (index = 1, index_assigned = 1, limit = DB_INCDIR_USED;
	 index < limit;
	 index++) {
	dwarf_out("bC", DB_INCDIR_NAME(index), "include directory");
	DB_INCDIR_DBINDEX(index) = index_assigned++;
    }  /* for */

    /* Terminate the include directory path name sequences */
    dwarf_out("\tB\txC", 0, "terminate include directories");

    /* Output the sequence of source file entries for this compilation. */
    for (index = 0, limit = DB_SRCFILE_USED;
	 index < limit;
	 index++) {
	db_srcfile *src_ptr;

	src_ptr = &(TD_ELEM(td_dbsrcfile, db_srcfile, (index)));
	dwarf_out("bC\tluC\tluC\tluC",
	       src_ptr->filename, "source file name",
	       DB_INCDIR_DBINDEX(src_ptr->dir_index), "directory index",
	       src_ptr->last_mod_time, "time of last modification",
	       src_ptr->byte_size, "file size in bytes");
    }  /* for */

    /* Terminate the file name sequences. */
    dwarf_out("\tB\txCLP:\n", 0, "terminate source file info sequences");
 
    /* Now generate a "DW_LNE_set_address" expended opcode instruction
       to set the address register to that of ..text.b. */
    dwarf_out("\tB\tx;\tlu;\tB\tx;\tW\tLBC", 0, (1 + SZPOINT/SZCHAR),
	   DW_LNE_set_address, "DW_LNE_set_address");
    dwarf_out("St");			/* force to .text */
}  /* db_dw2_init_line_section */

void
db_begfile(long length)
/* Generate initial debug information after the rest of the compiler
** has decided on .file and .ident pseudo-ops.
*/
{
	if (db_symlevel == DB_LEVEL0 || !db_symbols_file
		|| (db_sym_in = fopen(db_symbols_file, "r")) == 0)
		return;

	/* copy debugging information prologue */
	while (length)
	{
		char	buf[BUFSIZ];
		size_t	bytes_to_read = (length < BUFSIZ) ? length : BUFSIZ;

		if (fread(buf, sizeof(char), bytes_to_read, db_sym_in) <= 0)
			break;
		fwrite(buf, sizeof(char), bytes_to_read, dbout);
		length -= bytes_to_read;
	} /* while */

	if (IS_DWARF_1()) {
		/* Dwarf 1 */
		db_dbg_sec_name = DB_DOTDEBUG;
		db_line_sec_name = DB_DOTLINE;
		/* Set up start of line number information. */
		dwarf_out("Sl.b\tW\tLe-Lb; W\tLB\n");
	}  else {
		/* Dwarf 2 */
		db_dbg_sec_name = DB_DOTDBG_INFO;
		db_line_sec_name = DB_DOTDBG_LINE;
		/* Generate start of line number information */
		db_dw2_init_line_section();
	}  /* if */
	/* Set beginning of text label */
	dwarf_out("St");			/* force to .text */
	dwarf_out(".B");
}  /* db_begfile */

void
db_s_file(s)
char * s;
/* Do what needs to be done for debug information at the start of a file. */
{
    db_filename = st_lookup(s);		/* remember filename for later */
    if (db_symlevel == DB_LEVEL2) {
	/* If this is a normal compilation, this filename will be identical
	   to the primary source file.  If this is a compilation of
	   preprocessed source (-E), then this may be different and should
	   take precedence. */
	if (DB_SRCFILE_USED >= 1) {
	    db_add_src_file_to_table(s, 0);
	}  /* if */
    } /* if */
}


void
db_s_cwd(s)
char * s;
/* Record the current working directory.  If this is not the first
   call of this function, preprocessed source is being compiled and
   a "#pragma working_directory" has been seen.  The current working
   directory and include directories will be reset to those in
   effect at the time of preprocessing.
*/
{
    if (db_symlevel == DB_LEVEL2) {
	if (DB_INCDIR_USED != 0) {
	    /* A "#pragma working_directory" has been seen; this is 
	       preprocessed input (or generated C for C++ source).
	       Check if the compilation/code generation is being
	       done in the same directory (important to correctly
	       lookup the date stamp and file size of the source
	       file(s) involved in this compilation. */
	    if (strcmp(s, DB_INCDIR_NAME(0)) != 0) {
		code_gen_in_diff_wd = 1;	/* TRUE */
		DB_INCDIR_NAME(0) = s = st_lookup(s);
	    }  /* if */
	    return;
	}  /* if */

	/* Start the table (array) from the first entry. */
	DB_INCDIR_USED = 0;		/* In case, this is not 1st call. */
	TD_NEED(td_dbincdir, 1);
	DB_INCDIR_NAME(0) = s = st_lookup(s);
					/* remember directory for later */
	DB_INCDIR_DBINDEX(0) = 0;	/* The index of the "current
					   working directory" is 0 - Dwarf 2 */
	DB_INCDIR_USED++;
    } /* if */
}  /* db_s_cwd */


void
db_reg_incdir(s)
char * s;
/* Enter the include directory specified by the string "s" into the
   include directory stack.  The first directory entered should be
   the "current working directory"; done with call to db_s_cwd(). */
{
    if (db_symlevel == DB_LEVEL2) {
	TD_NEED(td_dbincdir, 1);
	DB_INCDIR_NAME(DB_INCDIR_USED) = s = st_lookup(s);
					/* remember directory for later */
	DB_INCDIR_DBINDEX(DB_INCDIR_USED) = 0;
	DB_INCDIR_USED++;
    } /* if */
}  /* db_reg_incdir */


static void
db_add_src_file_to_table(name, index)
char * name;
int index;
/*
   Add the file name specified by "name" to the source file table at
   the specified index "index".  Typically, the index would be for the
   next available spot in the table, but, the primary source file
   information may be overwritten as a result of encountering a
   "#pragma file" directive in preprocessed input.
*/
{
	int inc_index, limit;
	db_srcfile *src_ptr;
	char dir_path[MAXPATHLEN+1];
	char * null_spot = 0;
	char * filename = 0;
	struct stat file_stat;
	int    byte_size = 0;		/* default - info not available. */
	time_t last_mod_time = 0;	/* default - info not available. */

	static time_t dot_i_time_stamp = 0;
	static int    preprocessed_input = 0;

	/* Add the file to the table (array).  The index value should be equal
	   to DB_SRCFILE_USED for new entries.  A value of zero implies that
	   the primary source file is being entered for a second time. */
#ifndef NODBG
	if (index > DB_SRCFILE_USED)
		cerror("db_add_src_file_to_table: file index too large.\n");
#endif
	if (index == (limit = DB_SRCFILE_USED)) {
		TD_NEED(td_dbsrcfile, 1);	/* Insure enough space. */
		DB_SRCFILE_USED++;
	}  /* if */

	src_ptr = &TD_ELEM(td_dbsrcfile, db_srcfile, index);

	if (index < limit) {
		/* This should only happen if a "#file" directive was
		   encountered (preprocessed input). */
#ifndef NODBG
		if (index != 0) {
			cerror("db_add_src_file_to_table: file index incorrect (not zero)\n");
		}  /* if */
#endif
		/* Updating the primary source file name; save the time stamp
		   of the .i file. */
		dot_i_time_stamp = src_ptr->last_mod_time;
		preprocessed_input = 1;		/* TRUE */
	}  /* if */

	src_ptr->pathname = st_lookup(name);
	/* The first file, added at index 0, is actually file number 1
	   in the debugging (Dwarf 2) info scheme of things.  Adjust the file
	   index number assigned accordingly. */
	src_ptr->debug_index = ++index;

	if (   *name != '/'		/* relative file name */
		&& code_gen_in_diff_wd) {
		/* We are compiling preprocessed source in a different
		   directory than the one in which the preprocessing was done.
		   Why anyone would do this is not obvious or logical, but
		   we can do the the stat() call with a complete path name for 
	   	   relative file names....... complete with the working
		   directory from the "#pragma working_directory". */

		int len;
		/* Construct a full path name. */
		strcpy(dir_path, DB_INCDIR_NAME(0));
		len = strlen(dir_path);
		if (dir_path[len - 1] != '/') {
			dir_path[len++] = '/';		/* Add trailing '/'. */
		}  /* if */
		strcpy(&dir_path[len], name);
	} else {
		strcpy(dir_path, name);
	} /* if */

	if (stat(dir_path, &file_stat) == 0) {
		/* Everything is OK - have valid data. */
		byte_size = file_stat.st_size;
		last_mod_time = file_stat.st_mtime;
	}  /* if */

	/* If compiling preprocessed source, check if this source file has been
	   modified since the .i file was created. */
	if (   preprocessed_input
		&& dot_i_time_stamp < last_mod_time) {
		/* This source file has been modified since the preprocessing
		   has been done.  The stat() information is meaningless. */
		byte_size = 0;
		last_mod_time = 0;	/* This could be set to the .i time
					   as the last known valid time. */
	}  /* if */
	src_ptr->byte_size = byte_size;
	src_ptr->last_mod_time = last_mod_time;

	if (index == 1) {
		/* primary source file is always either an absolute path name
		   or relative to the current working directory - in either
		   case inc_index is zero */
		filename = name;
		inc_index = 0;
		goto complete_source;
	} /* if */

	/* Break the pathname down into the largest directory name
	   contained in the directory table and the base file name. */
	limit = DB_INCDIR_USED;		/* Establish the upper limit of the
					   include directory table (array). */
	for (;;) {
		inc_index = 0;		/* set the default include directory
					   index as the "working directory"
					   for all special cases encountered
					   before any search. */
		filename = strrchr(dir_path, '/');
		/* put previous '/' back */
		if (null_spot) *null_spot = '/';
		if (! filename) {
			/* No remaining '/' found in the path.  File must be
			   releative to the current working directory. */
			filename = dir_path;
			goto complete_source;
		}  else {
			/* Have located the next '/' from the rear. */
			null_spot = filename;
			*(filename++) = '\0';/* terminate the directory name */

			/* Check for reference to the current working directory. */
			if (   (strlen(dir_path) == 1)
				&& (dir_path[0] == '.')) {
				/* This is a file name beginning with "./". */
				goto complete_source;
			}  /* if */
			/* If it is an absolute path name beginning with a '/'
			   and it has not matched with an include directory
			   pathname that begins with a '/', mark as an absolute
			   filename in the current working directory. */
			if (null_spot == dir_path) {
				*null_spot = '/';
				filename = dir_path;
				goto complete_source;
			}  /* if */
		}  /* if */
	
		for (inc_index = 0; inc_index < limit; inc_index++) {
			if (strcmp(dir_path, DB_INCDIR_NAME(inc_index)) == 0 ){
				/* Found a match.  Go to complete_source. */
				if (inc_index == 0 && code_gen_in_diff_wd) {
					/* use absolute path for file
					   compiled in a different directory */
					if (null_spot) *null_spot = '/';
					filename = dir_path;
				} /* if */
				goto complete_source;
			}  /* if */
		}  /* for */
	}  /* for */

complete_source:
	src_ptr->filename = st_lookup(filename);
	src_ptr->dir_index = inc_index;
}  /* db_add_src_file_to_table */


int
db_reg_file(name)
char * name;
/* Enter the source file name specified by the string "s" into the
   source file stack.  The first source file entered should be the
   primary source file. */
{
    int index, limit;

    if (db_symlevel == DB_LEVEL2) {
	if (name) {
	    for (index = 0, limit = DB_SRCFILE_USED; index < limit; index++) {
		if (strcmp(name, DB_SRCFILE_PATH(index)) == 0) {
		    /* The file is already in the source file table at
		       the "index" element. */
		    goto return_file_index;
		}  /* if */
	    }  /* for */
	    /* The file is not in the source file table; add it at the
	       next available spot - "index" */
	    db_add_src_file_to_table(name, index);
return_file_index:
	    return DB_SRCFILE_DBINDEX(index);
	}  /* if */
    } /* if */
    return 0;				/* no debugging to be generated, or
					   no file name. */
}  /* db_reg_file */



void
db_e_file()
/* Do what needs to be done for debug information at the end of the
   primary source file. */
{
    extern int		highest_used_region_number;

    debug_updates	**ptr;
    debug_updates	*header;
    int			i;

    if (db_symlevel == DB_LEVEL0 || !db_sym_in)
	return;

    dwarf_out("St");			/* force to .text */
    dwarf_out(".E");			/* end of text label */
    /* Final line number (zero) with end-of-text.  Then lay down end
    ** of line numbers label.
    */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	dwarf_out("Sl\tW\t0; H x; W LE-LB\n", 0xffff);
    } else {
	/* Dwarf 2 */
	dwarf_out("Sl\tB\tx;\tH\tLE-LnC\tB\tx;\tlu;\tB\txC", DW_LNS_fixed_advance_pc,
		"DW_LNS_fixed_advance_pc", 0, 1, DW_LNE_end_sequence,
		"DW_LNE_end_sequence");
    } /* if */
    dwarf_out(".e");			/* force to .text */

    dwarf_out("Sd");
    /* Copy through definitions of inline functions */
    ptr = &region_updates[2];
    for (i = highest_used_region_number - 1; i; --i, ++ptr) {
	header = *ptr;
	if (!header || header->routine_offset || !header->first_offset) {
		/* regular or compiler-generated function */
		continue;
	} /* if */

	fseek(db_sym_in, header->first_offset, SEEK_SET);
	db_copy_infile(header->first_offset, header->inline_insert);
	if (IS_DWARF_1()) {
		dwarf_out("\tH\tx; B\txC", AT_inline, 0, "AT_inline");
	} else {
		/* Dwarf2 */
		dwarf_out("\tB\txC",
			header->has_been_inlined ? DW_INL_declared_inlined
						 : DW_INL_declared_not_inlined,
			"DW_AT_inline");
	} /* if */
	db_copy_infile(header->inline_insert, header->last_offset);
    } /* for */

    /* Supply locations for global variable entries */
    header = region_updates[1];
    prev_offset = header->first_offset;
    fseek(db_sym_in, prev_offset, SEEK_SET);

    if (header->updates || header->last_offset != prev_offset) {
	update_list	*list;

	for (list = header->updates; list; list = list->next) {
	    db_copy_infile(prev_offset, list->offset);
	    prev_offset = list->offset;
	    db_sym_location(list->variant.symbol.sid,
				list->variant.symbol.addr_only,
				list->variant.symbol.return_val_opt);
	} /* for */
	db_copy_infile(prev_offset, header->last_offset);
    } /* if */
    dwarf_out("St");			/* force to .text */
}  /* db_e_file */

static db_info *
db_copy_updates(update_list *list)
/* Translate the abstract update list into the form for a specific instantiation */
{
	db_info	*head = 0;
	db_info	*tail = 0;

	for (; list; list = list->next) {
		db_info	*ptr;
		if ((ptr = (db_info *)malloc(sizeof(db_info))) == 0)
			cerror("db_copy_updates: cannot malloc");
		if (tail)
			tail->next = ptr;
		else
			head = ptr;
		tail = ptr;
		ptr->next = 0;
		ptr->offset = list->offset;
		ptr->type = list->item_type;
		if (IS_BLOCK(list->item_type)) {
			ptr->child = db_copy_updates(list->variant.scope.child);
			ptr->extra.block.scope = list->variant.scope.scope_id;
			ptr->extra.block.high_pc = 0;
			ptr->extra.block.low_pc = 0;
		} else {
			ptr->extra.sym.symbol = list->variant.symbol.sid;
			ptr->extra.sym.new_symbol = 0;
			ptr->extra.sym.addr_only = list->variant.symbol.addr_only;
			ptr->extra.sym.return_val_opt = list->variant.symbol.return_val_opt;
			ptr->child = 0;
		} /* if */
	} /* for */
	return head;
}

void
db_begf(sid)
SX sid;
/* Do debug stuff at start of function definition. */
{
    static db_info	f_info;

    if (db_symlevel == DB_LEVEL0)
	return;

    db_artificial_function = SY_FLAGS(sid) & SY_ARTIFICIAL;

    /* remember name to put out label */
    db_funcname = cg_extname(sid);

    /* Emit the file indx and line number for this function. */
    if (!db_artificial_function)
	db_conv_seq_to_file_line(db_curline);
    SY_FLAGS(sid) |= SY_DBOUT;		/* mark debug information generated */

    /* set up stack for tracking inlines */
    db_in_inline = 0;
    db_create_entry = 0;
    curr_function = sid;
    f_info.type = db_il_function;
    f_info.extra.func.symbol = sid;
    f_info.child = db_copy_updates(region_updates[SY_DEBUG_ID(sid)]->updates);
    DB_CURSCOPE = &f_info;
    DB_HEAD = DB_TAIL = 0;
}  /* db_begf */


void
db_s_fcode()
/* Output debug information after function prologue, before real
** function code if no debug information has been issued for this 
** line yet.
*/
{
#ifdef DBLINE
    db_func_start = 1;
#endif
    if (db_symlevel == DB_LEVEL2
	&& db_curline != db_lastlineno
	&& ! db_artificial_function) {
	/* Convert the sequence number contained in db_curline to the file
	   index number and the line number within the file. */
	db_conv_seq_to_file_line(db_curline);

	dwarf_out("St");		/* put line number labels in .text */
	if (IS_DWARF_1()) {
	    /* Dwarf 1 - Output:
	    ** <LAB_FUNCNO><line>:
	    **	.section .line
	    **	.uaword <line> 
	    **	.uahalf 0xffff
	    **	.uaword <label>-..text.begin
	    **
	    ** where label is the function name.
	    */
	    dwarf_out(".f");
	    dwarf_out("Sl\tW\td; H x; W s-LB\n", db_curr_lineno, 0xffff, db_funcname);
	    dwarf_out("St");			/* force to .text */
	} else {
	    /* Dwarf 2 */
	    /* Dwarf 2 */
	    /* For Dwarf 2, advances in the PC value is made as a delta from
	    ** the last statement point.  This particular statement point
	    ** involves <func_name>-..LN<old> and the next statement point
	    ** would be ..LN<new> - <func_name>.  To simplify this, a new
	    ** line label will be assigned and equated to the function label.
	    **
	    ** Output:
	    **
	    **  .set .L<new>,<func_name>
	    **
	    ** followed by the line program statements necessary to bring
	    ** the "machine" up to date.
	    */
	    /* Get a new line label number assigned, but not defined.
	       Equate the label with the function name. */
	    dwarf_out(".N\ts\tLn,sC", DB_DOTSET, db_funcname,
		   "equate line label with function");
	    db_dw2_upd_statement_prog();
	} /* if */
	db_lastlineno = db_curline;
    }  /* if */
    return;
}  /* db_s_fcode */


void
db_e_fcode()
/* Generate debug output at end of function, before function epilogue. */
{
    db_lineno();			/* put out line number for epilogue */
}  /* db_e_fcode */


void
db_endf()
/* Generate debug output at end of entire function definition. */
{
  switch (db_symlevel){
    case DB_LEVEL2:
    case DB_LEVEL1:
	dwarf_out("St");
	dwarf_out("LH:\n", (int)cg_getcurfunc());	/* Generate high pc label in text */
	db_apply_updates(curr_function, DB_CURSCOPE->child, DB_HEAD);
	break;
    case DB_LEVEL0:
	break;
    }
    
}  /* db_endf */

static void
db_push_update_stack(db_info *ptr)
/* push an entry for a new scope - either a block or an inline function */
{
	++TD_USED(td_update_stack);		/* want to use another element */
	TD_NEED1(td_update_stack);
	TD_CHKMAX(td_update_stack);
	DB_CURSCOPE = ptr;
	DB_HEAD = DB_TAIL = 0;
} /* db_push_update_stack */

static void
db_pop_update_stack(void)
{
	/* Link inline entries onto end of child list for the current scope */
	if (DB_HEAD) {
		if (DB_CURSCOPE->child) {
			db_info	*list = DB_CURSCOPE->child;
			while (list->next)
				list = list->next;
			list->next = DB_HEAD;
		} else {
			DB_CURSCOPE->child = DB_HEAD;
		} /* if */
	}
	if (--TD_USED(td_update_stack) < 0)
		cerror("update stack underflow");
} /* db_pop_update_stack */

void
db_s_block(int snum)
/* Starting a new block. */
{
    if (db_symlevel == DB_LEVEL2) {
#ifdef DBLINE
	if (db_func_start) {
	    db_func_start = 0;
	    cgsync();
	    db_state = DB_INIT;
	}
	else
	    db_state = DB_START;
#endif
	if (snum) {
		/* Generate label marking the beginning of a block */
		db_info	*ptr;

		for (ptr = DB_CURSCOPE->child; ptr; ptr = ptr->next) {
			if (IS_BLOCK(ptr->type) && ptr->extra.block.scope == snum) {
				db_push_update_stack(ptr);
				break;
			} /* if */
		} /* for */
		if (!ptr)
			cerror("db_s_block: scope not found");
		dwarf_out("St");		/* force a label in .text */
		if (db_in_inline) {
			ptr->extra.block.low_pc = getlab();
			dwarf_out("LL:\n", ptr->extra.block.low_pc);
		} else {
			dwarf_out("Ll:\n", snum);		/* low pc */
		} /* if */
	} else if (db_in_inline && db_inline_needs_label) {
		/* generate label marking beginning of scope for inline function */
		cg_setlocctr(PROG);	/* put labels in .text */
		dwarf_out("Li:\n", inline_lab_no);
		db_inline_needs_label = 0;
	} /* if */
    }  /* if */
}  /* db_s_block */

void
db_e_block(int snum)
/* Exiting a block.  Output high pc label if we've done a lexical
** block entry for this block.  Drop the current block level.
*/
{
#ifdef DBLINE
	db_state = DB_INIT;
#endif

	if (db_symlevel == DB_LEVEL2 && snum) {
		dwarf_out("St");		/* force label in text */
		if (db_in_inline) {
			DB_CURSCOPE->extra.block.high_pc = getlab();
			dwarf_out("LL:\n", DB_CURSCOPE->extra.block.high_pc);
		} else {
			dwarf_out("Lh:\n", snum);		/* high pc */
		} /* if */
		db_pop_update_stack();
	}  /* if */
}  /* db_e_block */

void
db_symbol(sid)
SX sid;
/* Produce debug information for sid, conditional on global flag. */
{
#ifdef DBLINE
	SY_CLASS_t class = SY_CLASS(sid);
	if (db_state == DB_START) {
		/* don't sync for label defs and externs */
		if (!(SY_FLAGS(sid) & SY_LABEL) && class != SC_EXTERN) {
			db_state = DB_INIT;
			cgsync();
		}
	}
#endif
	if (db_in_inline && SY_CLASS(sid) != SC_LABEL) {
		/* Match the new, concrete symbol with the abstract one */
		db_info	*ptr = DB_CURSCOPE->child;
		for (; ptr; ptr = ptr->next) {
			if ((ptr->type == db_il_symbol)
				&& ptr->extra.sym.symbol == SY_ORIG_SYM(sid)) {
				ptr->extra.sym.new_symbol = sid;
				break;
			} /* if */
		} /* for */
	} /* if */
}  /* db_symbol */

void
db_lineno()
/* Output the current line, relative to the beginning of the
** current function.
*/
{
    if (db_symlevel == DB_LEVEL2
	&& db_curline != db_lastlineno
	&& ! db_artificial_function
	&& db_curline != 0     /* Some C++ IL-lowered code introduced
				  without a sequence number - NOT
				  a true line number change. */ 
				) {

	db_uclineno(db_curline);
	db_lastlineno = db_curline;
    }
    return;
}  /* db_lineno */


static void
db_dw2_make_special_opcode(int line_delta, int addr_incr)
/*
** Either generate a special opcode to adjust the line number register
** and append a row of register value to the statement matrix, or generate
** separate instructions to do that.
*/
{
    char comment[128];

    dw2_line_number += line_delta;
    sprintf(comment, "special_opcode(%d, %d): line # %d", line_delta,
	    addr_incr, dw2_line_number);
    if (   (line_delta >= DB_DW2_LINE_BASE)
	&& (line_delta < (DB_DW2_LINE_BASE + DB_DW2_LINE_RANGE))) {
	/* Construct a special opcode based on the formula:
	**
	** opcode = (line_delta - line_base) +
	**	    (line_range * addr_incr) + opcode_base
	*/
	int opcode = (line_delta - DB_DW2_LINE_BASE) +
			(DB_DW2_LINE_RANGE * addr_incr) + DB_DW2_OPCODE_BASE;
	dwarf_out("\tB\txC", opcode, comment);
    } else {
	/* Need to generate separate instructions
	**
	** Output:
	**    DW_LNS_advance_line LEB128<line_delta>
	**    DW_LNS_copy
	*/
	dwarf_out("\tB\tx;\tlsC\tB\txC", DW_LNS_advance_line, line_delta, comment,
	       DW_LNS_copy, "DW_LNS_copy");
    }  /* if */
}  /* db_dw2_make_special_opcode */


static void
db_conv_seq_to_file_line(seq_no)
int seq_no;
/*
** Convert the sequence number to a file index and line number within
** that file.  The results are stored in the static variables 
** "db_curr_file_index" and "db_curr_line", respectively. 
*/
{
    conv_seq_to_line_and_file_index(seq_no, &db_curr_lineno,
				    &db_curr_file_index);
}  /* db_conv_seq_to_file_line */


static void
db_dw2_upd_statement_prog(void)
/*
** Dwarf 2 - Generate the line statement program instructions to bring
**           the state machine up to date.
*/
{
    char prev_label[32];
    int line_delta;

    line_delta = db_curr_lineno - dw2_line_number;

    dwarf_out("Sl");
    /* Check for a change in file name and update if necessary. */
    if (dw2_file_index != db_curr_file_index) {
	/* Have hit a source file change. */
	dw2_file_index = db_curr_file_index;
	dwarf_out("\tB\tx;\tluC", DW_LNS_set_file, db_curr_file_index,
	       "DW_LNS_Set_file");
    }  /* if */

    /* Since the actual value of the address increment is not really known,
       use a "DW_LNS_fixed_advance_pc" instruction to advance the PC. */
    sprintf(prev_label, LAB_LINENO, dw2_prev_line_label);
    dwarf_out("\tB\tx;\tH\tLn-sC", DW_LNS_fixed_advance_pc, prev_label,
	   "DW_LNS_fixed_advance_pc");
    /* Now update the line number with a remaining addr increment of zero. */
    db_dw2_make_special_opcode(line_delta, 0 /* address increment */ );
    dwarf_out("Sp");
}  /* db_dw2_upd_statement_prog */


static void
db_uclineno(ln)
int ln;
/* Unconditional output line number ln. */
{
    /* Convert the sequence number contained in "ln" to the file
       index number and the line number within the file. */
    db_conv_seq_to_file_line(ln);

    cg_setlocctr(PROG);			/* put line number labels in .text */
    dwarf_out(".n");
    if (IS_DWARF_2()) {
	/* Dwarf 2 - Output */
	db_dw2_upd_statement_prog();
    }  else {
	/* Dwarf 1 - Output:
	**	label
	**	.section .line
	**	.uaword <line number>
	**	.uahalf 0xffff
	**	.uaword <label>-..text.begin
	*/
	dwarf_out("Sl\tW\td; H x; W Ln-LB\nSp", db_curr_lineno, 0xffff);
    }  /* if */
    return;
}  /* db_uclineno */

/* Address referenced in cgstuff - never called for cplusbe */
void
db_sue(t)
T1WORD t;
{
	cerror("in db_sue");
}  /* db_sue */

void
db_sy_clear(sid)
SX sid;
/* Output debug information for symbol table entries that are being
** flushed.  This is the way we pick up s/u/e tags for which no
** information has been generated.
*/
{
#ifdef DBLINE
    if (db_state != DB_CLEAR)

	/* don't want to sync if only clears in block are for function defs,
	   or extern defs.
	*/
	if (!TY_ISFTN(SY_TYPE(sid)) && SY_CLASS(sid) != SC_EXTERN) {
		cgsync();
		db_state = DB_CLEAR;
	}
#endif

    return;
}  /* db_sy_clear */

void
db_s_inline(SX sid)
/* Push an entry for an inline function onto the update stack */
{
	int		region = SY_DEBUG_ID(sid);
	debug_updates	*header;
	db_info		*info;

	if (s1debug)
		fprintf(dbout, "/ in db_s_inline\n");
	++db_in_inline;
	header = region_updates[region];
	if (!header)
		cerror("db_s_inline: corrupt region update table");

	header->has_been_inlined = 1;
	if ((info = (db_info *)malloc(sizeof(db_info))) == 0)
		cerror("db_s_inline: cannot malloc");
	/* save label number, but don't actually generate label here - assignments
	   to parameters may be generated, and those should appear in the outer scope. */
	db_inline_needs_label = 1;
	info->extra.func.low_pc = ++inline_lab_no;
	info->type = db_il_function;
	info->next = 0;
	info->offset = 0;
	info->extra.func.symbol = sid;
	if (DB_HEAD)
		DB_TAIL->next = info;
	else
		DB_HEAD = info;
	DB_TAIL = info;
	info->child = db_copy_updates(header->updates);
	db_push_update_stack(info);
} /* db_s_inline */

void
db_s_inline_expr(SX sid)
{
	db_s_inline(sid);
	/* go ahead and generate label marking beginning of scope, won't get db_s_block */
	cg_setlocctr(PROG);	/* put labels in .text */
	dwarf_out("Li:\n", inline_lab_no);
	db_inline_needs_label = 0;
}

void
db_e_inline()
{
	if (s1debug)
		fprintf(dbout, "/ in db_e_inline\n");
	cg_setlocctr(PROG);	/* put labels in .text */
	dwarf_out("Li:\n", ++inline_lab_no);
	DB_CURSCOPE->extra.func.high_pc = inline_lab_no;
	db_pop_update_stack();
	--db_in_inline;
} /* db_e_inline */

#endif /* ndef LINT */

