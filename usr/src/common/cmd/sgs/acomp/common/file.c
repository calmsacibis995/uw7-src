#ident	"@(#)acomp:common/file.c	1.6"
/* file.c */

#include <stdlib.h>
#include <limits.h>
#include <unistd.h>
#include "p1.h"


/* Routines to provide a map from a line sequence number to the
** corresponding (debugging) file index and line number of that file.
*/

#define MAX_SEQ_NUMBER INT_MAX

typedef struct a_src_file *a_src_file_ptr;

typedef struct a_src_file {
  char    *file_name;	/* File name of the current file - as used in the 
			   file open call or as appears on the #line
			   directive. */
    int    first_seq_number,
	   last_seq_number;
			/* The range of sequence numbers included in this
			   file and include files within it.  The first 
			   is larger than the last if the file has zero lines.
			   A value of MAX_SEQ_NUMBER for the last indicates
			   that the final number is not yet known. */
    int    first_line_number;
			/* The line number (in this file) associated with
			   first_seq_number.  Has the value 1 for entries
			   not generated by #line directives. */
    a_src_file_ptr
	   parent;	/* The file that implicitly or explicitly included
			   this file. */
    a_src_file_ptr
	   first_child,
	   last_child;	/* The list of include files referenced from this
			   source file, in order.  Both pointers are NULL
			   if the present file references no include files.
			   The list is linked on the "next" link. */
    a_src_file_ptr
	   next;	/* The next include file referenced by the parent of
			   this file, or NULL if there is no next file. */
    short  db_file_index;
			/* File number assigned by the debugging information
			   generation routines for this file.  In Dwarf 2,
			   this number will correspond to the index of the
			   source file in the line statement prologue. */
    short  is_include_file;
 			/* True (non-zero) if this file is input as the
			   result of a #include directive. */
} a_src_file;

#ifndef LINT

/* Data structure used to save information about the last source
** sequence number to file/line number conversion that was done.
** Often this may be a more optimum point to start the lookup of the
** next sequence number.
*/
typedef struct a_src_seq_cache_entry {
    int    first_seq_number;
			/* First sequence number for which this cached
			   information is valid. */
    int    last_seq_number;
			/* Last sequence number for which this cache
			   information is valid. */
    int    line_offset;
			/* Value to be subtracted from a sequence number
			   to convert it to a line number of the source
			   file associated with this cached information. */
    a_src_file_ptr
	   src_file;	/* Pointer to the source file associated with this
			   cached information. */
} a_src_seq_cache_entry;

static a_src_seq_cache_entry seq_cache;

#endif  /* ifndef LINT */

static a_src_file_ptr primary_src_file = NULL;
static a_src_file_ptr current_src_file = NULL;
static char *final_incdir = NULL;
static int final_incdir_len;

#ifndef LINT

static void
reset_sequence_cache()
/* Reset the cached sequence number lookup information. */
{
    seq_cache.first_seq_number = 0;
    seq_cache.last_seq_number  = 0;
    seq_cache.line_offset      = 0;
    seq_cache.src_file = NULL;
}  /* reset_sequence_cache */

#endif  /* ifndef LINT */

void
record_incdir(char *path, int len)
{
	final_incdir = st_nlookup(path, len);
	final_incdir_len = len;
}


int
in_system_header(void)
{
	return current_src_file->file_name != NULL
		&& strncmp(current_src_file->file_name,
			final_incdir, final_incdir_len) == 0
		&& current_src_file->file_name[final_incdir_len] == '/';
}


int
record_start_of_src_file (int  seq_number,
			  int  line_number,
			  char *file_name,
			  int  is_include_file)
{
    a_src_file_ptr new_file;

    new_file = malloc(sizeof(a_src_file));
    if (file_name != NULL) {
	new_file->file_name = st_lookup(file_name);
    } else {
	/* A missing file name would only occur for a "# nnn" in a source
	   file, which means a change in line number within the current
	   file.  Pick up the current file name. */
	new_file->file_name = current_src_file->file_name;
    }  /* if */
    new_file->first_seq_number = seq_number;
    new_file->first_line_number = line_number;
    new_file->last_seq_number = MAX_SEQ_NUMBER;	/* not yet entered */
    new_file->parent = NULL;
    new_file->first_child = NULL;
    new_file->last_child = NULL;
    new_file->next = NULL;
#ifndef LINT
    new_file->db_file_index = DB_REG_FILE(new_file->file_name);
#else
    new_file->db_file_index = 0;
#endif  /* ifdef LINT */
    new_file->is_include_file = is_include_file;

    if (is_include_file) {
	/* This is a file included by the current source file. */
	new_file->parent = current_src_file;
	if (current_src_file->last_child) {
	    /* Add this file to the end of the current include file list. */
	    current_src_file->last_child->next = new_file;
	    current_src_file->last_child = new_file;
	}  else {
	    /* This include file is the first file included by the current
	       source file. */
	    current_src_file->first_child = new_file;
	    current_src_file->last_child = new_file;
	    /* At least 1 line has been encountered in the current source
	       file. */
	    current_src_file->last_seq_number = MAX_SEQ_NUMBER;
	}  /* if */
    }  else if (! primary_src_file) {
	/* This is the primary source file. */
	primary_src_file = new_file;
    }  else {
	/* This a #line directive encountered in the current file.
	   If the current source file is the primary source file
	   or an include file (actual file), treat the new source file
	   as a child of the current source file; otherwise, terminate
	   the current src_file/sequence record and chain the new
	   information as the "next" file. */
	if (   (primary_src_file == current_src_file)
	    || (current_src_file->is_include_file != 0)) {
	    if (current_src_file->last_child) {
		current_src_file->last_child->next = new_file;
		current_src_file->last_child = new_file;
	    } else {
		current_src_file->first_child = new_file;
		current_src_file->last_child = new_file;
	    }  /* if */
	    new_file->parent = current_src_file;
	}  else {
	    /* Terminate the current source file and chain the new entry
	       as the next file. */
	    current_src_file->last_seq_number = seq_number;
				/* The sequence number of the #line. */
	    current_src_file->next = new_file;
	    new_file->parent = current_src_file->parent;
	}  /* if */
	/* The new line number takes effect on the following source line;
	   the next sequence number. */
	new_file->first_seq_number = seq_number + 1;
    }  /* if */

    current_src_file = new_file;

#ifndef LINT
    /* Clear the cached source sequence number conversion information. */
    reset_sequence_cache();
#endif  /* ifndef LINT */
    return new_file->db_file_index;
}  /* record_start_of_src_file */


void
record_end_of_src_file(int  seq_number)
{
    current_src_file->last_seq_number = seq_number - 1;
    while (   (! current_src_file->is_include_file)
	   && (current_src_file != primary_src_file)) {
	/* The current source file was the result of a #line directive
	   in the parent file.  The end-of-file also signifies the
	   end of the parent file as well.  */
	current_src_file = current_src_file->parent;
        current_src_file->last_seq_number = seq_number - 1;
    }  /* while */
    current_src_file = current_src_file->parent;

#ifndef LINT
    /* Clear the cached source sequence number conversion information. */
    reset_sequence_cache();
#endif  /* ifndef LINT */
}  /* record_end_of_src_file */

#ifndef LINT

void
conv_seq_to_line_and_file_index(int    sequence_number,
				int   *line_number,
				int   *file_index)
{
    a_src_file_ptr curr_file, child_file, grandchild_file;
    int		   lines_in_children;
    int		   first_seq_for_cache;
    int		   line_offset;
 
    *line_number = 0;
    *file_index  = 0;
    curr_file = primary_src_file;
    if (   (curr_file == NULL)
	|| (sequence_number <= 0 )
	|| (sequence_number < curr_file->first_seq_number)
	|| (sequence_number > curr_file->last_seq_number)) {
        /* This is an "internal" compiler error. */
	cerror(gettxt(":0",
		      "conv_seq_to_line_and_file_index: bad sequence number"));
    }  /* if */
    if (   sequence_number >= seq_cache.first_seq_number
	&& sequence_number <= seq_cache.last_seq_number) {
	/* The information from the last sequence number conversion is
	   valid for this sequence number; use it. */
	*line_number = sequence_number + seq_cache.line_offset;
	*file_index = seq_cache.src_file->db_file_index;
    }  else {
	/* Starting with the primary source file, locate the file which
	   contains the sequence numnber. */
examine_children:
	lines_in_children = 0;
	child_file = curr_file->first_child;
	/* Record the first sequence number of the current file as the
	   first sequence number for which cached information applies.
	   This will be updated below if necessary to reflect child files. */
	first_seq_for_cache = curr_file->first_seq_number;
	/* Now check the sequence number against each child.  The children
	   are in order by sequence number. */
	while (child_file != NULL) {
	    if (sequence_number < child_file->first_seq_number) {
		/* The sequence number falls before the start of this
		   child and, therefore, must be in the current file. */
		break;
	    } else if (sequence_number <= child_file->last_seq_number) {
		/* The sequence number falls within this child (or one of
		   its children). */
		curr_file = child_file;
		goto examine_children;
	    }  /* if */
	    /* The sequence number falls after this child; keep looking.
	       Keep track of the number of lines in the children.  If
	       the entry we are skipping is for a #line directive, only
	       count the lines in its #include children, not those lines
	       of the current file spanned by the #line directive. */
	    if (child_file->is_include_file) {
		/* Real file */
		lines_in_children += child_file->last_seq_number -
					child_file->first_seq_number + 1;
	    } else {
		/* #line directive entry.  Note that typically when 
		   #line directives appear, there are no #includes, so
		   the loop here does nothing. */
		for (grandchild_file = child_file->first_child;
		     grandchild_file != NULL;
		     grandchild_file = grandchild_file->next) {
		    lines_in_children += grandchild_file->last_seq_number -
					 grandchild_file->first_seq_number + 1;
		}  /* for */
	    }  /* if */
	    /* Record the sequence number following this child as the first
	       sequence number for which the cached information applies. */
	    first_seq_for_cache = child_file->last_seq_number + 1;
	    child_file = child_file->next;
	}  /* while */
	/* Save the information about the file in which this sequence
	   number was located so that subsequent lines may be found more
	   quickly. */
	line_offset = - (curr_file->first_seq_number) +
	  		curr_file->first_line_number - lines_in_children;
	seq_cache.first_seq_number = first_seq_for_cache;
	if (child_file != NULL) {
	    /* This cache entry is valid up to the first line of the
	       next child_file. */
	    seq_cache.last_seq_number = child_file->first_seq_number - 1;
	}  else {
	    /* This cached entry is valid through the end of the current file. */
	    seq_cache.last_seq_number = curr_file->last_seq_number;
	}  /* if */
	seq_cache.line_offset = line_offset;
	seq_cache.src_file = curr_file;

	/* Complete the line number and file index to be returned to the
	   caller. */
	*line_number = sequence_number + line_offset;
	*file_index = curr_file->db_file_index;
    }  /* if */
}  /* conv_seq_to_line_and_file_index */

#ifdef DEBUG

static int indent_cnt = 0;

static void indent()
{
    register int i;

    for (i = 0; i < indent_cnt; i++) {
	fprintf(stderr, "    ");
    }  /* for */
}  /* indent */


static void dmp_file_info(register a_src_file_ptr file)
/* Dump the individual file information for "file", indented by indent_cnt
   spacing and recursively dump and children.
*/
{
    register a_src_file_ptr child;

    indent();
    fprintf(stderr, "%s\n", file->file_name);
    indent();
    fprintf(stderr, "  seq: %d - %d; line: %d; file index: %d; - %s\n",
	    file->first_seq_number, file->last_seq_number,
	    file->first_line_number, file->db_file_index,
	    (file->is_include_file ? "INCLUDE FILE" : ""));
    child = file->first_child;
    indent_cnt++;
    while  (child) {
	if (child->parent != file) {
	    indent();
	    fprintf(stderr, "  ****** PARENT NOT CORRECTLY LINKED ******\n");
	}  /* if */
	dmp_file_info(child);
	child = child->next;
    }  /* while */
    indent_cnt--;
}  /* dmp_file_info */

void dmp_all_file_info()
/* Dump the file information - file name, sequence number range, and line 
    number for the source files involved in the compilation. 
*/
{
    dmp_file_info(primary_src_file); 
}  /* dmp_file_info */
#endif  /* DEBUG */

#endif  /* idndef LINT */
