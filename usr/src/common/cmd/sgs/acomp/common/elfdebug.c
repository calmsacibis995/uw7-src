#ident	"@(#)acomp:common/elfdebug.c	55.6.6.12"
/* elfdebug.c */

#include "sgs.h"			/* For PACKAGE string. */
#include <sys/utsname.h>
#include <string.h>

/* Define db_curline whether or not LINT is defined since it is used
 * in lex.c and aclex.l.
 */

int db_curline = 0;		/* start line of current statement */

#ifndef LINT

/* Code to support standard debugging output in ELF format.  The various
** flavors of output that are supported are:
**
**	1)  Start and end of function.
**	2)  Start and end of block.
**	3)  Symbol.
**	4)  Line number.
**
*/


#include "p1.h"

#undef FIXED_FRAME     /*   FOR NOW */

#include "err.h"
#include "file.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/param.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include "dwarf.h"
#include "dwarf2.h"
#include "abbrev.h"

/* definitions needed for dwarf_gen.h */

#define COMMENTS_IN_DEBUG	(s1debug)
#define ERROR_FUNCTION		cerror
#define ADDR_SIZE		(SZPOINT/SZCHAR)
#define DBOUT			dbout

/* These data support a stack of entries that holds the label numbers
** for the current information entry and its sibling pointer at each level.
*/
#ifndef INI_DBSTACK
#define INI_DBSTACK 20		/* initial maximum depth of stack */
#endif

typedef struct {
    int db_infolab;		/* label of current info entry */
    int db_sibling;		/* sibling of current entry */
    T1WORD db_low_type;		/* lowest type id to be generated at this
				   "debugging scope/level" */
} db_stack;
TABLE(Static, td_dbstack, static, db_stack_init,
		db_stack, INI_DBSTACK, 0, "debug sibling stack");
#define DB_CURINFOLAB \
	(TD_ELEM(td_dbstack,db_stack,TD_USED(td_dbstack)).db_infolab)
#define DB_CURSIBLING \
	(TD_ELEM(td_dbstack,db_stack,TD_USED(td_dbstack)).db_sibling)
#define DB_LOW_TYPE(scope) \
	(TD_ELEM(td_dbstack,db_stack,(scope)).db_low_type)

static FILE * dbout = stdout;
static char * db_dbg_sec_name;
static char * db_line_sec_name;
static int db_begfile_seen;

/* Dwarf 2 - Line number state machine variables */
static int dw2_generate_line_prologue = 1;
static int dw2_prev_line_label = 0;	/* label number of the previous .LN */
static int dw2_curr_line_label = 0;	/* label number of the current .LN */
static int dw2_file_index = 1;		/* index into the file name sequence. */
static int dw2_line_number = 1;		/* current line number. */
static int dw2_column = 0;		/* column number - not used yet */

static int dw2_line_base;
static int dw2_line_range;
static int dw2_opcode_base;

#include <dwarf_gen.h>

/* These macros are for symbolic prefixes to offsets to the
** frame or stack pointers. 
*/
#ifndef STACKSYM
#define STACKSYM	""
#endif
#ifndef ARGSYM
#define ARGSYM		""
#endif

int db_linelevel = DB_LEVEL2;	/* line number debugger info level */
int db_symlevel = DB_LEVEL2;	/* symbol debugger info level */
int db_abbreviations = 0;	/* Dwarf 2 - generate abbreviation table */
static char * db_filename = "";	/* name of file for debug info */
static char * db_funcname = "";	/* name of function to generate label */
static int db_lastlineno;	/* line number at last line number output */
static int db_labno = 0;	/* current debug label number */
static int db_file_scope;	/* debug scope of the compilation unit. */
static int db_force_incomplete_type = 0;
				/* set to 1 to force an incomplete type
				   to be emitted. */

static int db_language = LANG_C89;	/* default for acomp */

int db_format = DB_DWARF_2;	/* default debugging format */

int db_name_lookup = 0;		/* Dwarf 2 - name lookup section generation
					   - off by default (for now) */

int db_addr_ranges = 0;		/* Dwarf 2 - address range section generation
					   - off by default (for now) */

static int code_gen_in_diff_wd = 0;
				/* True (non-zero) if the code generation
				   is being done in a different working
				   directory than the preprocessing.
				   (i.e. the preprocessed file was moved or
				   using a relative path to get to the .i
				   file.) */

/* Used by the static function db_conv_seq_to_file_line() to store
   the results of converting a sequence number to a file and line number.
   Available for both Dwarf 1 and Dwarf 2 as needed. */
static int  db_curr_file_index;	/* the file index return for a specific
				   line sequence number. */
static int  db_curr_lineno;	/* the actual line number with in a file for 
				   a specific line sequence number. */


#ifdef DBLINE
/* The i860 CG saves up trees in a basic block and then produces code for the
   block. acomp calls cgsync at the beginning and end of lexical blocks that
   declare local variables, to force the CG to generate the code for the
   lexical block between the markers for the block generated by db_s_block
   and db_e_block.

   We implement the policy described above by a finite state machine which
   keeps track of the lexical block markers and whether variables have
   been declared in the lexical block in db_state.  The values for db_state 
   are listed below.
*/

#define DB_INIT 0	
#define DB_START 1	
#define DB_CLEAR 2
static int db_state = DB_INIT;
static int db_func_start;

/* transitions for the finite statement machine are:
*,  	  db_s_block-> DB_START 
	  db_s_block && db_func_start == 1 -> DB_INIT (call cgsync)
DB_INIT,  db_sy_clear->DB_CLEAR   (call cgsync)
DB_START, db_symbol->  DB_INIT    (call cgsync)
*, 	  db_e_block-> DB_INIT
*/
#endif

#define DB_GENLAB() (++db_labno)

/* Dwarf 2
**	Abbreviation Table Macros
*/
#define DW2_START_ABBREV_ENTRY()	\
	(dwarf_out("\tluC", ++dw2_curr_abbrev_index, "start abbrev entry"), dw2_curr_abbrev_index)
#define DW2_ABBREV_TAG_ATTR(tag_attr, form_child)	\
	dwarf_out("\tlu;\tluC", tag_attr, form_child,	\
	       #tag_attr " " #form_child)
#define DW2_END_ABBREV_ENTRY()		\
	dwarf_out("\tlu;\tluC", DB_DW2_END, DB_DW2_END, "end entry")
#define DW2_BASE_TYPE(type_id, name, base_type_encoding, byte_size )	\
	db_s_entry(dw2_base_type);	\
	db_at_name(name);		\
	dwarf_out("\tB\txC", base_type_encoding, "DW_AT_encoding");\
	dwarf_out("\tluC", byte_size, "DW_AT_byte_size");	\
	dwarf_out("=", (unsigned int)TY_MAPID(type_id));	\
	DB_TY_SETOUT(type_id);		\
	db_e_entry();


/* Dwarf 2
**	Abbreviation Table Indexes
*/
static short dw2_curr_abbrev_index = 0;
static short dw2_compile_unit;
static short dw2_compile_no_line_info;
static short dw2_base_type;
static short dw2_pointer_type;
static short dw2_const_type;
static short dw2_volatile_type;
static short dw2_typedef;
static short dw2_struct;
static short dw2_incomplete_struct;
static short dw2_union;
static short dw2_incomplete_union;
static short dw2_su_member;
static short dw2_bit_field;
static short dw2_enumeration;
static short dw2_incomplete_enumeration;
static short dw2_enumerator;
static short dw2_array;
static short dw2_subrange;
static short dw2_non_void_subr_type;
static short dw2_void_subr_type;
static short dw2_formal_param_type;
static short dw2_unspecified_params;
static short dw2_variable;
static short dw2_variable_no_decl;
static short dw2_formal_param;
static short dw2_label;
static short dw2_non_void_subr;
static short dw2_void_subr;
static short dw2_lexical_block;

#define DB_DW2_END	0
#define DB_DW2_VERSION	2
#define DB_DW2_MIN_INSTR_SIZE	1		/* for x86 */
#define DB_DW2_LINE_BASE	-100
#define DB_DW2_LINE_RANGE	220
#define DB_DW2_OPCODE_BASE	(DW_LNS_fixed_advance_pc + 1)




static void db_begfile();
static void db_ucsymbol();
static void db_uclineno();
static void dwarf_outmember();
static void dwarf_outarray();
static void dwarf_outfunction();
static void db_uctype();
static void db_conv_seq_to_file_line();
static void db_dw2_init_line_section();
static void db_dw2_upd_statement_prog();
static void db_add_src_file_to_table(char *, int);

extern int db_curline;		/* current statement line */

/* This structure keeps track of whether a given type ID has had
** a user-defined type generated for it.  It's simply a bitmap,
** one bit per type number.
*/
#ifndef INI_DBTYPES
#define INI_DBTYPES 100		/* number of bytes to represent type IDs */
#endif

/* Maximum type number represented, +1. */
static TY_TYPEID db_maxtype = INI_DBTYPES*8;
/* Highest type number that needs to be produced eventually. */
static TY_TYPEID db_maxneedtype = 0;

static unsigned char db_tymask[8] = {
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80
};
typedef unsigned char db_typebits[2];
#define DB_OUTBIT 0		/* 0-th element is for types already output */
#define DB_NEEDBIT 1		/* 1-st element is for types that are needed */
TABLE(Static, td_dbtypes, static, dbtypes_init,
		db_typebits, INI_DBTYPES, TD_ZERO, "type ID flags");

#define DB_TY_CHKOUT(t) db_ty_chkout(t)
#define DB_TY_SETOUT(t) db_ty_setout(t)
#define DB_TY_CHKNEED(t) db_ty_chkneed(t)
#define DB_TY_SETNEED(t, scope) db_ty_setneed(t, scope)



#ifndef	INI_BBFLAGS
#define	INI_BBFLAGS 10
#endif

/* This structure (array) holds flags that say whether a debug
** entry has been generated for a particular block level.
*/
TABLE(Static, td_bbflags, static, bbflags_init,
		char, INI_BBFLAGS, 0, "block flags");
#define bblevel (TD_USED(td_bbflags))
#define BBFLAG (TD_ELEM(td_bbflags,char,bblevel))


/* Table of include directories used in this compilation. */
#ifndef INI_DBINCDIR
#define INI_DBINCDIR 4
#endif  /* INI_DBINCDIR */

typedef struct {
    char  *dir_name;		/* include directory path name. */
    short  debug_index;		/* index assigned in the debugging line
				   statement prologue. */
    char   referenced;		/* non-zero if directory was actually
				   used. */
} db_incdir;
TABLE(Static, td_dbincdir, static, db_incdir_init,
		db_incdir, INI_DBINCDIR, 0, "debug include directories");
#define DB_INCDIR_NAME(index) \
	(TD_ELEM(td_dbincdir, db_incdir, (index)).dir_name)
#define DB_INCDIR_DBINDEX(index) \
	(TD_ELEM(td_dbincdir, db_incdir, (index)).debug_index)
#define DB_INCDIR_REFD(index) \
	(TD_ELEM(td_dbincdir, db_incdir, (index)).referenced)
#define DB_INCDIR_USED	(TD_USED(td_dbincdir))

/* Table of source files used in this compilation. */
#ifndef INI_DBSRCFILE
#define INI_DBSRCFILE 10
#endif  /* INI_DBSRCFILE */

typedef struct {
    char   *pathname;		/* pathname used to open the file. */
    char   *filename;		/* source file name */
    off_t   byte_size;		/* file size in bytes */
    time_t  last_mod_time;	/* time file last modified. */
    short   dir_index;		/* index of include directory */
    short   debug_index;	/* index assigned in the debugging line
				   statement prologue. */
} db_srcfile;
TABLE(Static, td_dbsrcfile, static, db_srcfile_init,
		db_srcfile, INI_DBSRCFILE,0, "debug source files");
#define DB_SRCFILE_PATH(index) \
	(TD_ELEM(td_dbsrcfile, db_srcfile, (index)).pathname)
#define DB_SRCFILE_DBINDEX(index) \
	(TD_ELEM(td_dbsrcfile, db_srcfile, (index)).debug_index)
#define DB_SRCFILE_USED (TD_USED(td_dbsrcfile))


static int
db_ty_chkout(t)
T1WORD t;
/* Return non-zero if type t has been output as a user-defined type, else 0. */
{
    TY_TYPEID id = TY_MAPID(t);

    if (id >= db_maxtype)
	return( 0 );			/* beyond known range */
    return (TD_ELEM(td_dbtypes,db_typebits,id/8)[DB_OUTBIT] & db_tymask[id%8]);
}

static void
db_ty_setout(t)
T1WORD t;
/* Mark type t as having been output as a user-defined type. */
{
    TY_TYPEID id = TY_MAPID(t);
    int need = id/8 + 1;		/* number of bytes needed:  type 8 is
					** in the 2nd byte
					*/

    TD_USED(td_dbtypes) = need;
    if (need > td_dbtypes.td_allo)
	td_enlarge(&td_dbtypes, need);
    TD_CHKMAX(td_dbtypes);
    db_maxtype = 8 * td_dbtypes.td_allo;

    TD_ELEM(td_dbtypes,db_typebits,id/8)[DB_OUTBIT] |= db_tymask[id%8];
    /* The scope of the type is that of the current debugging scope level. */
    if (t >= TY_NBASE)
	TY_DBSCOPE(t) = (ty_typetab)TD_USED(td_dbstack);
    return;
}


static int
db_ty_chkneed(t)
T1WORD t;
/* Return non-zero if type t needs to be output as a user-defined type,
** else 0.
*/
{
    TY_TYPEID id = TY_MAPID(t);

    if (id > db_maxneedtype)
	return( 0 );			/* beyond known range */
    return (
	TD_ELEM(td_dbtypes,db_typebits,id/8)[DB_NEEDBIT] & db_tymask[id%8]
	);
}

static void
db_ty_setneed(t, scope)
T1WORD t;
ty_typetab scope;
/* Mark type t as needing to be output as a user-defined type. */
{
    TY_TYPEID id = TY_MAPID(t);
    int need = id/8 + 1;		/* number of bytes needed:  type 8 is
					** in the 2nd byte
					*/

    TD_USED(td_dbtypes) = need;
    if (need > td_dbtypes.td_allo)
	td_enlarge(&td_dbtypes, need);
    TD_CHKMAX(td_dbtypes);
    db_maxtype = 8 * td_dbtypes.td_allo;

    TD_ELEM(td_dbtypes,db_typebits,id/8)[DB_NEEDBIT] |= db_tymask[id%8];
    if (id > db_maxneedtype)		/* update maximum needed type */
	db_maxneedtype = id;
    /* Mark the scope at which the debugging information is to be generated. */
    if (t >= TY_NBASE) {
	TY_DBSCOPE(t) = scope;
	if (t < DB_LOW_TYPE(scope)) DB_LOW_TYPE(scope) = t;
    }  /* if */
    return;
}


static void
db_push()
/* Start new level on debug stack.  New sibling label number is 0. */
{
    ++TD_USED(td_dbstack);		/* want to use another element */
    TD_NEED1(td_dbstack);
    TD_CHKMAX(td_dbstack);
    DB_CURSIBLING = 0;			/* no sibling yet */
    DB_LOW_TYPE(TD_USED(td_dbstack)) = INT_MAX;
    return;
}

static void
db_pop()
/* Exit current debug stack level.  Tie off any dangling sibling
** pointer.
*/
{
    /* Run through the types, from the lowest T1WORD needed for this
       "scope", and generate any types that need to be generated at
       this level. */
    T1WORD t = DB_LOW_TYPE(TD_USED(td_dbstack));
    for (; t <= db_maxneedtype; t++) {
        if (   DB_TY_CHKNEED(t)
	    && (! DB_TY_CHKOUT(t))
	    && (TY_DBSCOPE(t) == TD_USED(td_dbstack))) {
            /* Force the type debugging information to be generated now. */
	    db_uctype(t);
        }  /* if */
    }  /* for */
    dwarf_out("Sd");
    if (DB_CURSIBLING)
	dwarf_out(".d", DB_CURSIBLING);

    /* Output a null entry to tie off any non-existent children for
    ** this entry.  The phony entry has no content other than the length.
    */
    if (IS_DWARF_1()) {
	dwarf_out("\tW\td\nSp", 4);
    } else {
	dwarf_out("\tB\txCSp", DB_DW2_END, "end sibling chain");
    }  /* if */
    if (--TD_USED(td_dbstack) < 0)
	cerror("debug stack underflow");
    return;
}


static void
db_s_entry(i)
int i;
/* Start new debug information entry with tag i.  Set up the current
** stack appropriately.  Sets output for debug section.
** For Dwarf 1, "i" specifies the tag; for Dwarf 2, "i" denotes the
** abbreviation table number.
*/
{
    int sibling;
    char *tagname;

    /* BEWARE!!
    ** There's a tricky recursion problem here.  The very first call
    ** to dwarf_out triggers a call to db_begfile(), which, in turn, calls
    ** db_s_entry().  We have to keep the current/sibling information
    ** straight in case of such a call.  Therefore, force a slightly
    ** early call to dwarf_out() just to be sure.
    */
    dwarf_out("Sd");

    if((sibling = DB_CURSIBLING) == 0)
	sibling = DB_GENLAB();
    DB_CURINFOLAB = sibling;
    DB_CURSIBLING = DB_GENLAB();

    dwarf_out(".d", sibling);

    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	if (s1debug) {
	    /* Dwarf 1 */
	    switch(i) {
	    case TAG_array_type:	tagname = "TAG_array_type"; break;
	    case TAG_entry_point:	tagname = "TAG_entry_point"; break;
	    case TAG_enumeration_type:	tagname = "TAG_enumeration_type"; break;
	    case TAG_formal_parameter:	tagname = "TAG_formal_parameter"; break;
	    case TAG_global_subroutine:	tagname = "TAG_global_subroutine"; break;
	    case TAG_global_variable:	tagname = "TAG_global_variable"; break;
	    case TAG_label:		tagname = "TAG_label"; break;
	    case TAG_lexical_block:	tagname = "TAG_lexical_block"; break;
	    case TAG_local_variable:	tagname = "TAG_local_variable"; break;
	    case TAG_member:		tagname = "TAG_member"; break;
	    case TAG_pointer_type:	tagname = "TAG_pointer_type"; break;
	    case TAG_source_file:	tagname = "TAG_source_file"; break;
	    case TAG_structure_type:	tagname = "TAG_structure_type"; break;
	    case TAG_subroutine:	tagname = "TAG_subroutine"; break;
	    case TAG_subroutine_type:	tagname = "TAG_subroutine_type"; break;
	    case TAG_typedef:		tagname = "TAG_typedef"; break;
	    case TAG_union_type:	tagname = "TAG_union_type"; break;
	    case TAG_unspecified_parameters: tagname = "TAG_unspecified_parameters"; break;
	    default:
		tagname = "---unknown tag type ---"; break;
	    }
	}
	else
	    tagname = "";

	dwarf_out("\tW\tLC-Lc\n");
	dwarf_out("\tH\txC", i, tagname);
	/* Output sibling attribute. */
	dwarf_out("\tH\tx; W\tLdC", AT_sibling, DB_CURSIBLING, "AT_sibling");
    } else if (db_abbreviations) {
	/* Dwarf 2 */
	dwarf_out("\tluC", i, "abbrev table index");
	if (i == dw2_struct || i == dw2_union || i == dw2_enumeration
	    || i == dw2_array || i == dw2_non_void_subr_type
	    || i == dw2_void_subr_type || i == dw2_non_void_subr
	    || i == dw2_void_subr || i == dw2_lexical_block
	    || i == dw2_compile_unit || i == dw2_compile_no_line_info)
		dwarf_out("\tW\tLd-sC", DB_CURSIBLING, LAB_INFOBEGIN,
				"DW_AT_sibling");
    } else {
	/* Dwarf 2 */
	dwarf_out("\tluC", i, "abbrev table index");
	switch (i) {
	    case DW2_compile_unit:
	    case DW2_compile_no_line_info:
	    case DW2_struct:
	    case DW2_union:
	    case DW2_enumeration:
	    case DW2_array:
	    case DW2_non_void_subr_type:
	    case DW2_void_subr_type:
	    case DW2_non_void_subr:
	    case DW2_void_subr:
	    case DW2_lexical_block:
		dwarf_out("\tW\tLd-sC", DB_CURSIBLING, LAB_INFOBEGIN,
				"DW_AT_sibling");
		break;
	    default:
		break;
	} /* switch */
    }  /* if */
    return;
}


static void
db_e_entry()
/* End debug information entry.  Generate end label (for Dwarf 1),
** reset section.
*/
{
    if (IS_DWARF_1()) dwarf_out(".C");
    dwarf_out("Sp");
    return;
}


static void
db_at_name(s)
char * s;
/* Output name attribute.  It may be null for certain error cases where
** a s/u/e is declared in a function prototype:  the tag and members go
** out of scope, but the type that refers to them lingers on.
*/
{
    if (s == 0)
	s = "";
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	dwarf_out("\tH\txC", AT_name, "AT_name");
	dwarf_out("b\n", s);			/* does length, bytes */
    } else {
	/* Dwarf 2 */
	dwarf_out("bC", s, "DW_AT_name");
    }  /* if */
    return;
}

static void
db_at_byte_size(size)
BITOFF size;
/* Output the size attribute for an object whose size is
** "size" bits.
*/
{
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	dwarf_out("\tH\tx; W\tdC", AT_byte_size, size/SZCHAR, "AT_byte_size");
    } else {
	/* Dwarf 2 */
	dwarf_out("\tluC", size/SZCHAR, "DW_AT_byte_size");
    }  /* if */
    return;
}


static void
db_at_element_list(t)
T1WORD t;
/* Generate attribute for names and values of enumerators. */
{
    unsigned int mbrno;
    SX mbr;
    int lab = DB_GENLAB();

    /* Generate attribute, length, label for stuff. */
    dwarf_out("\tH\txC\tW\tLD-Ld\n.d", AT_element_list, "AT_element_list",
	lab, lab, lab);
    
    /* Generate value, then string, for each enumerator. */
    for (mbrno = 0; (mbr = TY_G_MBR(t, mbrno)) != SY_NOSYM; ++mbrno)
	dwarf_out("\tW\td\nb\n", SY_OFFSET(mbr), SY_NAME(mbr));

    /* Generate end label */
    dwarf_out(".D", lab);
    return;
}


static void
db_dw2_outenum(t)
T1WORD t;
/* Dwarf 2 - output the enumerator entries for the enumeration "t".
** The enumeration members have been made in reverse order as 
** required for Dwarf 1.  They must be reversed again for Dwarf 2.
*/
{
    int mbrno;
    SX mbr;

    /* Determine the last member number that is valid. */
    for (mbrno = 0; (mbr = TY_G_MBR(t, mbrno)) != SY_NOSYM; ++mbrno) ;

    /* Now walk the members from the back to the front. */
    for (mbrno = --mbrno; mbrno >= 0; mbrno--) {
	mbr = TY_G_MBR(t, mbrno);
	db_s_entry(dw2_enumerator);
	dwarf_out("\tlsC", SY_OFFSET(mbr), "DW_AT_const_value");
	db_at_name(SY_NAME(mbr));
	db_e_entry();
    }  /* for */
}  /* db_dw2_outenum */


static void
db_at_pc()
/* Generate low and hi pc attributes for a block.  The labels are always
** based on the current information entry.
*/
{
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	dwarf_out("\tH\tx; W LlC\tH\tx; W LhC",
		AT_low_pc, DB_CURINFOLAB, "AT_low_pc",
		AT_high_pc, DB_CURINFOLAB, "AT_high_pc");
    }  else  {
	/* Dwarf 2 */
	dwarf_out("\tW\tLlC\tW\tLhC", DB_CURINFOLAB, "DW_AT_low_pc",
		DB_CURINFOLAB, "DW_AT_high_pc");
    }  /* if */
    return;
}  /* db_at_pc */


static void
db_at_type(t)
T1WORD t;
/* Dwarf 1
** Output type attribute.  By this time all sub-types that
** would result in a new debug info entry being generated
** must already have been flushed.
**
** Dwarf 2
** Simply put out the DW_AT entry, which is a reference to the
** type entry elsewhere in the .debug_info section.  Struct, 
** union, enumeration and C++ classes are typically generated
** when first encountered (from declaration processing), but other
** derived types may not have been generated.  If so, the type
** will have been already marked as needed by an earlier db_walktype()
** call and the type debugging information will be generated on the
** cleanup of the scope containing the derived-from type.
*/
{
    if (IS_DWARF_1()) {
	/* Dwarf 1
	** We have to figure out which case we're dealing with, first:
	** fundamental type/user-defined type, modified or not.
	*/
	int elftype = FT_none;
	int usertype = 0;		/* user-defined type if non-0 */
	int nptrs = 0;			/* number of pointer modifiers */
	int attr;
	char * attrstring;
	char * ts;			/* name of fundamental type */

	/* Stop if we find a type already output.  Pointer to void is
	** special:  a generic pointer.
	*/
	for (;;) {
	    t = TY_UNQUAL(t);	/* strip qualifiers, which the
				** debugger information does not
				** represent
					*/
	    if (DB_TY_CHKOUT(t)) {
		usertype = 1;		/* is user-defined type */
		break;
	    }
	    else if (TY_ISPTR(t)) {
		t = TY_DECREF(t);
		if (TY_TYPE(t) == TY_VOID) {
		    elftype = FT_pointer;
		    ts = "void *";
		    break;
		}
		++nptrs;
	    }
	    else
		break;
	}  /* for */

	if (!usertype && elftype == FT_none) {
	    switch( TY_TYPE(t) ){
	    case TY_CHAR:
		elftype = FT_char;
		ts = "char";
		break;
	    case TY_UCHAR:
		elftype = FT_unsigned_char;
		ts = "unsigned char";
		break;
	    case TY_SCHAR:
		elftype = FT_signed_char;
		ts = "signed char";
		break;

	    case TY_SHORT:
		elftype = FT_short;
		ts = "short";
		break;
	    case TY_USHORT:
		elftype = FT_unsigned_short;
		ts = "unsigned short";
		break;
	    case TY_SSHORT:
		elftype = FT_signed_short;
		ts = "signed short";
		break;

	    case TY_INT:
		elftype = FT_integer;
		ts = "int";
		break;
	    case TY_UINT:
		elftype = FT_unsigned_integer;
		ts = "unsigned int";
		break;
	    case TY_SINT:
		elftype = FT_signed_integer;
		ts = "signed int";
		break;

	    case TY_LONG:
		elftype = FT_long;
		ts = "long";
		break;
	    case TY_ULONG:
		elftype = FT_unsigned_long;
		ts = "unsigned long";
		break;
	    case TY_SLONG:
		elftype = FT_signed_long;
		ts = "signed long";
		break;

#ifndef FT_long_long
#define FT_long_long		(FT_label+1)
#define FT_signed_long_long	(FT_label+2)
#define FT_unsigned_long_long	(FT_label+3)
#endif
	    case TY_LLONG:
		elftype = FT_long_long;
		ts = "long long";
		break;
	    case TY_ULLONG:
		elftype = FT_unsigned_long_long;
		ts = "unsigned long long";
		break;
	    case TY_SLLONG:
		elftype = FT_signed_long_long;
		ts = "signed long long";
		break;

	    case TY_FLOAT:
		elftype = FT_float;
		ts = "float";
		break;
	    case TY_DOUBLE:
		elftype = FT_dbl_prec_float;
		ts = "double";
		break;
	    case TY_LDOUBLE:
		elftype = FT_ext_prec_float;
		ts = "long double";
		break;

	    case TY_VOID:
		elftype = FT_void;
		ts = "void";
		break;

	    /* For these, assume that the description of the type will be
	    ** generated eventually.  It will have a number related to the
	    ** type's ID, as usual.
	    */
	    case TY_STRUCT:
	    case TY_UNION:
	    case TY_ENUM:
		usertype = 1;
		/* If the guts of the type haven't been output, add this
		** type to the list of incomplete types.
		*/
		if (   ! DB_TY_CHKOUT(t)
		    && ! DB_TY_CHKNEED(t)) {
		    /* will need this one later */
		    DB_TY_SETNEED(t, TD_USED(td_dbstack));
		} /* if */
		break;

	    default:
		cerror("db_at_type:  can't output type %ld", (unsigned long) t);
	    }  /* switch */
	}  /* if */
	if (nptrs) {
	    if (usertype) {
		attr = AT_mod_u_d_type; attrstring = "AT_mod_u_d_type";
	    }
	    else {
		attr = AT_mod_fund_type; attrstring =  "AT_mod_fund_type";
	    }
	}
	else {
	    if (usertype) {
		attr = AT_user_def_type; attrstring = "AT_user_def_type";
	    }
	    else {
		attr = AT_fund_type; attrstring = "AT_fund_type";
	    }
	}
	dwarf_out("\tH\txC", attr, attrstring);
	if (nptrs) {
	    /* Generate length of whole attribute, modifiers. */
	    int i;

	    dwarf_out("\tH\td\n", nptrs + (usertype ? 4 : 2));
	    for (i = nptrs; i > 0; --i)
		dwarf_out("\tB\tx\n", MOD_pointer_to);
	}
	if (usertype)
	    dwarf_out("\tW\tLt\n", TY_MAPID(t));
	else
	    dwarf_out("\tH\txC", elftype, ts);
    } else {
	/* Dwarf 2
	** Generate the DW_AT_type info as needed.
	*/
        dwarf_out("\tW\tLt-sC", TY_MAPID(t), LAB_INFOBEGIN, "DW_AT_type");
    }  /* if */
}  /* db_at_type */


static ty_typetab
db_walktype(t)
T1WORD t;
/* Assume we're in a state where it's okay to write new debug info entries.
/* Walk the type structure t and flush all embedded types that have
** not been output.  Struct/union/enum's are emitted when they're seen.
** The debugging scope level at which the debugging information is needed
** or already generated is returned.
*/
{
    ty_typetab return_scope;

    if (IS_DWARF_1()) {
	/* Strip qualifiers, which the debug information does not represent. */
	t = TY_UNQUAL(t);
    }  /* if */

    /* Quit if stuff has already been generated for a type or previously
       recorded as needed. */
    if (DB_TY_CHKOUT(t) || DB_TY_CHKNEED(t))
	return (t < TY_NBASE) ? db_file_scope : TY_DBSCOPE(t);

    /* Dwarf 2 - cv-qualifiers are part of the type information. */
    if (IS_DWARF_2() && TY_ISQUAL(t)) {
	/* cv-qualified type should be put out at the same scope as
	   the derived-from type. */
	return_scope = db_walktype(TY_UNQUAL(t));
	DB_TY_SETNEED(t, return_scope);
	return (return_scope);
    }  /* if */
	
    switch( TY_TYPE(t) ){
    case TY_PTR:
    {
	T1WORD nextt = TY_DECREF(t);

	/* Check if generic pointer.  This would only be an issue for
	   DWARF 1 since DWARF 2 has the basic type DW_ATE_address as 
	   generic pointer used for void *. */
	if (IS_DWARF_1() && (TY_TYPE(nextt) == TY_VOID)) {
	    /* Generic pointer */
	    return_scope = db_file_scope;
	    break;
	}  /* if */
	/* Walk the type from here.  We will allow pointer modifiers,
	** because if we're going to generate a pointer type now, we
	** can handle modifiers.

	** The scope of a pointer should be the same as the type pointed
	** to.
	*/
	return_scope = db_walktype(nextt);	/* Keep going */
	DB_TY_SETNEED(t, return_scope);
	break;
    }
    case TY_ARY:
    {
	T1WORD newt = t;

	do {
	    newt = TY_DECREF(newt);
	} while (TY_ISARY(newt));

	(void)db_walktype(newt);	/* walk from non-array type */
	dwarf_outarray(t, 1);		/* output information for this array */
	/* The array type has been emitted at this scope. */
	return_scope = (ty_typetab)TD_USED(td_dbstack);
	break;
    }
    case TY_FUN:
	dwarf_outfunction(t);		/* output function type description */
	/* The function type has been emitted at this scope. */
	return_scope = (ty_typetab)TD_USED(td_dbstack);
	break;
    default:
	/* All other types will be emitted in the scope that they were
	   encountered.  Return that scope from the type table. */
	return_scope = (t < TY_NBASE) ? db_file_scope : TY_DBSCOPE(t);
	if (return_scope == 0 ) {
	    /* This type has not been encountered (officially).  Treat
	       it as appearing at the current scope. */
	    DB_TY_SETNEED(t, return_scope = TD_USED(td_dbstack));
	}  /* if */
    } /* end switch */
    return (return_scope);
}  /* db_walktype */


static void
dwarf_outarray(t, first)
T1WORD t;
int first;
/* Output a debug information entry for an array.  "first" is
** non-zero for the first of a sequence of array types, 0 for
** the rest.
*/
{
    T1WORD arrayof = TY_DECREF(t);
    int dimlab;				/* label number for start of
					** dimensions
					*/
    SIZE nelem = TY_NELEM(t);		/* number of elements at this level */

    /* Dwarf 1 - Subscript information looks like this for C:
    **		1	format (FMT_FT_C_C)
    **		2	type (int)
    **		4	low bound (0)
    **		4	high bound (number of elements - 1)
    **	       --
    **
    ** If the upper bound is unknown, the format is FMT_FT_C_X, with
    ** an empty high bound expression.
    **
    ** Following the subscript stuff comes FMT_ET, the element type,
    ** which is an embedded at_type.
    **
    **
    ** Dwarf 2 - Subscripting information is expressed in terms of
    **		 children subranges which specify the number of elements
    **		 in that dimension.  If the upper bound is unknown, the
    **		 count is specified as 0.
    */

    if (first) {
	int tag;

	tag = IS_DWARF_1() ? TAG_array_type : dw2_array;
	db_s_entry(tag);
	dwarf_out("=", (unsigned int)TY_MAPID(t));
	DB_TY_SETOUT(t);
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    dwarf_out("\tH\tx; H\txC", AT_ordering, ORD_row_major,
			"AT_ordering:  row major");
	    dwarf_out("\tH\txC", AT_subscr_data, "AT_subscr_data");
	    dimlab = DB_GENLAB();
	    dwarf_out("\tH\tLD-Ld\n", dimlab, dimlab); /* length of subscript data */
	    dwarf_out(".d", dimlab);		/* remember start of subscript data */
	}  else {
	    /* Dwarf 2 */
	    T1WORD elem_type = arrayof;
	    while (TY_ISARY(elem_type))
		elem_type = TY_DECREF(elem_type);
	    db_at_type(elem_type);
	    db_at_byte_size(TY_SIZE(t));
	    db_e_entry();
	    db_push();
	}  /* if */
      }
    
    /* Output subscript data at current level. */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	if (nelem == TY_NULLDIM || nelem == TY_ERRDIM)
	    dwarf_out("\tB\tx; H x; W s; H sC",
		    FMT_FT_C_X, FT_signed_integer, "0", "0", "no bound");
	else
	    dwarf_out("\tB\tx; H\tx; W\tsds\n",
		    FMT_FT_C_C, FT_signed_integer, "0,", nelem, "-1");

	if (TY_ISARY(arrayof))
	    dwarf_outarray(arrayof, 0);
	else {
	    dwarf_out("\tB\txC", FMT_ET, "FMT_ET");	/* output element type */
	    db_at_type(arrayof);
	}
    }  else {
	/* Dwarf 2 */
	db_s_entry(dw2_subrange);
	dwarf_out("\tluC", ((nelem == TY_NULLDIM || nelem == TY_ERRDIM) ?
			 0 : nelem), "DW_AT_count");
	db_e_entry();
	if (TY_ISARY(arrayof))
	    dwarf_outarray(arrayof, 0);
    }  /* if */
    if (first) {
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    dwarf_out(".D", dimlab);	/* end of subscript data */
	    db_e_entry();		/* end of array entry */
	}  else {
	    /* Dwarf 2 */
	    db_pop();
	}  /* if */
    }

    return;
}

static void
dwarf_outmember(sid)
SX sid;
/* Output debug information for each member of a s/u/e. */
{
    BITOFF mbroff = SY_OFFSET(sid);
    T1WORD t = SY_TYPE(sid);
    int tag_index;

    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	tag_index = TAG_member;
    } else {
	/* Dwarf 2 */
	tag_index = (SY_FLAGS(sid) & SY_ISFIELD) ? dw2_bit_field : dw2_su_member;
    }  /* if */
    db_s_entry(tag_index);
    db_at_name(SY_NAME(sid));
    if (IS_DWARF_2()) {
	/* Dwarf 2 */
	/* "plain" bitfields are treated as "unsigned" in the Intel x86 ABI,
	   while "plain" integer types are considered "signed". */
	if (   (SY_FLAGS(sid) & SY_ISFIELD)
	    && (TY_ISSIGNED(t) < 0  /* "plain" integer type */) ) {
	    /* Tweak the integer type to "unsigned type. */
	    switch (t) {
		case TY_CHAR:	t = TY_UCHAR; break;
		case TY_SHORT:	t = TY_USHORT; break;
		case TY_INT:	t = TY_UINT; break;
		case TY_LONG:	t = TY_ULONG; break;
		case TY_LLONG:	t = TY_ULLONG; break;
	    }  /* switch */
	}  /* if */
    }  /* if */
    db_at_type(t);
    if (SY_FLAGS(sid) & SY_ISFIELD) {
	/* Extra stuff for bitfields. */
	BITOFF size;
	BITOFF offset;
	BITOFF align = TY_ALIGN(t);

	SY_FLDUPACK(sid, size, offset);

	/* Calculate offset of field relative to an object of its
	** type's alignment.  Then adjust "mbroff" to reflect such
	** an object.
	** If RTOLBYTES, the bit offset is of the right-most bit,
	** and we need the position of the left-most one, which is
	** displaced by sizeof(field) from the opposite end of the
	** storage unit.
	*/
	mbroff = (offset/align) * align;
	offset %= align;
#ifdef RTOLBYTES
	offset = (TY_SIZE(t) - size) - offset;
#endif
	db_at_byte_size(TY_SIZE(t));	/* in a unit of its type */
	/* Output field size, offset. */
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    dwarf_out("\tH\tx; W\tdC", AT_bit_size, size, "AT_bit_size");
	    dwarf_out("\tH\tx; H\tdC", AT_bit_offset, offset, "AT_bit_offset");
	} else {
	    dwarf_out("\tluC", size, "DW_AT_bit_size");
	    dwarf_out("\tluC", offset, "DW_AT_bit_offset");
	    dwarf_out("\tB\txC", 0, "DW_AT_SCO_mutable"); /* only needed for C++ */
	}  /* if */
    }
    /* Output location attribute; address of start of s/u is implicit. */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	dwarf_out("\tH\tx; H d; B x; W d; B xC",
		AT_location, 1+4+1, OP_CONST, mbroff/SZCHAR, OP_ADD,
		"AT_location: OP_CONST val OP_ADD");
    } else {
	/* Dwarf 2 */
	dw2_out_loc_desc("DW_AT_data_member_location", DW_FORM_block1,
			    DW_OP_plus_uconst, mbroff/SZCHAR, DB_DW2_END);
    }  /* if */
    db_e_entry();
    return;
}


static void
dwarf_outfunction(t)
T1WORD t;
/* Output debug information entry for a function-returning type. */
{
    T1WORD rett = TY_DECREF(t);		/* return type */
    int tag;

    db_walktype(rett);			/* output return sub-type stuff */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	tag = TAG_subroutine_type;
    } else {
	/* Dwarf 2 */
	tag =  (rett == TY_VOID) ? dw2_void_subr_type
				 : dw2_non_void_subr_type;
    }  /* if */
    db_s_entry(tag);
    dwarf_out("=", (unsigned int)TY_MAPID(t));		/* label this type */
    DB_TY_SETOUT(t);			/* mark type as being generated */
    if (rett != TY_VOID || IS_DWARF_1())
	db_at_type(rett);		/* describe the returned type */
    if (IS_DWARF_2()) {
	/* Dwarf 2 */
	dwarf_out("\tB\txC", (TY_HASPROTO(t) ? 1 : 0), "DW_AT_prototyped");
    }  /* if */
    db_e_entry();


    /* Debug info entries for formals are children of the subroutine
    ** entry.
    **
    ** Note: Any types introduced in the parameter list such as array types
    **	     will appear in the children list, intermixed with formal
    **	     parameter types.
    */
    db_push();

    if (TY_HASPROTO(t)) {
	int i;
	int nparams;

	
	for (nparams = TY_NPARAM(t), i = 0; i < nparams; ++i) {
	    T1WORD paramt = TY_PROPRM(t,i);

	    /* Walk the param type, output any lower level information there. */
	    db_walktype(paramt);

	    db_s_entry(IS_DWARF_1() ? TAG_formal_parameter
				    : dw2_formal_param_type);
	    db_at_type(paramt);
	    db_e_entry();
	}

	/* Represent "...". */
	if (TY_ISVARARG(t)) {
	    db_s_entry(IS_DWARF_1() ? TAG_unspecified_parameters
				    : dw2_unspecified_params);
	    db_e_entry();
	}
    }
    else {
	/* Unknown parameter information looks like "...". */
	db_s_entry(IS_DWARF_1() ? TAG_unspecified_parameters
				: dw2_unspecified_params);
	db_e_entry();
    }

    db_pop();
    return;
}  /* dwarf_outfunction */


static void
db_uctype(type)
T1WORD type;
/*  Output the debug information entry for specified type.  It has been
    determined that the type entry is needed (referenced already) and
    is required in the debugging information.
*/
{
    T1WORD derived_from_type;

    /* Quit if stuff has already been generated for the type. */
    if (DB_TY_CHKOUT(type))
	return;

    derived_from_type = TY_UNQUAL(type);

    /* "const" and "volatile" type modifiers are ignored for Dwarf 1
       debugging information.  Separate type entries are required for 
       Dwarf 2. */
    if (IS_DWARF_2()) {
	int typeid_used = 0;

	if (TY_ISCONST(type)) {
	    db_s_entry(dw2_const_type);
	    /* acomp will combine "const" and "volatile" into a single
	       type entry, but Dwarf 2 requires a separate modifier. */
	    if (TY_ISVOLATILE(type))
		/* Use the debug information label of the sibling "volatile"
		   type (next to be generated) as the type label. */
		dwarf_out("\tW\tLd-sC", DB_CURSIBLING, LAB_INFOBEGIN,
		       "DW_AT_type");
	    else
		dwarf_out("\tW\tLt-sC", derived_from_type, LAB_INFOBEGIN,
		       "DW_AT_type");
	    typeid_used = 1;
	    dwarf_out("=", (unsigned int)TY_MAPID(type));
	    db_e_entry();
	    DB_TY_SETOUT(type);
	}  /* if */
	if (TY_ISVOLATILE(type)) {
	    db_s_entry(dw2_volatile_type);
	    dwarf_out("\tW\tLt-sC", derived_from_type, LAB_INFOBEGIN,
		   "DW_AT_type");
	    if (typeid_used == 0) {
		dwarf_out("=", (unsigned int)TY_MAPID(type));
		DB_TY_SETOUT(type);
	    }  /* if */
	    db_e_entry();
	}  /* if */
    }  /* if */

    /* Now look at the unqualified type. */
    type = derived_from_type;

    /* Quit if stuff has already been generated for the unqualified type. */
    if (DB_TY_CHKOUT(type))
	return;

    switch (TY_TYPE(type)){
	case TY_PTR:
	{
	    if (type == ty_voidstar)
		break;			/* For Dwarf 1 */
	    if (IS_DWARF_2()) {
		/* For DWARF 1, pointer types are NOT specifically emitted, but
                   are handled as an AT_mod_u_d_type. */
		DB_TY_SETOUT(type);
		db_s_entry(dw2_pointer_type);
		dwarf_out("\tW\tLt-sC", TY_DECREF(type), LAB_INFOBEGIN,
		       "DW_AT_type");
		dwarf_out("=", (unsigned int)TY_MAPID(type));
		db_e_entry();
	    }  /* if */
	    break;
	}

	case TY_ARY:
	{
	}

	case TY_FUN:
	{
	}

	case TY_STRUCT:
	case TY_UNION:
	case TY_ENUM:
	{
	    db_force_incomplete_type = 1;
	    db_sue(type);
	    db_force_incomplete_type = 0;
	    break;
	}
    }  /* switch */
}  /* db_uctype */

static void
db_dw2_setup_indices()
/* For Dwarf2, assume a .o containing the "standard" abbreviation table will be
   brought in at link time.  This is the default behavior.  All the compiler
   needs to do is initialize the index variables.
*/
{
	dw2_compile_unit = DW2_compile_unit;
	dw2_compile_no_line_info = DW2_compile_no_line_info;
	dw2_base_type = DW2_base_type;
	dw2_pointer_type = DW2_pointer_type;
	dw2_const_type = DW2_const_type;
	dw2_volatile_type = DW2_volatile_type;
	dw2_typedef = DW2_typedef;
	dw2_struct = DW2_struct;
	dw2_incomplete_struct = DW2_incomplete_struct;
	dw2_union = DW2_union;
	dw2_incomplete_union = DW2_incomplete_union;
	dw2_su_member = DW2_su_member;
	dw2_bit_field = DW2_bit_field;
	dw2_enumeration = DW2_enumeration;
	dw2_incomplete_enumeration = DW2_incomplete_enumeration;
	dw2_enumerator = DW2_enumerator;
	dw2_array = DW2_array;
	dw2_subrange = DW2_subrange;
	dw2_non_void_subr_type = DW2_non_void_subr_type;
	dw2_void_subr_type = DW2_void_subr_type;
	dw2_formal_param_type = DW2_formal_param_type;
	dw2_unspecified_params = DW2_unspecified_params;
	dw2_variable = DW2_variable;
	dw2_variable_no_decl = DW2_variable_no_decl;
	dw2_formal_param = DW2_formal_param_no_decl;
	dw2_label = DW2_label;
	dw2_non_void_subr = DW2_non_void_subr;
	dw2_void_subr = DW2_void_subr;
	dw2_lexical_block = DW2_lexical_block;
}

static void
db_dw2_abbrev_table()
/* For Dwarf 2, generate a separate .debug_abbrev section (instead of using
** the standard, shared version.)
*/
{
    fprintf(dbout, "\t%s\t%s\n", SECTION, DB_DOTDBG_ABBR);
    /* output Abbreviation table lable */
    dwarf_out("s:\tC", LAB_ABBRBEGIN, "Dwarf 2 - Abbreviation Table");
    dw2_compile_unit = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_compile_unit , DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_comp_dir, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_language, DW_FORM_data1);
	DW2_ABBREV_TAG_ATTR(DW_AT_producer, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_low_pc, DW_FORM_addr);
	DW2_ABBREV_TAG_ATTR(DW_AT_high_pc, DW_FORM_addr);
	DW2_ABBREV_TAG_ATTR(DW_AT_stmt_list, DW_FORM_data4);
	DW2_END_ABBREV_ENTRY();

    dw2_compile_no_line_info = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_compile_unit , DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_comp_dir, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_language, DW_FORM_data1);
	DW2_ABBREV_TAG_ATTR(DW_AT_producer, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_low_pc, DW_FORM_addr);
	DW2_ABBREV_TAG_ATTR(DW_AT_high_pc, DW_FORM_addr);
	DW2_END_ABBREV_ENTRY();

    dw2_base_type = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_base_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_encoding, DW_FORM_data1);
	DW2_ABBREV_TAG_ATTR(DW_AT_byte_size, DW_FORM_udata);
	DW2_END_ABBREV_ENTRY();

    dw2_pointer_type = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_pointer_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_END_ABBREV_ENTRY();

    dw2_const_type = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_const_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_END_ABBREV_ENTRY();

    dw2_volatile_type = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_volatile_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_END_ABBREV_ENTRY();

    dw2_typedef = DW2_START_ABBREV_ENTRY();
	DW2_ABBREV_TAG_ATTR(DW_TAG_typedef, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_END_ABBREV_ENTRY();

    dw2_struct = DW2_START_ABBREV_ENTRY();		/* struct */
	DW2_ABBREV_TAG_ATTR(DW_TAG_structure_type, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_byte_size, DW_FORM_udata);
	DW2_END_ABBREV_ENTRY();

    dw2_incomplete_struct = DW2_START_ABBREV_ENTRY();	/* incomplete struct */
	DW2_ABBREV_TAG_ATTR(DW_TAG_structure_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_declaration, DW_FORM_flag);
	DW2_END_ABBREV_ENTRY();

    dw2_union = DW2_START_ABBREV_ENTRY();		/* union */
	DW2_ABBREV_TAG_ATTR(DW_TAG_union_type, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_byte_size, DW_FORM_udata);
	DW2_END_ABBREV_ENTRY();

    dw2_incomplete_union = DW2_START_ABBREV_ENTRY();	/* incomplete union */
	DW2_ABBREV_TAG_ATTR(DW_TAG_union_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_declaration, DW_FORM_flag);
	DW2_END_ABBREV_ENTRY();

    dw2_su_member = DW2_START_ABBREV_ENTRY();	/* struct/union member */
	DW2_ABBREV_TAG_ATTR(DW_TAG_member, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_data_member_location, DW_FORM_block1);
	DW2_END_ABBREV_ENTRY();

    dw2_bit_field = DW2_START_ABBREV_ENTRY();		/* bit field */
	DW2_ABBREV_TAG_ATTR(DW_TAG_member, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_byte_size, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_bit_size, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_bit_offset, DW_FORM_data1);
	DW2_ABBREV_TAG_ATTR(DW_AT_SCO_mutable, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_data_member_location, DW_FORM_block1);
	DW2_END_ABBREV_ENTRY();

    dw2_enumeration = DW2_START_ABBREV_ENTRY();		/* enumeration */
	DW2_ABBREV_TAG_ATTR(DW_TAG_enumeration_type, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_byte_size, DW_FORM_udata);
	DW2_END_ABBREV_ENTRY();

    dw2_incomplete_enumeration = DW2_START_ABBREV_ENTRY();
						/* incomplete enumeration */
	DW2_ABBREV_TAG_ATTR(DW_TAG_enumeration_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_declaration, DW_FORM_flag);
	DW2_END_ABBREV_ENTRY();

    dw2_enumerator = DW2_START_ABBREV_ENTRY();		/* enumerator */
	DW2_ABBREV_TAG_ATTR(DW_TAG_enumerator, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_const_value, DW_FORM_sdata);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_END_ABBREV_ENTRY();

    dw2_array = DW2_START_ABBREV_ENTRY();		/* array */
	DW2_ABBREV_TAG_ATTR(DW_TAG_array_type, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_byte_size, DW_FORM_udata);
	DW2_END_ABBREV_ENTRY();

    dw2_subrange = DW2_START_ABBREV_ENTRY();		/* subrange */
	DW2_ABBREV_TAG_ATTR(DW_TAG_subrange_type, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_count, DW_FORM_udata);
	DW2_END_ABBREV_ENTRY();

    dw2_non_void_subr_type = DW2_START_ABBREV_ENTRY(); /* subroutine type */
    						/* non-void return type */
	DW2_ABBREV_TAG_ATTR(DW_TAG_subroutine_type, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_prototyped, DW_FORM_flag);
	DW2_END_ABBREV_ENTRY();

    dw2_void_subr_type = DW2_START_ABBREV_ENTRY();	/* subroutine type */
							/* void return type */
	DW2_ABBREV_TAG_ATTR(DW_TAG_subroutine_type, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_prototyped, DW_FORM_flag);
	DW2_END_ABBREV_ENTRY();

    dw2_formal_param_type = DW2_START_ABBREV_ENTRY();	/* param type */
	DW2_ABBREV_TAG_ATTR(DW_TAG_formal_parameter, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_END_ABBREV_ENTRY();

    dw2_unspecified_params = DW2_START_ABBREV_ENTRY();	/* unspecified params */
	DW2_ABBREV_TAG_ATTR(DW_TAG_unspecified_parameters, DW_CHILDREN_no);
	DW2_END_ABBREV_ENTRY();

    dw2_non_void_subr = DW2_START_ABBREV_ENTRY(); /* subroutine */
    						/* non-void return type */
	DW2_ABBREV_TAG_ATTR(DW_TAG_subprogram, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_decl_file, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_decl_line, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_prototyped, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_external, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_low_pc, DW_FORM_addr);
	DW2_ABBREV_TAG_ATTR(DW_AT_high_pc, DW_FORM_addr);
	DW2_END_ABBREV_ENTRY();

    dw2_void_subr = DW2_START_ABBREV_ENTRY();	/* subroutine */
							/* void return type */
	DW2_ABBREV_TAG_ATTR(DW_TAG_subprogram, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_decl_file, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_decl_line, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_prototyped, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_external, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_low_pc, DW_FORM_addr);
	DW2_ABBREV_TAG_ATTR(DW_AT_high_pc, DW_FORM_addr);
	DW2_END_ABBREV_ENTRY();

    dw2_variable_no_decl = DW2_START_ABBREV_ENTRY();	/* variable */
	DW2_ABBREV_TAG_ATTR(DW_TAG_variable, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_external, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_location, DW_FORM_block1);
	DW2_END_ABBREV_ENTRY();

    dw2_variable = DW2_START_ABBREV_ENTRY();	/* variable & DECL */
	DW2_ABBREV_TAG_ATTR(DW_TAG_variable, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_decl_file, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_decl_line, DW_FORM_udata);
	DW2_ABBREV_TAG_ATTR(DW_AT_external, DW_FORM_flag);
	DW2_ABBREV_TAG_ATTR(DW_AT_location, DW_FORM_block1);
	DW2_END_ABBREV_ENTRY();

    dw2_formal_param = DW2_START_ABBREV_ENTRY();	/* formal param */
	DW2_ABBREV_TAG_ATTR(DW_TAG_formal_parameter, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_type, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_location, DW_FORM_block1);
	DW2_END_ABBREV_ENTRY();

    dw2_lexical_block = DW2_START_ABBREV_ENTRY(); /* lexical block */
	DW2_ABBREV_TAG_ATTR(DW_TAG_lexical_block, DW_CHILDREN_yes);
	DW2_ABBREV_TAG_ATTR(DW_AT_sibling, DW_FORM_ref4);
	DW2_ABBREV_TAG_ATTR(DW_AT_low_pc, DW_FORM_addr);
	DW2_ABBREV_TAG_ATTR(DW_AT_high_pc, DW_FORM_addr);
	DW2_END_ABBREV_ENTRY();

    dw2_label = DW2_START_ABBREV_ENTRY(); /* label */
	DW2_ABBREV_TAG_ATTR(DW_TAG_label, DW_CHILDREN_no);
	DW2_ABBREV_TAG_ATTR(DW_AT_name, DW_FORM_string);
	DW2_ABBREV_TAG_ATTR(DW_AT_low_pc, DW_FORM_addr);
	DW2_END_ABBREV_ENTRY();

    dwarf_out("\tluC", DB_DW2_END, "end section");
    fputs(DB_DOTPREVIOUS, dbout);
}  /* db_dw2_abbrev_table */


static void
db_dw2_fund_types()
/* Generate the fundamental types for C and C++.  

   NOTE: These fundamental type entries are ideal candidates to move to 
         a common .debug_info section to be shared by all .o's when
	 compiled with debugging.
*/
{
    DW2_BASE_TYPE(TY_CHAR, "char", DW_ATE_signed_char, SZCHAR/SZCHAR );
    DW2_BASE_TYPE(TY_UCHAR, "unsigned char", DW_ATE_unsigned_char, SZCHAR/SZCHAR );
    DW2_BASE_TYPE(TY_SCHAR, "signed char", DW_ATE_signed_char, SZCHAR/SZCHAR );

    DW2_BASE_TYPE(TY_SHORT, "short", DW_ATE_signed, SZSHORT/SZCHAR );
    DW2_BASE_TYPE(TY_USHORT, "unsigned short", DW_ATE_unsigned, SZSHORT/SZCHAR );
    DW2_BASE_TYPE(TY_SSHORT, "signed short", DW_ATE_signed, SZSHORT/SZCHAR );

    DW2_BASE_TYPE(TY_INT, "int", DW_ATE_signed, SZINT/SZCHAR );
    DW2_BASE_TYPE(TY_UINT, "unsigned int", DW_ATE_unsigned, SZINT/SZCHAR );
    DW2_BASE_TYPE(TY_SINT, "signed int", DW_ATE_signed, SZINT/SZCHAR );

    DW2_BASE_TYPE(TY_AINT, "(ambiguous) int", DW_ATE_signed, SZINT/SZCHAR );
    DW2_BASE_TYPE(TY_AUINT, "(ambiguous) unsigned int", DW_ATE_unsigned, SZINT/SZCHAR );

    DW2_BASE_TYPE(TY_LONG, "long", DW_ATE_signed, SZLONG/SZCHAR );
    DW2_BASE_TYPE(TY_ULONG, "unsigned long", DW_ATE_unsigned, SZLONG/SZCHAR );
    DW2_BASE_TYPE(TY_SLONG, "signed long", DW_ATE_signed, SZLONG/SZCHAR );
    DW2_BASE_TYPE(TY_LLONG, "long long", DW_ATE_signed, SZLLONG/SZCHAR );
    DW2_BASE_TYPE(TY_ULLONG, "unsigned long long", DW_ATE_unsigned, SZLLONG/SZCHAR );
    DW2_BASE_TYPE(TY_SLLONG, "signed long long", DW_ATE_signed, SZLLONG/SZCHAR );
    DW2_BASE_TYPE(TY_FLOAT, "float", DW_ATE_float, SZFLOAT/SZCHAR );
    DW2_BASE_TYPE(TY_DOUBLE, "double", DW_ATE_float, SZDOUBLE/SZCHAR );
    DW2_BASE_TYPE(TY_LDOUBLE, "long double", DW_ATE_float, SZLDOUBLE/SZCHAR );

    DW2_BASE_TYPE(TY_VOID, "void", DW_ATE_unsigned, 0);

    /* Set "void *" as a fundamental type -- address. */
    DW2_BASE_TYPE(ty_voidstar, "void *", DW_ATE_address, SZPOINT/SZCHAR);
}  /* db_dw2_fund_types */


static void
db_dw2_init_line_section()
/* Generate the Statement Program Prologue as defined in 6.2.4 of the
   Dwarf Debugging Information Format 2.0. Also initialize the variables
   used to represent the "current" values of the line number state 
   machine.
*/
{
    int prologue_label_no = DB_GENLAB();
    int index, limit;
    int index_assigned;

    /* First generate the prologue which will have the following format.

	.section .debug_line
      ..line_b:
	.uaword ..line.e-..line_b-4	/ length of statement info
	.uahalf 0x2			/ version 2
	.uaword ..Dnnn.e-..Dnnn		/ statement program prologue length
	.uabyte 0x1			/ minimum instruction length
	.uabyte 0x1			/ default - is statement
	.uabyte aaa			/ line base
	.uabyte bbb			/ line range
	.uabyte ccc			/ opcode base
	.uabyte n n n n...		/ standard_opcode operand counts
	.string "xxxx"			/ sequence of include directory
	.string .......			/     path names
	.uabyte 0x0			/ include directory sequence termination
	.string "<file_name>"		/ sequence of file entries - name
	.leb128 0xnnn			/     directory index
	.leb128 <file_last_mod_date>	/     write date of file
	.leb128 <file_length>		/     file byte length
	.uabyte 0x0			/ file entry sequence termination
    */
    dwarf_out("Sl.b\tW\tLe-Lb-4C\tH\txC\tW\tLD-LdC.d\tB\txC\tB\txC\tB\tdC\tB\tdC\tB\tdC",
	   "Dwarf 2 - start line number section",
	   DB_DW2_VERSION /*version 2*/, "version 2",
	   prologue_label_no, prologue_label_no,
			"statement program prologue length",
	   prologue_label_no,
	   1, "minimum instruction length",
	   1, "default - is statement",
	   (dw2_line_base = DB_DW2_LINE_BASE), "line base",
	   (dw2_line_range = DB_DW2_LINE_RANGE), "line range",
	   (dw2_opcode_base = DB_DW2_OPCODE_BASE), "opcode base");
    /* Output the array of bytes representing the operand count for each
       standard opcode (opcode_base - 1 bytes) */
    dwarf_out("\tB\td,d,d,d,d,d,d,d,dC", 0, 1, 1, 1, 1, 0, 0, 0, 1,
	   "standard opcode operand counts");
    /* Output a sequence of names representing the set of include 
       directories used by the compiler.  The "current" working directory
       is represented at index ZERO and is not emitted in DWARF 2. */
    /* Only include directories that are actually used are emitted. */
    for (index = 1, index_assigned = 1, limit = DB_INCDIR_USED;
	 index < limit;
	 index++) {
	if (DB_INCDIR_REFD(index)) {
	    dwarf_out("bC", DB_INCDIR_NAME(index), "include directory");
	    DB_INCDIR_DBINDEX(index) = index_assigned++;
	}  /* if */
    }  /* for */

    /* Terminate the include directory path name sequences */
    dwarf_out("\tB\txC", 0, "terminate include directories");

    /* Output the sequence of source file entries for this compilation. */
    for (index = 0, limit = DB_SRCFILE_USED;
	 index < limit;
	 index++) {
	db_srcfile *src_ptr;

	src_ptr = &(TD_ELEM(td_dbsrcfile, db_srcfile, (index)));
	dwarf_out("bC\tluC\tluC\tluC",
	       src_ptr->filename, "source file name",
	       DB_INCDIR_DBINDEX(src_ptr->dir_index), "directory index",
	       src_ptr->last_mod_time, "time of last modification",
	       src_ptr->byte_size, "file size in bytes");
    }  /* for */

    /* Terminate the file name sequences. */
    dwarf_out("\tB\txC", 0, "terminate source file info sequences");
 
    dwarf_out(".D", prologue_label_no);

    /* Now generate a "DW_LNE_set_address" expended opcode instruction
       to set the address register to that of ..text.b. */
    dwarf_out("\tB\tx;\tlu;\tB\tx;\tW\tLBC", 0, (1 + SZPOINT/SZCHAR),
	   DW_LNE_set_address, "DW_LNE_set_address");
    dwarf_out("Sp");
}  /* db_dw2_init_line_section */


static void
db_begfile()
/* Generate initial debug information after the rest of the compiler
** has decided on .file and .ident pseudo-ops.
*/
{
    static int firsttime = 1;

    if (! firsttime || db_symlevel == DB_LEVEL0) /* only do this once */
	return;
    
    firsttime = 0;
    /* Create a file scope concept of a basic block that has been 
       started.  This is used to catch struct, union or enumeration
       types that occur as the first thing in a basic block of code
       and require that a delayed lexical block TAG be generated.
       Mark the "fake" basic block as begun to avoid a lexical block
       being forced out at the file scope or function scope.  These
       scopes are automatically created (not delayed).
    */
    db_begfile_seen = 1;
    if (++bblevel >= td_bbflags.td_allo) {
	TD_NEED1(td_bbflags);
	TD_CHKMAX(td_bbflags);
    }
    BBFLAG = 1;			/* will soon output entry at this level */

    cg_setlocctr(PROG);			/* force to .text */
    /* Set beginning of text label, initialize sections. */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	db_dbg_sec_name = DB_DOTDEBUG;
	db_line_sec_name = DB_DOTLINE;
    }  else {
	/* Dwarf 2 */
	db_dbg_sec_name = DB_DOTDBG_INFO;
	db_line_sec_name = DB_DOTDBG_LINE;
    }  /* if */
    dwarf_out(".B");
    /* Initialize sections with all their attributes. */
    /* Right now, there are no attributes for these sections. */
    fprintf(dbout, "\t%s\t%s\n\t.previous\n", SECTION, db_dbg_sec_name);
    fprintf(dbout, "\t%s\t%s\n\t.previous\n", SECTION, db_line_sec_name);
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	db_s_entry(TAG_source_file);
	db_at_name(db_filename);
	dwarf_out("\tH\tx; W\txC", AT_language, db_language, "AT_language");
	dwarf_out("\tH\tx; W\tLBC\tH\tx; W\tLEC",
	       AT_low_pc, "AT_low_pc", AT_high_pc, "AT_high_pc");
	if (db_linelevel == DB_LEVEL2)
	    dwarf_out("\tH\tx; W\tLbC", AT_stmt_list, "AT_stmt_list");
	db_e_entry();
	/* Set up start of line number information. */
	if (db_linelevel == DB_LEVEL2)
	    dwarf_out("Sl.b\tW\tLe-Lb; W\tLB\nSp");

	/* file entry owns all the others */
	db_push();
	db_file_scope = TD_USED(td_dbstack);

    } else {
	/* Dwarf 2 */

	char            buffer[SYS_NMLN+PATH_MAX+2];
	struct utsname  unm;
	size_t          len;

	fprintf(dbout, "\t%s\t%s\n\t.previous\n", SECTION, DB_DOTDBG_ABBR);
	/* The following 2 sections can only be flagged for output if
	   generating Dwarf 2; this is controlled currently when
	   the command line options are processed in main.c. */
	if (db_name_lookup) {
		fprintf(dbout, "\t%s\t%s\n\t.previous\n", SECTION, DB_DOTDBG_NAME);
	}  /* if */
	if (db_addr_ranges) {
		fprintf(dbout, "\t%s\t%s\n\t.previous\n", SECTION, DB_DOTDBG_ADDR);
	}  /* if */
	if (db_abbreviations)
	    db_dw2_abbrev_table();		/* generate abbrev. table */
	else
	    db_dw2_setup_indices();	/* use standard shared abbrev. table */

	/* Generate the .debug_info header. */
	dwarf_out("Sds:\tC", LAB_INFOBEGIN, "Dwarf 2 - .debug_info section header");
	dwarf_out("\tW\ts-s-4C", LAB_INFOEND, LAB_INFOBEGIN,
	       ".debug_info section length less these 4 bytes");
	dwarf_out("\tH\txC", DB_DW2_VERSION /*version 2*/, "version 2");
	dwarf_out("\tW\tsC", (db_abbreviations ? LAB_ABBRBEGIN : ABBREV_VERSION_ID),
		"abbreviation table offset");
	dwarf_out("\tB\txC", SZPOINT/SZCHAR, "size of an address");

	/* Generate the compilation unit header. */
	dwarf_out("\tluC", (db_linelevel == DB_LEVEL2 ? dw2_compile_unit
		       : dw2_compile_no_line_info),
       "DW_TAG_compile_unit");

	/* create the string "host:compilation_dir" for DW_AT_comp_dir */
	if (uname(&unm) < 0) {
		len = 0;
	} else {
		len = strlen(unm.nodename);
		strncpy(buffer, unm.nodename, SYS_NMLN);
	} /* fi */
	buffer[len] = ':';
	strcpy(&buffer[len+1], DB_INCDIR_NAME(0));

	dwarf_out("bC", buffer, "DW_AT_comp_dir");
	db_at_name(db_filename);
	dwarf_out("\tB\txC", db_language, "DW_AT_language");
	/* NEED PRODUCER INFORMATION HERE !!!! */
	dwarf_out("bC", "SCO " CPL_PKG, "DW_AT_producer");
	dwarf_out("\tW\tLBC\tW\tLEC", "DW_AT_low_pc", "DW_AT_high_pc");
	if (db_linelevel == DB_LEVEL2)
	    dwarf_out("\tW\tLbC", "DW_AT_stmt_list");
	dwarf_out("Sp");

	/* Generate the .debug_pubnames section header. */
	if (db_name_lookup) {
	    dwarf_out("Sn\tW\ts-sC", LAB_NAMEEND, LAB_NAMEBEGIN,
		   "Dwarf 2 - .debug_pubnames section header");
	    dwarf_out("s:\tC", LAB_NAMEBEGIN,
		   "Dwarf 2 - .debug_pubnames section start");
	    dwarf_out("\tH\txC", DB_DW2_VERSION /*version 2*/, "version 2");
	    dwarf_out("\tW\tsC", LAB_INFOBEGIN, ".debug_info offset");
	    dwarf_out("Sd\tW\ts-sC", LAB_INFOEND, LAB_INFOBEGIN,
		   "length of .debug_info section (including 4 byte len.)");
	    dwarf_out("Sp");
	}  /* if */

	/* file entry owns all the others */
	db_push();
	db_file_scope = TD_USED(td_dbstack);

	db_dw2_fund_types();

    }  /* if */
    return;
}  /* db_begfile */

void
db_s_file(s)
char * s;
/* Do what needs to be done for debug information at the start of a file. */
{
    db_filename = st_lookup(s);		/* remember filename for later */
    if (db_linelevel == DB_LEVEL2) {
	/* If this is a normal compilation, this filename will be identical
	   to the primary source file.  If this is a compilation of
	   preprocessed source (-E), then this may be different and should
	   take precedence. */
	if (DB_SRCFILE_USED >= 1) {
	    db_add_src_file_to_table(s, 0);
	}  /* if */
    }  /* if */
    return;
}


void
db_s_cwd(s)
char * s;
/* Record the current working directory.  If this is not the first
   call of this function, preprocessed source is being compiled and
   a "#pragma working_directory" has been seen.  The current working
   directory and include directories will be reset to those in
   effect at the time of preprocessing.
*/
{
    if (db_linelevel == DB_LEVEL2) {
	if (DB_INCDIR_USED != 0) {
	    /* A "#pragma working_directory" has been seen; this is 
	       preprocessed input (or generated C for C++ source).
	       Check if the compilation/code generation is being
	       done in the same directory (important to correctly
	       lookup the date stamp and file size of the source
	       file(s) involved in this compilation. */
	    if (strcmp(s, DB_INCDIR_NAME(0)) != 0) {
		code_gen_in_diff_wd = 1;	/* TRUE */
	    }  /* if */
	}  /* if */

	/* Start the table (array) from the first entry. */
	DB_INCDIR_USED = 0;		/* In case, this is not 1st call. */
	TD_NEED(td_dbincdir, 1);
	DB_INCDIR_NAME(0) = s = st_lookup(s);
					/* remember directory for later */
	DB_INCDIR_DBINDEX(0) = 0;	/* The index of the "current
					   working directory" is 0 - Dwarf 2 */
	DB_INCDIR_USED++;
    }  /* if */
    return;
}  /* db_s_cwd */


void
db_reg_incdir(s)
char * s;
/* Enter the include directory specified by the string "s" into the
   include directory stack.  The first directory entered should be
   the "current working directory"; done with call to db_s_cwd(). */
{
    if (db_linelevel == DB_LEVEL2) {
	TD_NEED(td_dbincdir, 1);
	DB_INCDIR_NAME(DB_INCDIR_USED) = s = st_lookup(s);
					/* remember directory for later */
	DB_INCDIR_DBINDEX(DB_INCDIR_USED) = 0;
	DB_INCDIR_REFD(DB_INCDIR_USED) = 0;
	DB_INCDIR_USED++;
    }  /* if */
    return;
}  /* db_reg_incdir */


static void
db_add_src_file_to_table(name, index)
char * name;
int index;
/*
   Add the file name specified by "name" to the source file table at
   the specified index "index".  Typically, the index would be for the
   next available spot in the table, but, the primary source file
   information may be overwritten as a result of encountering a
   "#pragma file" directive in preprocessed input.
*/
{
    int inc_index, limit;
    db_srcfile *src_ptr;
    char dir_path[MAXPATHLEN+1];
    char * null_spot = 0;
    char * filename = 0;
    struct stat file_stat;
    int    byte_size = 0;		/* default - info not available. */
    time_t last_mod_time = 0;		/* default - info not available. */

    static time_t dot_i_time_stamp = 0;
    static int    preprocessed_input = 0;

    /* Add the file to the table (array).  The index value should be equal
       to DB_SRCFILE_USED for new entries.  A value of zero implies that
       the primary source file is being entered for a second time. */
#ifndef NODBG
    if (index > DB_SRCFILE_USED)
	cerror("db_add_src_file_to_table: file index too large.\n");
#endif
    if (index == (limit = DB_SRCFILE_USED)) {
	TD_NEED(td_dbsrcfile, 1);	/* Insure enough space. */
	DB_SRCFILE_USED++;
    }  /* if */

    src_ptr = &TD_ELEM(td_dbsrcfile, db_srcfile, index);
    filename = st_lookup(name);

    if (   index < limit
        && strcmp(filename, src_ptr->pathname) != 0 ) {
	/* This should only happen if a "#file" directive was encountered
	   (preprocessed input). */
#ifndef NODBG
	if (index != 0) {
	    cerror("db_add_src_file_to_table: file index incorrect (not zero)\n");
	}  /* if */
#endif
	/* Updating the primary source file name; save the time stamp
	   of the .i file. */
	dot_i_time_stamp = src_ptr->last_mod_time;
	preprocessed_input = 1;		/* TRUE */
    }  /* if */

    src_ptr->pathname = filename;
    /* The first file, added at index 0, is actually file number 1
       in the debugging (Dwarf 2) info scheme of things.  Adjust the file
       index number assigned accordingly. */
    src_ptr->debug_index = ++index;

    if (stat(name, &file_stat) == 0) {
	/* Everything is OK - have valid data. */
	byte_size = file_stat.st_size;
	last_mod_time = file_stat.st_mtime;
    }  else {
	/* Got an error.  One possible reason is that we are compiling
	   preprocessed source in a different directory than the one
	   in which the preprocessing was done.  Why anyone would do
	   this is not obvious or logical, but we can recover from this
	   by redoing the stat() call with a complete path name for 
	   relative file names....... complete with the working directory
	   from the "#pragma working_directory". */
	if (   *name != '/'		/* relative file name */
	    && code_gen_in_diff_wd) {

	    int len;
	    /* Construct a full path name. */
	    strcpy(dir_path, DB_INCDIR_NAME(0));
	    len = strlen(dir_path);
	    if (dir_path[len - 1] != '/') {
		dir_path[len++] = '/';		/* Add trailing '/'. */
	    }  /* if */
	    strcpy(&dir_path[len], name);
	    if (stat(dir_path, &file_stat) == 0) {
		/* Everything is OK this time - have valid data. */
		byte_size = file_stat.st_size;
		last_mod_time = file_stat.st_mtime;
	    }  /* if */
	}  /* if */
    }  /* if */
    /* If compiling preprocessed source, check if this source file has been
       modified since the .i file was created. */
    if (   preprocessed_input
	&& dot_i_time_stamp < last_mod_time) {
	/* This source file has been modified since the preprocessing has
	   been done.  The stat() information is meaningless. */
	byte_size = 0;
	last_mod_time = 0;		/* This could be set to the .i time
					   as the last known valid time. */
    }  /* if */
    src_ptr->byte_size = byte_size;
    src_ptr->last_mod_time = last_mod_time;

    /* Break the pathname down into the largest directory name
       contained in the directory table and the base file name. */
    strcpy(dir_path, name);
    limit = DB_INCDIR_USED;		/* Establish the upper limit of the
					   include directory table (array). */
    for (;;) {
	inc_index = 0;			/* set the default include directory
					   index as the "working directory"
					   for all special cases encountered
					   before any search. */
	filename = strrchr(dir_path, '/');
	/* put previous '/' back */
	if (null_spot) *null_spot = '/';
	if (! filename) {
	    /* No remaining '/' found in the path.  File must be
	       releative to the current working directory. */
	    filename = dir_path;
	    goto complete_source;
	}  else {
	    /* Have located the next '/' from the rear. */
	    null_spot = filename;
	    *(filename++) = '\0';    /* terminate the directory name. */

	    /* Check for reference to the current working directory. */
	    if (   (strlen(dir_path) == 1)
		&& (dir_path[0] == '.')) {
		/* This is a file name beginning with "./". */
		goto complete_source;
	    }  /* if */
	    if (null_spot == dir_path) {
		/* have an absolute path name beginning with a '/' and
		   have not matched with an incude directory pathname
		   that begins with a '/'.  Mark this as an absolute
		   filename in the current working directory. */
		*null_spot = '/';
		filename = dir_path;
		goto complete_source;
	    }  /* if */
	}  /* if */

	for (inc_index = 0; inc_index < limit; inc_index++) {
	    if (strcmp(dir_path, DB_INCDIR_NAME(inc_index)) == 0 ) {
		/* Found a match.  Go to complete_source. */
		goto complete_source;
	    }  /* if */
	}  /* for */
    }  /* for */

complete_source:
    src_ptr->filename = st_lookup(filename);
    src_ptr->dir_index = inc_index;
    DB_INCDIR_REFD(inc_index) = 1;
}  /* db_add_src_file_to_table */


int
db_reg_file(name)
char * name;
/* Enter the source file name specified by the string "s" into the
   source file stack.  The first source file entered should be the
   primary source file. */
{
    int index, limit;
    db_srcfile *src_ptr;
    char dir_path[MAXPATHLEN+1];
    char * null_spot = 0;
    char * filename = 0;
    struct stat file_stat;

    if (db_linelevel == DB_LEVEL2) {
	if (name) {
	    for (index = 0, limit = DB_SRCFILE_USED; index < limit; index++) {
		if (strcmp(name, DB_SRCFILE_PATH(index)) == 0) {
		    /* The file is already in the source file table at
		       the "index" element. */
		    goto return_file_index;
		}  /* if */
	    }  /* for */
	    /* The file is not in the source file table; add it at the
	       next available spot - "index" */
	    db_add_src_file_to_table(name, index);
return_file_index:
	    return DB_SRCFILE_DBINDEX(index);
	}  /* if */
    }  /* if */

    return 0;				/* no debugging to be generated, or
					   no file name. */
}  /* db_reg_file */


static int lang_array[2 *(int)End_lang] =
	{/* Dwarf 1 */ LANG_UNK, LANG_C89, LANG_C_PLUS_PLUS,
	 /* Dwarf 2 */ 0, DW_LANG_C89, DW_LANG_C_plus_plus};


void
db_set_lang(language_type lang)
/* Based on the version of Dwarf being generated and the language being
   compiled (denoted by lang), set the Dwarf language attribute. */
{
  db_language = lang_array[(IS_DWARF_1() ? 0 : (int)End_lang) + (int)lang];
}


void
db_e_file()
/* Do what needs to be done for debug information at the end of the
   primary source file. */
{
    if (db_symlevel == DB_LEVEL0)
	return;

    db_begfile();			/* be sure we've started debugging */

    /* Finish off file entry.  Its sibling label marks end of .debug
    ** for this file.
    */
    db_pop();				/* ties off sibling of current block */

    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	/* Force out dummy entry to align to 4-byte boundary.  This is a hack
	** to cope with assemblers that insist on aligning everything, whether
	** asked to or not.
	*/
	{
	    int lab = DB_GENLAB();
	    dwarf_out("Sd.d\tW\tLD-Ld\n\ts\t4\n.DSp",
		   lab, lab, lab, DB_DOTALIGN, lab);
	}

	dwarf_out("Sd.dSp", DB_CURSIBLING);	/* "theoretical" end of .debug */
    } else {
	/* Dwarf 2 */
	/* Put the label for the end of the .debug_info section.  Align
	** that label to a 4-byte boundary for the Dwarf 1 reasons.
	*/
	dwarf_out("Sd\ts\t4\ns:\tCSp", DB_DOTALIGN, LAB_INFOEND,
	       "Dwarf 2 - .debug_info section end");
    }  /* if */
    cg_setlocctr(PROG);			/* force to .text */
    dwarf_out(".E");			/* end of text label */
    /* Final line number (zero) with end-of-text.  Then lay down end
    ** of line numbers label.
    */
    if (db_linelevel == DB_LEVEL2) {
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    dwarf_out("Sl\tW\t0; H x; W LE-LB\n.eSp", 0xffff);
	} else {
	    /* Dwarf 2 */
	    if (dw2_generate_line_prologue) {
		/* Generate start of line number information if never
		   encountered a function definition. */
		dw2_generate_line_prologue = 0;
		db_dw2_init_line_section();
	    }  /* if */
	    dwarf_out("Sl\tB\tx;\tH\tLE-LnC\tB\tx;\tlu;\tB\txC", DW_LNS_fixed_advance_pc,
		   "DW_LNS_fixed_advance_pc", 0, 1, DW_LNE_end_sequence,
		   "DW_LNE_end_sequence");
	    dwarf_out(".eSp");
	}  /* if */
    }  /* if */
    /* Terminate the .debug_pubnames section header. */
    if (db_name_lookup) {
	dwarf_out("Sn\tB\tx\ns:\tCSp", DB_DW2_END, LAB_NAMEEND,
	       "end of .debug_pubnames section");
    }  /* if */
    if (TD_USED(td_dbstack) != 0)
	cerror("debug stack not zero");
    return;
}  /* db_e_file */



void
db_begf(sid)
SX sid;
/* Do debug stuff at start of function definition. */
{
    T1WORD functype;
    T1WORD rettype;
    int tag;

    if (db_symlevel == DB_LEVEL0)
	return;

    /* This may be the first call for debug info generation.  Make
    ** certain that any setup/initialization associated with db_begfile()
    ** is complete/
    */
    db_begfile();

    functype = SY_TYPE(sid);
    rettype = TY_DECREF(functype);

    /* remember name to put out label */
    db_funcname = SY_NAME(sid);

    db_walktype(rettype);		/* force out lower-level type info */

    /* Always generate a new entry */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
        tag = SY_CLASS(sid) == SC_EXTERN ?
		TAG_global_subroutine : TAG_subroutine;
    } else {
	/* Dwarf 2 */
	tag =  (rettype == TY_VOID) ? dw2_void_subr : dw2_non_void_subr;
    }  /* if */
    db_s_entry(tag);
    db_at_name(db_funcname);
    /* Redo function name to special case '$' as first character. */
    db_funcname = cg_extname(sid);
    if (rettype != TY_VOID || IS_DWARF_1())
	db_at_type(rettype);		/* describe the returned type */
    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	/* Low pc for a function is the same as the function's label. */
	dwarf_out("\tH\tx; W\tsC", AT_low_pc, db_funcname, "AT_low_pc");
	dwarf_out("\tH\tx; W\tLhC", AT_high_pc, DB_CURINFOLAB, "AT_high_pc");
    } else {
	/* Dwarf 2 */
	if (db_linelevel == DB_LEVEL2) {
	    /* Emit the file indx and line number for this function. */
	    db_conv_seq_to_file_line(db_curline);
	    dwarf_out("\tluC\tluC", db_curr_file_index, "DW_AT_decl_file",
		   db_curr_lineno, "DW_AT_decl_line");
	} else {
	    /* Emit zero file index and line number */
	    dwarf_out("\tlu\tluC", 0, 0, "DW_AT_decl_file, DW_AT_decl_line");
	}  /* if */
	dwarf_out("\tB\txC", (TY_HASPROTO(functype) ? 1 : 0), "DW_AT_prototyped");
	dwarf_out("\tB\txC", (SY_CLASS(sid) == SC_EXTERN), "DW_AT_external");
	/* Low pc for a function is the same as the function's label. */
	dwarf_out("\tW\tsC", db_funcname, "DW_AT_low_pc");
	dwarf_out("\tW\tLhC", DB_CURINFOLAB, "DW_AT_high_pc");
    }  /* if */
    db_e_entry();

    if (db_name_lookup) {
	/* Output the .debug_pubnames entry for this function. */
	dwarf_out("Sn\tW\tLdCb\nSp", DB_CURINFOLAB,
	       ".debug pubnames function entry", db_funcname);
    }  /* if */

    SY_FLAGS(sid) |= SY_DBOUT;		/* mark debug information generated */

    /* If debugging is enabled, descend a level to allow for other
    ** symbols within the function, particularly its formals.
    */
    if (db_symlevel == DB_LEVEL2)
	db_push();

    /* If generating Dwarf 2 line number information, it was necessary to
       compile module-at-a-time to be certain that all source file
       names have been seen for the line section prologue.  If this
       is the first function, output the line number prologue. */
    if (   dw2_generate_line_prologue
	&& IS_DWARF_2()
	&& db_linelevel == DB_LEVEL2) {
	/* Setup start of line number information. */
	dw2_generate_line_prologue = 0;
	db_dw2_init_line_section();
    }  /* if */
    return;
}  /* db_begf */


void
db_s_fcode()
/* Output debug information after function prologue, before real
** function code if no debug information has been issued for this 
** line yet.
*/
{
#ifdef DBLINE
    db_func_start = 1;
#endif
    if (   db_linelevel == DB_LEVEL2
        && db_curline != db_lastlineno) {
	/* Convert the sequence number contained in db_curline to the file
	   index number and the line number within the file. */
	db_conv_seq_to_file_line(db_curline);

	cg_setlocctr(PROG);		/* put line number labels in .text */
	if (IS_DWARF_1()) {
	    /* Dwarf 1 - Output:
	    ** <LAB_FUNCNO><line>:
	    **	.section .line
	    **	.uaword <line> 
	    **	.uahalf 0xffff
	    **	.uaword <label>-..text.begin
	    **
	    ** where label is the function name.
	    */
	    dwarf_out(".f");
	    dwarf_out("Sl\tW\td; H x; W s-LB\nSp", db_curr_lineno, 0xffff,
		   db_funcname);
	} else {
	    /* Dwarf 2 */
	    /* For Dwarf 2, advances in the PC value is made as a delta from
	    ** the last statement point.  This particular statement point
	    ** involves <func_name>-..LN<old> and the next statement point
	    ** would be ..LN<new> - <func_name>.  To simplify this, a new
	    ** line label will be assigned and equated to the function label.
	    **
	    ** Output:
	    **
	    **  .set .L<new>,<func_name>
	    **
	    ** followed by the line program statements necessary to bring
	    ** the "machine" up to date.
	    */
	    /* Get a new line label number assigned, but not defined.
	       Equate the label with the function name. */
	    dwarf_out(".N\ts\tLn,sC", DB_DOTSET, db_funcname,
		   "equate line label with function");
	    db_dw2_upd_statement_prog();
	}  /* if */
	db_lastlineno = db_curline;
    }  /* if */
    return;
}  /* db_s_fcode */


void
db_e_fcode()
/* Generate debug output at end of function, before function epilogue. */
{
    db_lineno();			/* put out line number for epilogue */
    return;
}  /* db_e_fcode */


void
db_endf()
/* Generate debug output at end of entire function definition. */
{
    switch (db_symlevel){
    case DB_LEVEL2:
	db_pop();			/* unwind from push in db_begf() */
	/*FALLTHRU*/
    case DB_LEVEL1:
	cg_setlocctr(PROG);
	dwarf_out(".h");			/* Generate high pc label in text */
	/*FALLTHRU*/
    case DB_LEVEL0:
	break;
    }
    return;
}  /* db_endf */



static void
dwarf_outblock()
/* Generate code to represent a new lexical block. */
{
    int tag;

    if (IS_DWARF_1()) {
	/* Dwarf 1 */
	tag = TAG_lexical_block;
    } else {
	/* Dwarf 2 */
	tag = dw2_lexical_block;
    }  /* if */
    db_s_entry(tag);
    db_at_pc();
    db_e_entry();
    cg_setlocctr(PROG);			/* force a label in .text */
    dwarf_out(".l");			/* low pc */
    db_push();				/* things in the block owned by this
				        ** entry
					*/
    BBFLAG = 1;				/* have output entry at this level */
    return;
}  /* dwarf_outblock */

void
db_s_block()
/* Starting a new block.  Make sure there is enough space in the
** block begin flags.
*/
{
    if (db_symlevel == DB_LEVEL2) {
#ifdef DBLINE
	if (db_func_start) {
	    db_func_start = 0;
	    cgsync();
	    db_state = DB_INIT;
	}
	else
	    db_state = DB_START;
#endif

	if (++bblevel >= td_bbflags.td_allo) {
	    TD_NEED1(td_bbflags);
	    TD_CHKMAX(td_bbflags);
	}
	BBFLAG = 0;			/* zero flag at current level */
    }  /* if */
    return;
}  /* db_s_block */

void
db_e_block()
/* Exiting a block.  Output high pc label if we've done a lexical
** block entry for this block.  Drop the current block level.
*/
{
#ifdef DBLINE
    db_state = DB_INIT;
#endif

    if (db_symlevel == DB_LEVEL2) {
	if (BBFLAG) {
	    db_pop();
	    cg_setlocctr(PROG);		/* force label in text */
	    dwarf_out(".h");		/* high pc */
	}  /* if */
	/* Check that the basic block index does not go below that
	   artifical "block" created for file scope. */
	if (--bblevel < (db_begfile_seen ? 1 : 0))
	    cerror("db_e_block():  confused block level");
    }  /* if */
    return;
}  /* db_e_block */

void
db_symbol(sid)
SX sid;
/* Produce debug information for sid, conditional on global flag. */
{
    SY_CLASS_t class = SY_CLASS(sid);
#ifdef DBLINE
    if (db_state == DB_START) {
	/* don't sync for label defs and externs */
	if (!(SY_FLAGS(sid) & SY_LABEL) && class != SC_EXTERN) {
		db_state = DB_INIT;
		cgsync();
        }
    }
#endif
    if (db_symlevel != DB_LEVEL2 || (SY_FLAGS(sid) & SY_DBOUT))
	return;
	
    /* No debugging for asm functions. */
    if (class == SC_ASM)
	return;
    /* ... or if the symbol is external and is neither defined nor
    ** tentatively defined.
    */
    if (class == SC_EXTERN && (SY_FLAGS(sid) & (SY_DEFINED|SY_TENTATIVE)) == 0)
	return;

    db_ucsymbol(sid);
    SY_FLAGS(sid) |= SY_DBOUT;
    return;
}  /* db_symbol */


static void
db_ucsymbol(sid)
SX sid;
/* Do unconditional symbol output for the symbol whose table
** entry is sid.
*/
{
    int tag;
    int external = 0;
    SY_CLASS_t class = SY_CLASS(sid);

    /* This may be the first call for debug info generation.  Make
    ** certain that any setup/initialization associated with db_begfile()
    ** is complete/
    */
    db_begfile();

    switch( class ){
    case SC_AUTO:
	tag = IS_DWARF_1() ? TAG_local_variable : dw2_variable_no_decl;
	break;
    case SC_PARAM:
    {
	char * s = SY_NAME(sid);

	/* Assume normal parameter, check for "...". */
	tag = IS_DWARF_1() ? TAG_formal_parameter : dw2_formal_param;
	if (s[0] == '.' && s[1] == '.' && s[2] == '.' && s[3] == 0) {
	    if (IS_DWARF_1()) {
		/* Dwarf 1 */
		tag = TAG_unspecified_parameters;
	    } else {
		/* Dwarf 2  - simply make an unspecified parameter reference */
		db_s_entry(dw2_unspecified_params);
		db_e_entry();
		return;
	    }  /* if */
	}  /* if */
	break;
    }
    case SC_TYPEDEF:
	tag = IS_DWARF_1() ? TAG_typedef : dw2_typedef;
	break;
    case SC_EXTERN:
	external++;
	/* FALLTHRU */
    case SC_STATIC:
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    tag = (class == SC_EXTERN) ? TAG_global_variable
				       : TAG_local_variable;
	} else {
	    tag = ((db_linelevel == DB_LEVEL2) ? dw2_variable
						: dw2_variable_no_decl);
	}  /* if */
	break;
    case SC_LABEL:
	tag = IS_DWARF_1() ? TAG_label : dw2_label;
	break;
    default:
	cerror("db_ucsymbol():  bad class");
    }

    /* Force out a lexical block debug entry for first declaration in a
    ** nested block, not including user-defined labels.
    */
    if (   BBFLAG == 0
	&& SY_LEVEL(sid) > SL_INFUNC
	&& tag != (IS_DWARF_1() ? TAG_label : dw2_label)) {
       dwarf_outblock();			/* force out code */
     }  /* if */
    db_walktype(SY_TYPE(sid));		/* walk type structure */
    /* Start new entry. */
    db_s_entry(tag);
    db_at_name(SY_NAME(sid));

    /* Do location descriptors. */
    switch (class) {
    case SC_EXTERN:
    case SC_STATIC:
    {
	db_at_type(SY_TYPE(sid));
	if IS_DWARF_1() {
	    /* Dwarf 1 */
	    dwarf_out("\tH\txC", AT_location, "AT_location");
	    dwarf_out("\tH\td; B x; W sC", 1+4, OP_ADDR, cg_extname(sid),
		   "OP_ADDR");
	}  else {
	    /* Dwarf 2 */
	    if (db_linelevel == DB_LEVEL2) {
		/* Emit the file indx and line number for this function. */
		db_conv_seq_to_file_line(SY_LINENO(sid));
		dwarf_out("\tluC\tluC", db_curr_file_index, "DW_AT_decl_file",
		       db_curr_lineno, "DW_AT_decl_line");
	    }  /* if */
	    dwarf_out("\tB\txC", external, "DW_AT_external");
	    dw2_out_loc_desc("DW_AT_location",
				DW_FORM_block1,  /* should hold it  */
				DW_OP_addr, cg_extname(sid), DB_DW2_END);
	    
	}  /* if */
	break;
    }
    case SC_AUTO:
    case SC_PARAM:
    {
	int regno, basereg;
	int offset;

	if (SY_REGNO(sid) == SY_NOREG) {
	    basereg = class == SC_AUTO ? DB_FRAMEPTR : DB_ARGPTR;
	    offset = class == SC_AUTO ? SY_OFFSET(sid) : PARM_OFFSET(SY_OFFSET(sid));
	} else {
	    regno = DB_OUTREGNO(SY_REGNO(sid));
	}  /* if */
	db_at_type(SY_TYPE(sid));
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    dwarf_out("\tH\txC", AT_location, "AT_location");
	    if (SY_REGNO(sid) == SY_NOREG) {
		dwarf_out("\tH\td; B x; W d; B x; W ds; B xC",
		    1+4+1+4+1, OP_BASEREG, basereg, OP_CONST, offset,
#ifdef FIXED_FRAME
		    (fixed_frame() ? PLUS_FRAME_OFFSET_STRING : ""),
#else
		    "",
#endif
		    OP_ADD,
		    "OP_BASEREG OP_CONST OP_ADD"
		  );
	    } else {
		T1WORD t = TY_UNQUAL(SY_TYPE(sid));
		if (t == TY_LLONG || t == TY_ULLONG || t == TY_SLLONG)
		    dwarf_out("\tH\td; B x; W d,dC",
			1+4+4, OP_SCO_REG_PAIR, regno, regno+1, "OP_SCO_REG_PAIR");
		else
		    dwarf_out("\tH\td; B x; W dC",
			1+4, OP_REG, regno, "OP_REG");
	    }
	} else {
	    /* Dwarf 2 */
	    if (class == SC_AUTO) {
		dwarf_out("\tB\txC", 0 /* not external */, "DW_AT_external");
	    }  /* if */
	    if (SY_REGNO(sid) == SY_NOREG) {
#ifdef FIXED_FRAME
	      if (fixed_frame())
		dw2_out_loc_desc("DW_AT_location", DW_FORM_block1,
				    DW_OP_breg0 + basereg, offset,
				    DW_OP_consts_as_string,
				    PLUS_FRAME_OFFSET_STRING,
				    DB_DW2_END);
	      else
#endif
		dw2_out_loc_desc("DW_AT_location", DW_FORM_block1,
				    DW_OP_breg0 + basereg, offset,
				    DB_DW2_END);
	    } else {
		T1WORD t = TY_UNQUAL(SY_TYPE(sid));
		if (t == TY_LLONG || t == TY_ULLONG || t == TY_SLLONG)
			dw2_out_loc_desc("DW_AT_location", DW_FORM_block1,
				DW_OP_SCO_reg_pair, regno, regno+1, DB_DW2_END);
		/* The following check may be overly cautious! */
		else if (regno >= (DW_OP_reg31 - DW_OP_reg0))
		    dw2_out_loc_desc("DW_AT_location", DW_FORM_block1,
					DW_OP_regx, regno, DB_DW2_END);
		else
		    dw2_out_loc_desc("DW_AT_location", DW_FORM_block1,
					DW_OP_reg0 + regno, DB_DW2_END);
	    }  /* if */
	}  /* if */
	break;
    }
    case SC_LABEL:
	/* low_pc attribute refers to location in .text, which is
	** label number in SY_OFFSET.
	*/
	if (IS_DWARF_1()) {
	    /* Dwarf 1 */
	    dwarf_out("\tH\tx; W LLC", AT_low_pc, SY_OFFSET(sid), "AT_low_pc");
	} else {
	    /* Dwarf2 */
	    dwarf_out("\tW\tLLC", SY_OFFSET(sid), "DW_AT_low_pc");

	}  /* if */
	break;
    case SC_TYPEDEF:
	/* Need type attribute. */
	db_at_type(SY_TYPE(sid));
	break;
    }
    db_e_entry();

    if (   db_name_lookup
	&& class == SC_EXTERN) {
	/* Output the .debug_pubnames entry for this variable. */
	dwarf_out("Sn\tW\tLdCb\nSp", DB_CURINFOLAB,
	       ".debug pubnames variable entry", SY_NAME(sid));
    }  /* if */

    return;
}  /* db_ucsymbol */


void
db_lineno()
/* Output the current line, relative to the beginning of the
** current function.
*/
{
    if (   db_linelevel == DB_LEVEL2
	&& db_curline != db_lastlineno
	&& db_curline != 0     /* Some C++ IL-lowered code introduced
				  without a sequence number - NOT
				  a true line number change. */ 
				) {

	db_uclineno(db_curline);
	db_lastlineno = db_curline;
    }
    return;
}  /* db_lineno */


static void
db_dw2_make_special_opcode(int line_delta, int addr_incr)
/*
** Either generate a special opcode to adjust the line number register
** and append a row of register value to the statem,ent matrix, or generate
** separate instructions to do that.
*/
{
    char comment[128];

    dw2_line_number += line_delta;
    sprintf(comment, "special_opcode(%d, %d): line # %d", line_delta,
	    addr_incr, dw2_line_number);
    if (   (line_delta >= dw2_line_base)
	&& (line_delta < (dw2_line_base + dw2_line_range))) {
	/* Construct a special opcode based on the formula:
	**
	** opcode = (line_delta - line_base) +
	**	    (line_range * addr_incr) + opcode_base
	*/
	int opcode = (line_delta - dw2_line_base) +
			(dw2_line_range * addr_incr) + dw2_opcode_base;
	dwarf_out("\tB\txC", opcode, comment);
    } else {
	/* Need to generate separate instructions
	**
	** Output:
	**    DW_LNS_advance_line LEB128<line_delta>
	**    DW_LNS_copy
	*/
	dwarf_out("\tB\tx;\tlsC\tB\txC", DW_LNS_advance_line, line_delta, comment,
	       DW_LNS_copy, "DW_LNS_copy");
    }  /* if */
}  /* db_dw2_make_special_opcode */


static void
db_conv_seq_to_file_line(seq_no)
int seq_no;
/*
** Convert the sequence number to a file index and line number within
** that file.  The results are stored in the static variables 
** "db_curr_file_index" and "db_curr_line", respectively. 
*/
{
    conv_seq_to_line_and_file_index(seq_no, &db_curr_lineno,
				    &db_curr_file_index);
}  /* db_conv_seq_to_file_line */


static void
db_dw2_upd_statement_prog()
/*
** Dwarf 2 - Generate the line statement program instructions to bring
**           the state machine up to date.
*/
{
    char prev_label[32];
    int line_delta;

    line_delta = db_curr_lineno - dw2_line_number;

    dwarf_out("Sl");
    /* Check for a change in file name and update if necessary. */
    if (dw2_file_index != db_curr_file_index) {
	/* Have hit a source file change. */
	dw2_file_index = db_curr_file_index;
	dwarf_out("\tB\tx;\tluC", DW_LNS_set_file, db_curr_file_index,
	       "DW_LNS_Set_file");
    }  /* if */

    /* Since the actual value of the address increment is not really known,
       use a "DW_LNS_fixed_advance_pc" instruction to advance the PC. */
    sprintf(prev_label, LAB_LINENO, dw2_prev_line_label);
    dwarf_out("\tB\tx;\tH\tLn-sC", DW_LNS_fixed_advance_pc, prev_label,
	   "DW_LNS_fixed_advance_pc");
    /* Now update the line number with a remaining addr increment of zero. */
    db_dw2_make_special_opcode(line_delta, 0 /* address increment */ );
    dwarf_out("Sp");
}  /* db_dw2_upd_statement_prog */


static void
db_uclineno(ln)
int ln;
/* Unconditional output line number ln. */
{
    /* Convert the sequence number contained in "ln" to the file
       index number and the line number within the file. */
    db_conv_seq_to_file_line(ln);

    cg_setlocctr(PROG);			/* put line number labels in .text */
    dwarf_out(".n");
    if (IS_DWARF_2()) {
	/* Dwarf 2 - Output */
	db_dw2_upd_statement_prog();
    }  else {
	/* Dwarf 1 - Output:
	**	label
	**	.section .line
	**	.uaword <line number>
	**	.uahalf 0xffff
	**	.uaword <label>-..text.begin
	*/
	dwarf_out("Sl\tW\td; H x; W Ln-LB\nSp", db_curr_lineno, 0xffff);
    }  /* if */
    return;
}  /* db_uclineno */


void
db_sue(t)
T1WORD t;
/* Output member information for s/u/e t after doing so for all
** recursively referenced s/u/e's.
*/
{
    int tagno;
    unsigned int mbrno;
    SX tagsid;
    SX mbr;
    int type_T_has_list;
    char *tag_name;
    T1WORD basic_type = TY_TYPE(t);

    /* This may be the first call for debug info generation.  Make
    ** certain that any setup/initialization associated with db_begfile()
    ** is complete/
    */
    db_begfile();

    /* Suppress output if no members in list, or if full debugging
    ** output is disabled.
    */
    if (db_symlevel != DB_LEVEL2)
	return;
    if ( ! TY_HASLIST(t) && ! db_force_incomplete_type) {
	/* Mark the debugging scope level that this tag was seen.  Use 
	   db_walk_type(). */
	(void) db_walktype(t);
	return;
    }  /* if */

    tagsid = TY_SUETAG(t);		/* get symbol ID for tag */

    /* Force out a lexical block debug entry for first declaration in a
    ** nested block.
    */
    if (   BBFLAG == 0
	&& SY_LEVEL(tagsid) > SL_INFUNC) {
	dwarf_outblock();	/* force out code */
    }  /* if */

    /* Mark type as having been output.  We'll be doing so shortly.
    ** This takes care of potential recursion in the structure.
    */
    DB_TY_SETOUT(t);

    SY_FLAGS(tagsid) |= SY_DBOUT;	/* debugging will have been produced */

    /* Walk the type of each member. */
    if (type_T_has_list = TY_HASLIST(t)) {
	for (mbrno = 0; (mbr = TY_G_MBR(t,mbrno)) != SY_NOSYM; ++mbrno)
	    db_walktype(SY_TYPE(mbr));
    }  /* if */

    /* Begin entry. */
    if (IS_DWARF_1()) {
	switch(basic_type){
	case TY_STRUCT:	tagno = TAG_structure_type; break;
	case TY_UNION:	tagno = TAG_union_type; break;
	case TY_ENUM:	tagno = TAG_enumeration_type; break;
	}
    } else {
	if (! TY_HASLIST(t)) {
	    switch(basic_type){
	    case TY_STRUCT:	tagno = dw2_incomplete_struct; break;
	    case TY_UNION:	tagno = dw2_incomplete_union; break;
	    case TY_ENUM:	tagno = dw2_incomplete_enumeration; break;
	    }  /* switch */
	} else {
	    switch(basic_type){
	    case TY_STRUCT:	tagno = dw2_struct; break;
	    case TY_UNION:	tagno = dw2_union; break;
	    case TY_ENUM:	tagno = dw2_enumeration; break;
	    }  /* switch */
	}  /* if */
    }  /* if */
    db_s_entry(tagno);
    dwarf_out("=", (unsigned int)TY_MAPID(t));
    tag_name = SY_NAME(tagsid);
    if (   IS_DWARF_2() 
	&& tag_name[0] == DCL_ILL_ID_CHAR) {
	/* This is a ".nnnfake" tag name invented by decl.c.  This should
	   be represented as an empty string in Dwarf 2. */
	tag_name = "";
    }  /* if */
    db_at_name(tag_name);
    if (type_T_has_list) {
	db_at_byte_size(TY_SIZE(t));
    }  /* if */
    if (IS_DWARF_2() && ! type_T_has_list) {
	/* generate an AT_declaration. */
	dwarf_out("\tB\txC", 1, "DW_AT_declaration");
    }  /* if */
    if (  (tagno == TAG_enumeration_type) && IS_DWARF_1()) {
	/* Dwarf 1 - enumerators are an attribute of the enumeration type. */
	if (type_T_has_list) {
	    db_at_element_list(t);
	}  /* if */
	db_e_entry();
	return;				/* no need to push an empty scope. */
    }  /* if */
    db_e_entry();
    if (type_T_has_list) {
	db_push();			/* new level for members */
	/* Output stuff for each s/u member. */
	if (basic_type != TY_ENUM) {
	    for (mbrno = 0; (mbr = TY_G_MBR(t,mbrno)) != SY_NOSYM; ++mbrno)
		dwarf_outmember(mbr);
	} else if (IS_DWARF_2()) {
	    /* Dwarf 2 - emit enumerators. */
	    db_dw2_outenum(t);
	}  /* if */
	db_pop();
    }  /* if */
    return;
}  /* db_sue */

void
db_sy_clear(sid)
SX sid;
/* Output debug information for symbol table entries that are being
** flushed.  This is the way we pick up s/u/e tags for which no
** information has been generated.
*/
{
#ifdef DBLINE
    if (db_state != DB_CLEAR)

	/* don't want to sync if only clears in block are for function defs,
	   or extern defs.
	*/
	if (!TY_ISFTN(SY_TYPE(sid)) && SY_CLASS(sid) != SC_EXTERN) {
		cgsync();
		db_state = DB_CLEAR;
	}
#endif

    return;
}  /* db_sy_clear */

/* unused in acomp - needed in cplusbe for inlining */
void
db_s_inline(sid)
SX sid;
{
} /* db_s_inline */

void
db_s_inline_expr(sid)
SX sid;
{
} /* db_s_inline_expr */

void
db_e_inline()
{
} /* db_e_inline */

#endif /* ndef LINT */

