/*
 *	ident @(#) mfck.c 11.1 97/10/30 
 */
/****************************************************************************
 *
 *	Copyright (c) 1997 The Santa Cruz Operation, Inc.. 
 *		All Rights Reserved. 
 *
 *	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF 
 *		THE SANTA CRUZ OPERATION INC.
 *	The copyright notice above does not evidence any
 *	actual or intended publication of such source code.
 *
 ****************************************************************************/
/*
 *
 * Modification History
 *
 * M001, 12-Sep-97, andrean
 *	- Fixed prompt() to use nl_langinfo() to obtain yes/no strings
 *	  of current locale.
 *
 * M000, 08-Sep-97, andrean
 *	- I18n for use of message catalog.
 *
 */

/*
 * message store (mailbox) check/repair and conversion program.
 *
 * this program has knowledge of the message store and calls it
 * directly, it does not use c-client.
 *
 * care was taken to support binary data (nulls in the message body)
 */

/* Design documentation
   The folder check and repair stuff is implemented as a tokenizer and an FSM.
   The tokenizer recognizes and tokenizes groups of lines.
   It looks ahead up to four lines and returns type based
   on the lines following.

   The FSM is responsible for distinguishing message headers and bodies.

   From lines are special in that we call the message store routine to
   validate them.

   Legal tokens generated by the tokenizer:

   simple types:
   H - a syntactically valid header line, this one has all continuation
       lines tacked on into one giant buffer (newlines included).
   B - blank line.
   R - regular line that does not match any of our known line types.
   A - a lone ctrl-A line without good things after it.  To be dropped.
   F - a lone valid From line that is not followed by legal header lines.
       will be padded if in header.

   The following are legal Start of Message (SOM) tokens:
   FH - a From line followed by at least one syntactically valid header line.
   AFH - a CTRL-A line followed by a legal From line and a legal header line.
   AAFH - two ctrl-A lines, with a legal From line and a legal header line.

   A, AFH, and AAFH are only generated when an MMDF file is being parsed.

   Legal SOM's mean this is probably the start of a new message.
   They are fixed up to be syntactically legal in MMDF's case (Ctrl-A
   lines are added and deleted as necessary).

   Lone From lines are padded or deleted and lone Ctrl-A lines are deleted.

   Content-Length headers are supported, and they are regenerated
   to reflect the new state of things for messages that did not
   have a valid content-length.

   This program really needs to understand MIME so as not to
   break up MIME messages that have an attachment type message/rfc822.
   Currently it does not do this.

 */
#ifdef INTL
#  include <locale.h>
#  include "mfck_msg.h"
   nl_catd catd;
#else
#  define MSGSTR(num,str)	(str)
#  define catclose(d)		/*void*/
#endif /* INTL */

#include <stdio.h>
#include <sys/param.h>
#include <pwd.h>
#include <time.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <signal.h>
#include <string.h>
#include <fcntl.h>
#include <langinfo.h>
#include <regex.h>
/* these two includes go last */
#include <c-client/mail.h>
#include <c-client/scomsc1.h>

#define uchar unsigned char
#define debug printf

typedef struct tokdef {
	int t_type;	/* type of token */
	int t_len;	/* length of data in string null chars are allowed */
			/* the string is still null terminated */
	uchar *t_str;	/* pointer to malloced token string buffer */
} token_t;

/* token types (they double as FSM inputs) */
#define I_SOM	0	/* valid start of message */
#define I_F	1	/* lone From line */
#define I_H	2	/* header line */
#define I_B	3	/* blank line */
#define I_R	4	/* regular line */
#define I_AE	5	/* ctrl-A at end of file */
#define I_EOF	6	/* end of file */
#define I_COUNT	7	/* FSM input count */
/* FSM inputs stop here, others are tokens that are dropped or converted */
#define I_A	7	/* lone ctrl-A line */
/* valid SOM types, will be converted to I_SOM */
#define I_FH	8	/* From followed by header */
#define I_AFH	9	/* ctrl-a, From, header */
#define I_AAFH	10	/* two ctrl-a, From, header */

/* FSM states */
#define S_START	0	/* start state */
#define S_HDR	1	/* in header state */
#define S_BODY	2	/* in body state */
#define S_COUNT 3	/* count of states */
#define S_DONE	4	/* magic state that terminates the machine */
/* FSM outputs */
#define O_SOM	0	/* start of first message found */
#define O_MK	1	/* start of first message not found, make it */
#define O_EOH	2	/* end of header found */
#define O_EOM	3	/* end of message found */
#define O_EOB	4	/* end of both (end of message while in header) */
#define O_OUTH	5	/* output current token to hdr file */
#define O_OUTB	6	/* output current token to body file */
#define O_PAD	7	/* pad the current From token and output */
#define O_IEOH	8	/* insert end of header (blank line) */
#define O_IEOM	9	/* insert end of message (mmdf only) */
#define O_IEOB	10	/* insert end of both (mmdf only) */
#define O_NULL	11	/* do nothing */
int fsm_state;		/* our current FSM state */

char buf[BUFSIZ+1];	/* input buffer */
char buf1[BUFSIZ+1];	/* another input buffer */

char ifile[MAXPATHLEN];	/* our current input file */
FILE *ifd;		/* file descriptor for in file */
char ofile[MAXPATHLEN];	/* tmp output file */
FILE *ofd;		/* file descriptor for out file */
char hfile[MAXPATHLEN];	/* tmp header file name */
FILE *hfd;		/* file descriptor for header file */
char bfile[MAXPATHLEN];	/* tmp body file name */
FILE *bfd;		/* file descriptor for body file */

int folder_mmdf;	/* file type for input (and output) file */
int lastseek;		/* current token seek position */
int curseek;		/* current seek position of input file */

int lastline;		/* current token line number */
int curline;		/* current line in input file */
int curmsg;		/* msg count */

/*
 * hack for content-length processing
 * we remember valid content length headers as we go, stripping them out
 * of the data stream so the FSM knows nothing about them.
 * the parser does know however and will not return an SOM inside a
 * content-length validated part of the file.  Spurious CTRL-A lines
 * will be stripped even inside content-length areas.
 */
int contentlength;	/* last content-length found */
int contentseek;	/* seek position for valid content-length SOM */
int contentsob;		/* seek position of start of body in input file */

int dochanges;		/* boolean: commit changes made in current file */
int changes;		/* changes made in current file */
int errors;		/* error count in the current file */

#define PROMPT_REGULAR	0
#define PROMPT_YES	1
#define PROMPT_NO	2
int opt_prompt;		/* 0 - regular prompts, 1 - yes, 2 - no */
#define CONV_MMDF	1
#define CONV_SENDMAIL	2
int opt_conv;		/* convert option */

/* parse types, groups of lines are checked */
/* good start of message (SOM) sequence */
#define PARSE_AAFH	0	/* ctrl-A, ctrl-A, From, header */
/* valid but need to be fixed start of message sequences */
#define PARSE_AFH	1	/* ctrl-A, From, header */
#define PARSE_FH	2	/* From, header */
/* invalid sequences that need the ctrl-A lines dropped */
#define PARSE_AAFX	3	/* ctrl-A, Ctrl-A, From, not header */
#define PARSE_AAX	4	/* ctrl-A, Ctrl-A, Not from */
#define PARSE_AX	5	/* ctrl-A, not From */

void mfconv(char *);
void mfck(char *);
token_t *parse_token();
token_t *token_reduce(token_t *);
int folder_fsm(token_t *);
int sendmail_check();
int folder_type();
void usage();
void main(int, char **);
void die(int);
void cleanup();
int isheader(char *);
int prompt(int, char *, int);
uchar *mmalloc(int);
uchar *mrealloc(void *, int);
void tokfree(token_t *);
char *makefrom();
void do_eom();
int isint(uchar *);
void setsig();
void clrsig();
void sigc();

/*
 * convert a mail folder from one format to another
 * call message store to do the work.
 */
void
mfconv(char *file)
{
	void *handle;
	int type;

	/* this is kludgy */
	strcpy(ifile, file);
	msc1_init(0);
	type = folder_type();
	if (type == -1)
		exit(1);
	if (opt_conv == CONV_MMDF)
		printf(MSGSTR(SCO_MFCK_MSG_CONV_MMDF, 
			"Convert to MMDF format.\n"));
	else
		printf(MSGSTR(SCO_MFCK_MSG_CONV_SENDMAIL, 
			"Convert to Sendmail format.\n"));
	/* any conversion necessary? */
	if (((type == 0) && (opt_conv == CONV_SENDMAIL)) ||
		((type == 1) && (opt_conv == CONV_MMDF))) {
		printf(MSGSTR(SCO_MFCK_MSG_NO_CONV, 
			"No conversion necessary.\n"));
		return;
	}
	conf_mmdf = (opt_conv == CONV_MMDF) ? 1 : 0;
	handle = scomsc1_open(file, ACCESS_SE, 1);
	if (handle == 0) {
		printf(MSGSTR(SCO_MFCK_ERR_CANT_OPEN_MAILBOX,
			"Conversion failed, unable to open mailbox.\n"));
		exit(1);
	}
	if (handle == (void *)1) {
		printf(MSGSTR(SCO_MFCK_ERR_INVALID_MAILBOX,
			"Conversion failed, invalid mailbox format.\n"));
		exit(1);
	}
	if (handle == (void *)2) {
		printf(MSGSTR(SCO_MFCK_ERR_LOCKED_MAILBOX,
			"Conversion failed, mailbox is locked.\n"));
		exit(1);
	}
	scomsc1_close(handle);
	printf(MSGSTR(SCO_MFCK_MSG_CONV_SUCCESS, "Conversion successful.\n"));
	fflush(stdout);
}

/*
 * check and repair a folder
 * the folder is rebuilt in parallel and is copied back at the end
 */
void
mfck(char *file)
{
	int pid;
	char *cp;
	int ret;
	int buflen;

	/* set up pathnames */
	strcpy(ifile, file);
	strcpy(ofile, file);
	cp = strrchr(ofile, '/');
	if (cp)
		*cp = 0;
	else
		strcpy(ofile, ".");
	strcpy(hfile, ofile);
	strcpy(bfile, ofile);
	pid = getpid();
	sprintf(ofile + strlen(ofile), "/mfck.%d", pid);
	sprintf(hfile + strlen(hfile), "/hdr.%d", pid);
	sprintf(bfile + strlen(bfile), "/bdy.%d", pid);

	dochanges = 0;
	changes = 0;
	errors = 0;
	setsig();

	/* and open ifile and check it's type */
	folder_mmdf = folder_type();
	if (folder_mmdf == -1)
		die(1);
	ofd = fopen(ofile, "w+");
	if (ofd == 0) {
		printf(MSGSTR(SCO_MFCK_ERR_CREATE,
			"Unable to create %s\n"), ofile);
		fclose(ifd);
		ifd = 0;
		die(1);
	}

	dochanges = folder_check();

	if (dochanges) {
		ftruncate(fileno(ifd), 0);
		while ((buflen = read(fileno(ofd), buf, BUFSIZ)) > 0)
			write(fileno(ifd), buf, buflen);
	}
	fclose(ofd);
	fclose(ifd);
	printf(MSGSTR(SCO_MFCK_MSG_DETECTED, 
		"%d messages detected.\n"), curmsg);
	printf(MSGSTR(SCO_MFCK_MSG_ERRORS,
		"%d errors were found.\n"), errors);
	printf(MSGSTR(SCO_MFCK_MSG_FIXED,
		"%d fixes were made.\n"), dochanges ? changes : 0);
	fflush(stdout);
	clrsig();
	cleanup();
}

/*
 * folder check, upper level FSM.
 * returns	0 if no changes
 *		1 if changes were made and user commits
 *		0 if changes were made and user doesn't want to commit
 */
int
folder_check()
{
	token_t *token;
	int ret;

	/* our grand loop for this file */
	curline = 1;
	curseek = 0;
	fsm_state = S_START;
	for (;;) {
		token = parse_token();
		token = token_reduce(token);
		if (token)
			folder_fsm(token);
		tokfree(token);
		if (fsm_state == S_DONE)
			break;
	}
	fflush(ofd);
	rewind(ifd);
	rewind(ofd);
	ret = 1;
	if (changes)
		ret = prompt(0, MSGSTR(SCO_MFCK_MSG_COMMIT, "Commit Changes?"), 0);
	else
		ret = 0;
	return(ret);
}

/*
 * tokenizer for input file
 * all lines in the token are concatenated in the string and returned.
 * tokens ending in a header line do not have the header line appended.
 * this is so the header line will be processed later, this is only important
 * for content-length headers but it doesn't hurt the others.
 */
token_t *
parse_token()
{
	register token_t *token;
	register uchar *cp;
	int len;
	int len1;
	int buflen;

	token = (token_t *)mmalloc(sizeof(token_t));
	token->t_str = mmalloc(1);
	token->t_str[0] = 0;
	/* loop is to skip content lines, only one line is really fetched */
	while (1) {
		fseek(ifd, curseek, SEEK_SET);
		if ((buflen = msc1_fgets(buf, BUFSIZ, ifd)) == 0) {
			token->t_type = I_EOF;
			return(token);
		}
		/* content-length check */
		if (fsm_state == S_BODY)
			break;
		if (msc1_strhccmp("Content-Length", buf, ':'))
			break;
		cp = (uchar *)strchr(buf, ':') + 1;
		while ((*cp == ' ') || (*cp == '\t'))
			cp++;
		/* drop content-length lines, prompted later to put back */
		if (isint(cp))
			contentlength = atoi((char *)cp);
		curseek += buflen;
		curline++;
		continue;
	}
	len = buflen;
	lastline = curline;
	lastseek = curseek;
	curseek += len;
	curline++;
	token->t_str = mrealloc(token->t_str, len + 1);
	memcpy(token->t_str, buf, buflen + 1);
	token->t_len = buflen;
	if (strcmp(buf, "\n") == 0) {
		token->t_type = I_B;
	}
	else if (sendmail_parse_from(buf, 0, 0, 0)) {
		/* look ahead by one, only care about headers */
		buf[0] = 0;
		fgets(buf, BUFSIZ, ifd);
		if (isheader(buf))
			token->t_type = I_FH;
		else
			token->t_type = I_F;
		/* treat as lone from if in a valid content-length sequences */
		if (lastseek < contentseek)
			token->t_type = I_F;
	}
	else if (isheader(buf)) {
		token->t_type = I_H;
		/* check for continuation lines */
		while (buflen = msc1_fgets(buf, BUFSIZ, ifd)) {
			if ((buf[0] != ' ') && (buf[0] != '\t'))
				break;
			len1 = buflen;
			token->t_str = mrealloc(token->t_str,
				token->t_len + len1 + 1);
			memcpy(token->t_str + token->t_len, buf, len1 + 1);
			token->t_len += len1;
			curseek += len1;
			curline++;
		}
	}
	else if ((folder_mmdf == 0) || strcmp(buf, MMDFSTR)) {
		token->t_type = I_R;
	}
	else {
		/* have ctrl-A */
		token->t_type = I_A;
		/* drop it if in a valid content-length sequences */
		if (lastseek < contentseek)
			return(token);
		if ((buflen = msc1_fgets(buf, BUFSIZ, ifd)) == 0) {
			token->t_type = I_AE;
		}
		else if (sendmail_parse_from(buf, 0, 0, 0)) {
			len1 = buflen;
			/* must be followed by header to be valid */
			if ((buflen = msc1_fgets(buf1, BUFSIZ, ifd)) == 0)
				return(token);
			if (isheader(buf1) == 0)
				return(token);
			/* build new token */
			token->t_str = mrealloc(token->t_str, len + len1 + 1);
			memcpy(token->t_str + len, buf, len1 + 1);
			token->t_type = I_AFH;
			token->t_len += len1;
			curseek += len1;
			curline++;
		}
		else if (strcmp(buf, MMDFSTR) == 0) {
			/* have two ctrl-a's, look for From and header */
			if ((buflen = msc1_fgets(buf, BUFSIZ, ifd)) == 0)
				return(token);
			len1 = buflen;
			if (sendmail_parse_from(buf, 0, 0, 0) == 0)
				return(token);
			if (fgets(buf1, BUFSIZ, ifd) == 0)
				return(token);
			if (isheader(buf1) == 0)
				return(token);
			/* build new token */
			token->t_str = mrealloc(token->t_str,
				len1 + MMDFSIZ + MMDFSIZ + 1);
			memcpy(token->t_str + MMDFSIZ, MMDFSTR, MMDFSIZ);
			memcpy(token->t_str + MMDFSIZ + MMDFSIZ, buf, len1 + 1);
			token->t_type = I_AAFH;
			token->t_len += len1 + MMDFSIZ;
			curseek += len1 + MMDFSIZ;
			curline += 2;
		}
	}
	return(token);
}

/*
 * reduce tokens, correct errors.
 */
token_t *
token_reduce(register token_t *token)
{
	int ret;
	int size;
	int len;
	uchar *str;

	/* sendmail tokens */
	if (folder_mmdf == 0) {
		if (token->t_type == I_FH)
			token->t_type = I_SOM;
		return(token);
	}
	/* mmdf tokens */
	switch (token->t_type) {
	case I_A:
		/* drop lone ctrl-A lines */
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_UNEXPECTED_CTRLA,
			"Unexpected Ctrl-A delimiter, remove it?"), 1);
		if (ret) {
			tokfree(token);
			return(0);
		}
		/* convert to regular line to keep it */
		token->t_type = I_R;
		break;
	case I_FH:
		token->t_type = I_SOM;
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_FROM,
			"Start of message (From) without Ctrl-A delimiters.  Fix?"), 1);
		if (ret) {
			size = token->t_len + (MMDFSIZ*2) + 1;
			str = mmalloc(size);
			memcpy(str, MMDFSTR, MMDFSIZ);
			len = MMDFSIZ;
			/* only one CTRL-A line if beginning of file */
			if (lastseek) {
				memcpy(str + len, MMDFSTR, MMDFSIZ);
				len += MMDFSIZ;
			}
			memcpy(str + len, token->t_str, token->t_len + 1);
			len += token->t_len;
			free(token->t_str);
			token->t_str = str;
			token->t_len = len;
		}
		break;
	case I_AFH:
		/* only ok if beginning of file */
		token->t_type = I_SOM;
		if (lastseek == 0)
			return(token);
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_MISSING_CTRLA,
			"Ctrl-A delimiter missing, restore it?"), 1);
		if (ret) {
			size = token->t_len + MMDFSIZ + 1;
			str = mmalloc(size);
			memcpy(str, MMDFSTR, MMDFSIZ);
			len = MMDFSIZ;
			memcpy(str + len, token->t_str, token->t_len + 1);
			len += token->t_len;
			free(token->t_str);
			token->t_str = str;
			token->t_len = len;
		}
		break;
	case I_AAFH:
		/* bad if beginning of file */
		token->t_type = I_SOM;
		if (lastseek)
			return(token);
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_CTRLA_BEGIN,
			"Unexpected Ctrl-A delimiter at beginning of folder, remove it?"), 1);
		if (ret) {
			str = malloc(token->t_len + 1);
			memcpy(str, token->t_str + MMDFSIZ,
				token->t_len - MMDFSIZ + 1);
			token->t_len -= MMDFSIZ;
			free(token->t_str);
			token->t_str = str;
		}
		break;
	}
	return(token);
}

/*
 * main folder FSM
 */
/* our FSM tables */
unsigned char fsm_output[I_COUNT][S_COUNT] = {
/*                   START     HDR       BODY      */
/* SOM       */ {    O_SOM,    O_EOB,    O_EOM,    },
/* From      */ {    O_MK,     O_PAD,    O_OUTB,    },
/* Hdr       */ {    O_MK,     O_OUTH,   O_OUTB,    },
/* Blank     */ {    O_MK,     O_EOH,    O_OUTB,    },
/* Regular   */ {    O_MK,     O_IEOH,   O_OUTB,    },
/* Ctrl-A EOF*/ {    O_MK,     O_EOB,    O_EOM,    },
/* EOF       */ {    O_NULL,   O_IEOB,   O_IEOM,   },
};

unsigned char fsm_nextstate[I_COUNT][S_COUNT] = {
/*                   START     HDR       BODY      */
/* SOM       */ {    S_HDR,    S_HDR,    S_HDR,    },
/* From      */ {    S_HDR,    S_HDR,    S_BODY,   },
/* Hdr       */ {    S_HDR,    S_HDR,    S_BODY,   },
/* Blank     */ {    S_BODY,   S_BODY,   S_BODY,   },
/* Regular   */ {    S_BODY,   S_BODY,   S_BODY,   },
/* Ctrl-A EOF*/ {    S_DONE,   S_DONE,   S_DONE,   },
/* EOF       */ {    S_DONE,   S_DONE,   S_DONE,   },
};
int
folder_fsm(register token_t *token)
{
	int input;
	int output;
	int nextstate;

	int ret;

	input = token->t_type;
	output = fsm_output[input][fsm_state];
	nextstate = fsm_nextstate[input][fsm_state];

	/*
	debug("line %d input %d state %d output %d next %d\n", lastline, input, fsm_state, output, nextstate);
	debug("<%s>\n", token->t_str);
	*/

	switch (output) {
	case O_NULL:
		break;
	case O_SOM:	/* start of first message found */
		/* open hdr file */
		hfd = fopen(hfile, "w");
		if (hfd == 0) {
			printf(MSGSTR(SCO_MFCK_ERR_CREATE,
				"Unable to create %s\n"), hfile);
			die(1);
		}
		curmsg++;
		/* output it */
		fwrite(token->t_str, 1, token->t_len, hfd);
		break;
	case O_MK:	/* start of first message not found, make it */
		/* open hdr file */
		hfd = fopen(hfile, "w");
		if (hfd == 0) {
			printf(MSGSTR(SCO_MFCK_ERR_CREATE,
				"Unable to create %s\n"), hfile);
			die(1);
		}
		curmsg++;
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_GARBLED,
			"Start of first message garbled, fix it?"), 1);
		if (ret == 0) {
			/* just output current token */
			fwrite(token->t_str, 1, token->t_len, hfd);
			break;
		}
		/* do different things based on current token */
		switch (token->t_type) {
		case I_F:	/* lone from line, no header, no Ctrl-A */
			if (folder_mmdf)
				fputs(MMDFSTR, hfd);
			fwrite(token->t_str, 1, token->t_len, hfd);
			fprintf(hfd, "Subject: repaired message (mfck)\n");
			break;
		case I_H:	/* header line, no From */
			if (folder_mmdf)
				fputs(MMDFSTR, hfd);
			fprintf(hfd, makefrom());
			fwrite(token->t_str, 1, token->t_len, hfd);
			break;
		case I_B:	/* blank line, header missing completely */
			if (folder_mmdf)
				fputs(MMDFSTR, hfd);
			fprintf(hfd, makefrom());
			fprintf(hfd, "Subject: repaired message (mfck)\n");
			fwrite(token->t_str, 1, token->t_len, hfd);
			/* must do end of header processing here */
			fclose(hfd);
			hfd = 0;
			bfd = fopen(bfile, "w");
			if (bfd == 0) {
				printf(MSGSTR(SCO_MFCK_ERR_CREATE,
					"Unable to create %s\n"), bfile);
				die(1);
			}
			break;
		case I_R:	/* regular line, header missing */
			if (folder_mmdf)
				fputs(MMDFSTR, hfd);
			fprintf(hfd, makefrom());
			fprintf(hfd, "Subject: repaired message (mfck)\n");
			fprintf(hfd, "\n");
			/* must do end of header processing here */
			fclose(hfd);
			hfd = 0;
			bfd = fopen(bfile, "w");
			if (bfd == 0) {
				printf(MSGSTR(SCO_MFCK_ERR_CREATE,
					"Unable to create %s\n"), bfile);
				die(1);
			}
			fwrite(token->t_str, 1, token->t_len, bfd);
			break;
		case I_AE:	/* almost empty file, make it really empty */
			/* just do nothing to eat the token */
			tokfree(token);
			token = 0;
			break;
		}
		break;
	case O_IEOH:	/* insert end of header (blank line) */
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_MISSING_END,
			"Missing end of header, insert it?"), 1);
		if (ret)
			fputc('\n', hfd);
	case O_EOH:	/* end of header found */
		if (token->t_type == I_B) {
			fwrite(token->t_str, 1, token->t_len, hfd);
			contentsob = curseek;
		}
		else
			contentsob = curseek - token->t_len;
		fclose(hfd);
		hfd = 0;
		do_eoh();	/* content-length check */
		bfd = fopen(bfile, "w");
		if (bfd == 0) {
			printf(MSGSTR(SCO_MFCK_ERR_CREATE,
				"Unable to create %s\n"), bfile);
			die(1);
		}
		if (token->t_type != I_B)
			fwrite(token->t_str, 1, token->t_len, bfd);
		break;
	case O_EOB:	/* end of both (end of message while in header) */
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_MISSING_END,
			"Missing end of header, insert it?"), 1);
		if (ret)
			fputc('\n', hfd);
		fclose(hfd);
		hfd = 0;
	case O_EOM:	/* end of message found */
		if (bfd) {
			fclose(bfd);
			bfd = 0;
		}
		do_eom();	/* fix Content-Length and copy msg to ofd */
		/* start a new message */
		if (nextstate != S_DONE) {
			hfd = fopen(hfile, "w");
			if (hfd == 0) {
				printf(MSGSTR(SCO_MFCK_ERR_CREATE,
					"Unable to create %s\n"), hfile);
				die(1);
			}
			/* output current token to new header file */
			fwrite(token->t_str, 1, token->t_len, hfd);
			curmsg++;
		}
		break;
	case O_PAD:	/* pad the current From token and output */
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_EXTRA_FROM,
			"Unpadded extra From line in header, pad it?"), 1);
		if (ret)
			fputc('>', hfd);
	case O_OUTH:	/* output current token to hdr file */
		fwrite(token->t_str, 1, token->t_len, hfd);
		break;
	case O_OUTB:	/* output current token to body file */
		fwrite(token->t_str, 1, token->t_len, bfd);
		break;
	case O_IEOM:	/* insert end of message (mmdf and EOF only) */
		if (bfd) {
			fclose(bfd);
			bfd = 0;
		}
		do_eom();
		if (folder_mmdf) {
			ret = prompt(lastline, 
				MSGSTR(SCO_MFCK_MSG_MISSING_CTRLA_LINE,
				"Missing Ctrl-A line, insert it?"), 1);
			if (ret)
				fputs(MMDFSTR, ofd);
		}
		break;
	case O_IEOB:	/* insert end of both (mmdf and EOF only) */
		ret = prompt(lastline, MSGSTR(SCO_MFCK_MSG_MISSING_END,
			"Missing end of header, insert it?"), 1);
		if (ret)
			fputc('\n', hfd);
		if (hfd) {
			fclose(hfd);
			hfd = 0;
		}
		do_eom();
		if (folder_mmdf) {
			ret = prompt(lastline,
				MSGSTR(SCO_MFCK_MSG_MISSING_CTRLA_LINE,
				"Missing Ctrl-A line, insert it?"), 1);
			if (ret)
				fputs(MMDFSTR, ofd);
		}
		break;
	}
	fsm_state = nextstate;
	if (fsm_state == S_DONE) {
		if (token && token->t_str[0])
			fwrite(token->t_str, 1, token->t_len, ofd);
	}
}

/*
 * process end of header (going on to body) event for FSM
 * primarily a content length check.
 */
do_eoh()
{
	token_t *token;
	int a, b, c, d, e, f, g;
	int good;

	if (contentlength == 0)
		return;
	/* save our globals */
	a = lastline;
	b = lastseek;
	c = curseek;
	d = curline;
	e = contentlength;
	f = contentsob;
	g = contentseek;

	contentlength = 0;
	contentseek = 0;
	curseek = contentsob + e;
	token = parse_token();

	lastline = a;
	lastseek = b;
	curseek = c;
	curline = d;
	contentlength = e;
	contentsob = f;
	contentseek = g;

	good = 0;
	switch (token->t_type) {
	/* sendmail */
	case I_SOM:
	case I_EOF:
		if (folder_mmdf == 0)
			good = 1;
		break;
	/* MMDF */
	case I_AE:
	case I_AFH:
	case I_AAFH:
		if (folder_mmdf)
			good = 1;
		break;
	/* both */
	case I_FH:
		good = 1;
		break;
	default:
		break;
	}
	/* valid content length */
	if (good) {
		contentseek = contentsob + contentlength;
	}
	else {
		contentlength = 0;
		contentseek = 0;
	}
	tokfree(token);	
}

/*
 * process end of message event for FSM.
 * hfd and bfd are expected to be closed before entry.
 * fix Content-Length and copy msg to ofd.
 */
void
do_eom()
{
	FILE *fd;
	int len;
	int len1;
	struct stat statb;
	int bodysize;

	bodysize = 0;
	if (stat(bfile, &statb) == 0)
		bodysize = statb.st_size;

	/* copy back header */
	fd = fopen(hfile, "r");
	if (fd == 0) {
		printf(MSGSTR(SCO_MFCK_ERR_REOPEN,
			"Unable to reopen %s\n"), hfile);
		die(1);
	}
	/*
	 * look ahead to check for last header line
	 * we are guaranteed that all headers have trailing newlines
	 * if the user answers yes to questions
	 */
	len = 0;
	while (len1 = msc1_fgets(buf1, BUFSIZ, fd)) {
		/* output old line */
		if (len)
			fwrite(buf, 1, len, ofd);
		memcpy(buf, buf1, len1 + 1);
		len = len1;
	}
	fclose(fd);
	/* last line of header is left in the buffer */

	if ((bodysize && (contentlength == 0)) || (contentlength != bodysize))
		prompt(lastline, MSGSTR(SCO_MFCK_MSG_CONTENT_LENGTH,
			"Missing/Bad Content-Length header, fix?"), 1);
	/* we always put one in, above check tries to inform user when
	   we added or changed it */
	fprintf(ofd, "Content-Length: %d\n", bodysize);

	/* output last line of header */
	fwrite(buf, 1, len, ofd);
	unlink(hfile);

	if (bodysize) {
		/* copy back body */
		fd = fopen(bfile, "r");
		if (fd == 0) {
			printf(MSGSTR(SCO_MFCK_ERR_REOPEN,
				"Unable to reopen %s\n"), bfile);
			die(1);
		}
		while (len = msc1_fgets(buf, BUFSIZ, fd))
			fwrite(buf, 1, len, ofd);
		fclose(fd);
		unlink(bfile);
	}

	contentlength = 0;
	contentseek = 0;
	contentsob = 0;
}

/*
 * folder type check
 * scan entire folder looking for ctrl-A lines
 * if any found it is MMDF folder.
 * User is warned later if MMDF folder does not start with Ctrl-A
 *
 * returns 1 if MMDF 0 if sendmail, -1 if error
 */
int
folder_type()
{
	int found;	/* found mmdf line */
	struct flock lock;
	int ret;

	printf("\n%s:\n", ifile);
	ifd = fopen(ifile, "r+");
	if (ifd == 0) {
		printf(MSGSTR(SCO_MFCK_ERR_OPEN,
			"Unable to open %s\n"), ifile);
		return(-1);
	}
	lock.l_type = F_WRLCK;
	lock.l_whence = 0;
	lock.l_start = 0;
	lock.l_len = 3;
	lock.l_sysid = 0;
	lock.l_pid = 0;

	ret = fcntl(fileno(ifd), F_SETLK, &lock);
	if (ret != 0) {
		printf(MSGSTR(SCO_MFCK_MSG_LOCKED, "%s is locked\n"), ifile);
		return(-1);
	}

	found = 0;
	while (fgets(buf, BUFSIZ, ifd)) {
		if (strcmp(buf, MMDFSTR) == 0) {
			found = 1;
			break;
		}
	}
	if (found)
		printf(MSGSTR(SCO_MFCK_MSG_MMDF_DETECTED,
			"MMDF Folder Detected.\n"));
	else
		printf(MSGSTR(SCO_MFCK_MSG_SENDMAIL_DETECTED,
			"Sendmail Folder Detected.\n"));
	return(found);
}

/*
 * verify that header is syntactically correct
 * two forms of headers are recognized:
 *     tag: value
 *     >From legal stuff
 */
int
isheader(char *str)
{
	register char *cp;

	cp = str;
	if (strncmp(cp, ">From ", 6) == 0) {
		if (sendmail_parse_from(cp+1, 0, 0, 0))
			return(1);
		return(0);
	}
	if ((*cp == ' ') || (*cp == '\t'))
		return(0);
	while (*cp && (*cp != ' ') && (*cp != '\t') && (*cp != ':'))
		cp++;
	if (*cp == 0)
		return(0);
	while ((*cp == ' ') && (*cp == '\t'))
		cp++;
	if (*cp != ':')
		return(0);
	return(1);
}

/*
 * make up a dummy from line
 */
char *
makefrom()
{
	static char sbuf[80];
	long t;
	char *cp;

	t = time(0);
	cp = ctime(&t);
	sprintf(sbuf, "From unknown %s", cp);
	return(sbuf);
}

void
die(int code)
{
	cleanup();
	exit(code);
}

void
cleanup()
{
	unlink(ofile);
	unlink(hfile);
	unlink(bfile);
}

uchar *
mmalloc(int size)
{
	uchar *cp;

	cp = malloc(size);
	if (cp == 0) {
		printf(MSGSTR(SCO_MFCK_ERR_MALLOC, "Malloc error\n"));
		die(1);
	}
	memset(cp, 0, size);
	return(cp);
}

uchar *
mrealloc(void *cp, int size)
{
	uchar *cp1;
	int len;

	cp1 = realloc(cp, size);
	if (cp1 == 0) {
		printf(MSGSTR(SCO_MFCK_ERR_MALLOC, "Malloc error\n"));
		die(1);
	}
	return(cp1);
}

/*
 * prompt for a change, only count as error and change if told to
 */
int
prompt(int line, char *msg, int count)
{
	int ret;
	int status;
	regex_t re;
	char pbuf[80];
	char *yesstr=MSGSTR(SCO_MFCK_MSG_YES, "yes");
	char *nostr=MSGSTR(SCO_MFCK_MSG_NO, "no");

	if (count)
		errors++;
	if (line)
		printf(MSGSTR(SCO_MFCK_MSG_LINE, "line %d: "), line);
	if (!yesstr) yesstr = "yes";
	if (!nostr) nostr = "no";
	printf("%s [%s]: ", msg, yesstr);
	fflush(stdout);
	if (opt_prompt == PROMPT_YES) {
		printf("%s\n", yesstr);
		if (count)
			changes++;
		fflush(stdout);
		return(1);
	}
	if (opt_prompt == PROMPT_NO) {
		printf("%s\n", nostr);
		fflush(stdout);
		return(0);
	}

	pbuf[0] = 0;
	gets(pbuf);
	if (strlen(pbuf) == 0) {
		if (count)
			changes++;
		return(1);
	}
	if (regcomp(&re, nl_langinfo(YESEXPR), REG_EXTENDED|REG_NOSUB) != 0) {
		return(0);
	}
	status = regexec(&re, pbuf, (size_t)0, NULL, 0);
	regfree(&re);
	if (status == 0) {
		if (count)
			changes++;
		return(1);
	}
	return(0);
}

void
tokfree(token_t *token)
{
	if (token) {
		free(token->t_str);
		free(token);
	}
}

/*
 * is next string a valid integer for atoi
 * (which goes to the first non-int char)
 */
int
isint(uchar *cp)
{
	/* first character must be valid */
	if ((*cp < '0') || (*cp > '9'))
		return(0);
	cp++;
	while (*cp && (*cp != '\n')) {
		if ((*cp < '0') || (*cp > '9'))
			return(0);
		cp++;
	}
	return(1);
}

/*
 * setsig, set our signal handling stuff for mfck
 */
void
setsig()
{
	signal(SIGINT, sigc);
	signal(SIGHUP, sigc);
}

/*
 * unset signal catching
 */
void
clrsig()
{
	signal(SIGINT, SIG_DFL);
	signal(SIGHUP, SIG_DFL);
}

/*
 * signal catcher routine
 */
void
sigc()
{
	clrsig();
	cleanup();
	printf("Interrupted...\n");
	fflush(stdout);
	die(1);
}

void
usage()
{
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_1,
		"Usage for mfck (Mail Folder Check):\n"));
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_2,
		"mfck %s Sendmail/MMDF folders...\n"), "-c");
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_3,
		"   convert mail folders from one format to another\n"));
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_4,
		"mfck [%s | %s] folders...\n"), "-y", "-n");
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_5,
		"   check and repair damaged mail folders\n"));
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_6,
		"   %s answer yes to all repair prompts\n"), "-y");
	printf(MSGSTR(SCO_MFCK_ERR_USAGE_7,
		"   %s answer no to all repair prompts\n"), "-n");
	exit(1);
}

void
main(argc, argv)
char **argv;
{

#ifdef INTL
	setlocale(LC_ALL,"");
	catd = catopen(MF_MFCK,MC_FLAGS);
#endif /* INTL */

	if (argc == 1)
		usage();
	argc--;
	argv++;
	while ((argc > 0) && (**argv == '-')) {
		if (strcmp(*argv, "-c") == 0) {
			if (argc == 0)
				usage();
			argc--;
			argv++;
			if (strcmp(*argv, "MMDF") == 0)
				opt_conv = CONV_MMDF;
			else if (strcmp(*argv, "Sendmail") == 0)
				opt_conv = CONV_SENDMAIL;
			else
				usage();
		}
		else if (strcmp(*argv, "-y") == 0)
			opt_prompt = PROMPT_YES;
		else if (strcmp(*argv, "-n") == 0)
			opt_prompt = PROMPT_NO;
		else
			usage();
		argc--;
		argv++;
	}
	if (argc == 0)
		usage();
	while (argc-- > 0) {
		if (opt_conv == 0)
			mfck(*argv);
		else
			mfconv(*argv);
		argv++;
	}
	exit(0);
}
