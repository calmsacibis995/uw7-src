.TH SFIO 3 "11 November 1992"
.SH NAME
\fBsfio\fR \- safe/fast string/file input/output
.SH SYNOPSIS
.de Tp
.fl
.ne 4
.TP
..
.de Ss
.fl
.ne 4
.SS "\\$1"
..
.ta 1.0i 2.0i 3.0i 4.0i 5.0i
.nf
.ft 5
#include	<sfio.h>
#define ulong	unsigned long
.ft 1
.fi
.Ss "SFIO TYPES"
.nf
.ft 5
Void_t;
Sfio_t, Sfile_t;
Sfdisc_t;
int	(*Sfread_f)(Sfio_t*, Void_t*, int, Sfdisc_t*);
int	(*Sfwrite_f)(Sfio_t*, Void_t*, int, Sfdisc_t*);
long	(*Sfseek_f)(Sfio_t*, long, int, Sfdisc_t*);
int	(*Sfexcept_t)(Sfio_t*, int, Sfdisc_t*);
.ft 1
.fi
.Ss "BIT FLAGS"
.nf
.ft 5
SF_READ
SF_WRITE
SF_STRING
SF_APPEND
SF_LINE
SF_SHARE
SF_PUBLIC
SF_MALLOC
SF_STATIC
SF_IOCHECK
.ft 1
.fi
.Ss "OPENING STREAMS"
.nf
.ft 5
Sfio_t*	sfnew(Sfio_t* f, char* buf, int size, int fd, int flags);
Sfio_t*	sfopen(Sfio_t* f, const char* string, const char* mode);
Sfio_t*	sfpopen(Sfio_t* f, const char* cmd, const char* mode);
Sfio_t*	sftmp(int size);
.ft 1
.fi
.Ss "STREAM DISCIPLINE"
.nf
.ft 5
Sfdisc_t*	sfdisc(Sfio_t* f, Sfdisc_t* disc);
int	sfrd(Sfio_t* f, Void_t* buf, int n, Sfdisc_t* disc);
int	sfwr(Sfio_t* f, Void_t* buf, int n, Sfdisc_t* disc);
long	sfsk(Sfio_t* f, long addr, int offset, Sfdisc_t* disc);
.ft 1
.fi
.Ss "STREAM BUFFERING"
.nf
.ft 5
int	sfclose(Sfio_t* f);
int	sfsync(Sfio_t* f);
int	sfpurge(Sfio_t* f);
Sfio_t*	sfpool(Sfio_t* f, Sfio_t* poolf, int mode);
char*	sfsetbuf(Sfio_t* f, char* buf, int size);
.ft 1
.fi
.Ss "STREAM CONTROL"
.nf
.ft 5
Sfio_t*	sfstack(Sfio_t* base, Sfio_t* top);
Sfio_t* sfswap(Sfio_t* f1, Sfio_t* f2);
char*	sfreserve(Sfio_t* f, int n, int lock);
int	sfpeek(Sfio_t* f, char** bufp, int n); (\fRobsolete\f5)
int	sfpoll(Sfio_t** fa, int n, int timeout); 
long	sfseek(Sfio_t* f, long addr, int offset);
long	sftell(Sfio_t* f);
int	sfsetfd(Sfio_t* f, int fd);
int	sfset(Sfio_t* f, int flags, int i);
.ft 1
.fi
.Ss "STREAM INPUT"
.nf
.ft 5
int	sfgetc(Sfio_t* f);
int	sfungetc(Sfio_t* f, int c);
ulong	sfgetu(Sfio_t* f);
long	sfgetl(Sfio_t* f);
double	sfgetd(Sfio_t* f);
char*	sfgetr(Sfio_t* f, int rsc, int string);
int	sfread(Sfio_t* f, Void_t* buf, int n);
int	sfscanf(Sfio_t* f, const char* format, ...);
int	sfsscanf(const char* s, const char* format, ...);
int	sfvscanf(Sfio_t* f, const char* format, va_list args);
.ft 1
.fi
.Ss "STREAM OUTPUT"
.nf
.ft 5
int	sfputc(Sfio_t* f, int c);
int	sfnputc(Sfio_t* f, int c, int n);
int	sfputu(Sfio_t* f, ulong v);
int	sfputl(Sfio_t* f, long v);
int	sfputd(Sfio_t* f, double v);
int	sfputr(Sfio_t* f, const char* s, int c);
int	sfwrite(Sfio_t* f, const Void_t* buf, int n);
long	sfmove(Sfio_t* fr, Sfio_t* fw, long n, int rsc);
int	sfprintf(Sfio_t* f, const char* format, ...);
int	sfvprintf(Sfio_t* f, const char* format, va_list args);
int	sfsprintf(char* s, int n, const char* format, ...);
char*	sfprints(const char* format, ...);
.ft 1
.fi
.Ss "STREAM STATUS"
.nf
.ft 5
int	sfnotify(void (*notify)(Sfio_t* f, int type, int fd));
long	sfsize(Sfio_t* f);
int	sffileno(Sfio_t* f);
int	sfstacked(Sfio_t* f);
int	sfeof(Sfio_t* f);
int	sferror(Sfio_t* f);
int	sfclrerr(Sfio_t* f);
int	sfclrlock(Sfio_t* f);
.ft 1
.fi
.Ss "SFIO LIBRARIES"
.nf
.ft 5
#include	<sfio_t.h>
#define	SFNEW(buf,size,file,flags,disc)
.ft 1
.fi
.Ss "MISCELLANEOUS"
.nf
.ft 5
int	sfslen();
int	sfulen(ulong v);
int	sfllen(long v);
int	sfdlen(double v);
int	sfpkrd(int fd, char* buf, int n, int rsc, long tm, int peek);
char*	sfecvt(double v, int n, int* decpt, int* sign);
char*	sffcvt(double v, int n, int* decpt, int* sign);
.ft 1
.fi
.SH DESCRIPTION
.PP
\fISfio\fP is a library of functions for efficient I/O on buffered streams.
Each \fIsfio\fP stream is of the type \f5Sfio_t\fP 
and corresponds to either a file descriptor (see \fIopen(2)\fP)
or some memory segment (a string stream).
Among the innovations of \fIsfio\fP are
I/O disciplines for data processing,
stream stacks for recursive stream processing, and
stream pools for auto-synchronization or data serialization.
.PP
During an I/O request,
a system call (\f5read(2), write()\fP or \f5lseek()\fP)
or its discipline replacement may be invoked.
Such a function is said to cause an exception if its return value is non-positive.
An application can handle the exception itself via an exception handler
(see \f5sfdisc()\fP) or leave it to \fIsfio\fP.
In the latter case, \fIsfio\fP examines \f5errno\fP (see \f5errno.h\fP)
for further actions. Typically, if \f5errno\fP is \f5EINTR\fP, the respective
function will be resumed. Otherwise, an error condition is returned.
.PP
There are various circumstances where \fIsfio\fP functions may fail.
For example, during the processing of an IO request on a stream,
the stream is usually locked to prevent concurrent accesses.
Accessing such a locked stream results in error.
In the event of an error, a function that returns integer values will
return \f5-1\fP or some negative value
while a function that returns a pointer value will return \f5NULL\fP.
More details on return values will be given for each function as appropriate.
.PP
For each file stream, to reduce the number of system calls,
a buffer is used to store data.
Normally, this buffer is a memory area allocated by \f5malloc(3)\fP
or some memory area supplied by the application.
On systems with memory mapping (\f5mmap(2)\fP),
memory maps may be used to speed up IO.
It is important that the extent of such a
stream not be truncated while the map is in use; otherwise, memory
access errors (\f5SIGBUS \- signal(3)\fP) can occur. If an application
cannot guarantee this, it should use \f5sfsetbuf()\fP to make sure that
no memory mapping will be used.

.PP
.Ss "SFIO TYPES"
.PP

.Ss "  Void_t*"
This defines a suitable type to use with functions such as \f5sfread()\fP or
\f5sfwrite()\fP that perform IO with objects of types unknown to the
package. \f5Void_t\fP is \f5#define\fPd as \f5void\fP for ANSI-C and C++ and
\f5char\fP for other compilation environments.

.Ss "  Sfio_t, Sfile_t"
.Ss "  Sfdisc_t"
.Ss "  int (*Sfread_f)(Sfio_t*, Void_t*, int, Sfdisc_t*)"
.Ss "  int (*Sfwrite_f)(Sfio_t*, Void_t*, int, Sfdisc_t*)"
.Ss "  long (*Sfseek_f)(Sfio_t*, long, int, Sfdisc_t*)"
.Ss "  int (*Sfexcept_t)(Sfio_t*, int, Sfdisc_t*)"
\f5Sfio_t\fP or \f5Sfile_t\fP defines the type of a stream.
\f5Sfdisc_t\fP is the type of a stream discipline and
contains fields of the types \f5Sfread_f\fP, \f5Sfwrite_f\fP, \f5Sfseek_f\fP,
and \f5Sfexcept_f\fP. These fields define alternative discipline functions
which replace their counterpart system calls to read, write and seek.
See \f5sfdisc()\fP for more details.

.Ss "BIT FLAGS"
A number of bit flags define stream types and control their operations.
They are either set when a stream is initialized or by calling \f5sfset()\fP.
Following are the flags:
.Tp
\f5SF_READ\fP:
The stream is readable.
.Tp
\f5SF_WRITE\fP:
The stream is writable.
.Tp
\f5SF_STRING\fP:
The stream is a string (a byte array) that
is readable if \f5SF_READ\fP is specified and
writable if \f5SF_WRITE\fP is specified.
.Tp
\f5SF_APPEND\fP:
The stream is a file opened for appending data
(see \f5open(2)\fP and \f5fcntl(2)\fP).
This means that data written to the stream is always
appended at the end of the file.
On systems where there is no primitive to specify
at file opening time that a file is opened for append only,
\f5lseek()\fP (or its discipline replacement) will be used on
the file stream to approximate this behavior by always seeking to the
end of the stream before writing out data.
.Tp
\f5SF_LINE\fP:
The stream is line-oriented. For write streams, this means that the
buffer is flushed whenever a new-line character, \f5\en\fP, is output.
For read streams, this means that \f5sfscanf()\fP will specially treat the
matching of \f5\en\fP (see below).
\f5SF_LINE\fP is automatically set for terminal devices.
.Tp
\f5SF_SHARE\fP:
The stream is a file stream accessible by independent entities, e.g.,
multiple processes.
If the stream is seekable and not \f5SF_PUBLIC\fP (see below),
each read or write system call will be
preceded by a \f5lseek()\fP (or its discipline replacement) to ensure that
the logical stream location corresponds to the physical file location.
If the stream is unseekable (e.g., pipes or ttys),
the block and record I/O operations (\f5sfread()\fP, \f5sfwrite()\fP, \f5sfmove()\fP,
\f5sfgetr()\fP, \f5sfputr()\fP, \f5sfreserve()\fP, \f5sfvscanf()\fP
and \f5sfvprintf()\fP)
will ensure that (1) after each write operation, the stream is synchronized and
(2) for each read operation, only the data requested will be read.
Note that this guarantee may not be possible if the underlying operating system
does not provide appropriate support facilities
such as \f5recv(2)\fP or \f5streamio(4)\fP
to peek on incoming data without reading past them.
\f5SF_SHARE\fP is automatically set for the standard streams \f5sfstdin\fP,
\f5sfstdout\fP, and \f5sfstderr\fP if they are pipes or seekable.
.Tp
\f5SF_PUBLIC\fP:
This flag must be used in conjunction with \f5SF_SHARE\fP.
It is automatically turned off for unseekable streams.
For seekable streams, it means that
after a \f5sfsync()\fP call, the next IO operation will cause the
internal stream pointer to align with the current location of the
physical seek pointer. This allows applications involving multiple
processes to schedule and serialize their IO on a shared file descriptor.
.Tp
\f5SF_MALLOC\fP:
The stream buffer was obtained via \f5malloc(3)\fP
and can be reallocated or freed by \fIsfio\fP.
.Tp
\f5SF_STATIC\fP:
The stream structure is not to be freed when closed (\f5sfclose()\fP).
This is frequently used by applications that allocate their own
stream structures (such an application must use the header file \f5sfio_t.h\fP).
.Tp
\f5SF_IOCHECK\fP:
If the stream has a discipline exception function,
this flag causes this function to be called in \f5sfsync()\fP, \f5sfpurge()\fP
and before a call to \f5read()\fP or \f5write()\fP or their discipline equivalent.

.PP
.Ss "OPENING STREAMS"
.PP

.Ss "  Sfio_t* sfnew(Sfio_t* f, char* buf, int size, int fd, int flags)"
This creates or renews a stream.
It returns the new stream on success and \f5NULL\fP on error.
.Tp
\f5f\fP:
If \f5f\fP is \f5NULL\fP, a new stream is created.
Otherwise, it is taken to be an \fIexisting stream\fP to be initialized or renewed.
The initialization case is indicated by the bit \f5SF_EOF\fP in \f5flags\fP.
In this case, the space provided by \f5f\fP simply gets used as if it was just
allocated.
If \f5SF_EOF\fP is not specified,
\f5f\fP will be closed (\f5sfclose()\fP) before renewing.
In this case, its buffer, pool and discipline stack will be preserved.
Note that,
except for \f5sfstdin\fP, \f5sfstdout\fP, \f5sfstderr\fP,
and other \f5SF_STATIC\fP streams,
it is an error to renew a stream already closed since its
space may already been deallocated.
.Tp
\f5buf\fP and \f5size\fP:
These determine a buffering scheme.
See \f5sfsetbuf()\fP for more details.
.Tp
\f5fd\fP:
If \f5SF_STRING\fP is specified, this is ignored.
Otherwise, \f5fd\fP is a file descriptor (e.g., from \f5open(2)\fP)
to use for I/O operations.
.Tp
\f5flags\fP:
This is composed from \f5SF_EOF\fP and
the bit values defined in the \fBBIT FLAGS\fP section.

.Ss "  Sfio_t* sfopen(Sfio_t* f, const char* string, const char* mode)"
This is a high-level function based on \f5sfnew()\fP
to create new streams from files or strings.
It returns the new stream on success and \f5NULL\fP on error.
.Tp
\f5f\fP:
This is treated in the same way as \f5sfnew()\fP treats its counterpart.
.Tp
\f5mode\fP:
This can be composed from the set of letters \f5{r, w, +, s, a}\fP.
\f5r\fP and \f5w\fP specify read and write mode.
\f5+\fP means that the new stream will be opened for both reading and writing.
\f5s\fP specifies that \f5string\fP is a null-terminated
string to be opened for string manipulation.
In this case, \f5string\fP can be \f5NULL\fP and is equivalent to the empty string.
Specifying \f5s\fP alone is equivalent to specifying \f5sr\fP.
If \f5s\fP is not specified, \f5string\fP defines a path name to a file.
\f5a\fP specifies the file to be opened in append mode.
This means that data is always written at the end of the file.

.Ss "  Sfio_t* sfpopen(Sfio_t* f, const char* cmd, const char* mode)"
This function executes a command and
sets up pipes so that data can be communicated
between the application and the resulting child process.
If the stream is open for read/write, then the standard input/output
(file descriptor 0/1) of the child is connected to the application.
If the child process was opened for both read and write,
there will be two different file descriptors associated with the stream.
Therefore, beware that \f5sffileno()\fP may return different values
depending on the type of the last I/O operation done (see also \f5sfset()\fP).
If \f5sfpopen()\fP opens a stream for writing and
the signal handler for \f5SIGPIPE\fP is \f5SIG_DFL\fP (default handling),
it will be set to \f5SIG_IGN\fP. This protects the application from getting killed
on attempts to write to a broken pipe.
\f5sfpopen()\fP returns the new stream or \f5NULL\fP on error.
.Tp
\f5f\fP:
The stream to be renewed (see \f5sfnew()\fP).
.Tp
\f5cmd\fP:
The command to be executed.
.Tp
\f5mode\fP:
This should be composed from \f5r\fP, \f5w\fP and \f5+\fP.

.Ss "  Sfio_t* sftmp(int size)"
This function creates a stream for writing and reading temporary data.
If \f5size\fP is negative, the stream is a pure \f5SF_STRING\fP stream.
If \f5size\fP is zero, the stream is a pure file stream.
Otherwise, the stream is first created as a \f5SF_STRING\fP stream
with a buffer of length \f5size\fP. A discipline is set so that
when this buffer is exhausted, a real temporary file is created.
The temporary file is also created on any attempt to modify this discipline,
e.g., stacking a new discipline on top of it.
\f5sftmp()\fP returns the new stream or \f5NULL\fP on error.

.PP
.Ss "STREAM DISCIPLINE"
.PP
A normal file stream makes use of the system calls \f5read()\fP, \f5write\fP
and \f5lseek()\fP to read, write and position in the underlying file.
Certain applications may implement alternative IO methods
or may further process the data before
handling it to the application or before writing out to the file.
This is done by defining an IO discipline.
The functions in this section are used to manipulate disciplines.

.Ss "  Sfdisc_t* sfdisc(Sfio_t* f, Sfdisc_t* disc)"
This function either pushes a new discipline or pops the top discipline.
The stream \f5f\fP is synchronized before anything is done to the discipline stack.
After the discipline stack has been successfully manipulated,
the current seek location (see \f5sftell()\fP)
and stream extent (see \f5sfsize()\fP) may be updated
to reflect that defined by the top level discipline.
If \f5disc\fP
is \f5SF_POPDISC\fP or \f5(Sfdisc_t*)0\fP, the
top element of the stack, if any, is popped
and its address is returned.
Otherwise, \f5disc\fP is
a new discipline to be pushed onto the discipline stack.
Note that a discipline can be used only on one stream at a time.
An application should take care to allocate different discipline
structures for use with multiple streams. 
.PP
A discipline structure is of the type \f5Sfdisc_t\fP.
It defines alternative functions to
read, write, seek, and handle exceptions.
Note that each file stream starts with the unremovable discipline
consisting of the system calls \f5read()\fP, \f5write()\fP, and \f5lseek()\fP.
\f5Sfdisc_t\fP contains the following public fields:
.nf

      \f5Sfread_f   readf;\fP
      \f5Sfwrite_f  writef;\fP
      \f5Sfseek_f   seekf;\fP
      \f5Sfexcept_f exceptf;\fP
.fi
.PP
The first three fields of \f5Sfdisc_t\fP specify the alternative I/O functions.
If any of them is \f5NULL\fP, it is inherited
from a discipline pushed earlier on the stack.
The arguments to the I/O discipline functions
have the same meaning as that of the
functions \f5sfrd()\fP, \f5sfwr()\fP and \f5sfsk()\fP to be described later.
.PP
The exception function, \f5(*exceptf)()\fP, if supplied is used to announce
to the application certain IO events.
It is called as \f5(*exceptf)(Sfio_t* f, int type, Sfdisc_t* disc)\fP.
Unless noted otherwise, the return value of \f5(*exceptf)()\fP is used
as follows:
.Tp
\f5<0\fP:
The calling function terminates with an appropriate error value.
.Tp
\f5>0\fP:
If the event was raised due to an IO error, the error has been
repaired and the calling function shall continue normally.
.Tp
\f5=0\fP:
The exception handler does not handle the raised event and the calling
function should perform whatever default action as appropriate.
For example, if the stream is on top of a stack (see \f5sfstack()\fP)
and the IO event was a read or write error or end-of-file, then the
stream will be popped and closed.
.PP
Following are the available values for the argument \f5type\fP of \f5(*exceptf)()\fP:
.Tp
\f5SF_READ\fP:
.Tp
\f5SF_WRITE\fP:
These events are always raised after a read or write operation fails.
In this case, \f5sfslen()\fP can be used to get
the return value of the failed operation (which should be nonpositive).
\f5SF_READ\fP and \f5SF_WRITE\fP
are also raised immediately before a read or write operation if
the flag \f5SF_IOCHECK\fP is on.
In this case, \f5sfslen()\fP returns the amount
of data to be processed by the respective IO operation.
In addition, the sign of the return value of \f5(*exceptf)()\fP
has the following meaning. If it is negative,
the stream is not ready for IO and the calling \fIsfio\fP operation will
abort with failure. If it is positive, the stream is ready
for IO but the amount should be restricted to the amount specified.
Finally, if \f5(*exceptf)() returns zero, the IO operation can
be carried out normally.
.Tp
\f5SF_SEEK\fP:
This event is raised when a seek operation fails.
.Tp
\f5SF_NEW\fP:
This event is raised when the stream is about to be closed to be reused
(see \f5sfnew()\fP).
.Tp
\f5SF_CLOSE\fP:
This event is raised when the stream is being closed (see \f5sfclose()\fP).
.Tp
\f5SF_DPUSH\fP:
This event is raised when the
discipline is about to be pushed down by a new discipline.
.Tp
\f5SF_DPOP\fP:
This event is raised when the
discipline is about to be popped from the discipline stack.
.Tp
\f5SF_DPOLL\fP:
This event is raised by
\f5sfpoll()\fP to check to see if the next I/O operation may block.
In this case, a negative return value means the stream will block,
a positive return value means the stream will not block.
A zero return value means that the file descriptor should be treated with
default actions by \f5sfpoll()\fP.
.Tp
\f5SF_DBUFFER\fP:
Before \f5sfdisc()\fP pushes or pops a discipline,
the buffer must be synchronized
so that all write data is flushed and there is no buffered read data.
If this is not possible, \f5SF_DBUFFER\fP will be raised.
In the case of pushing a new discipline, the exception function is called as
\f5(*exceptf)(f,SF_DBUFFER,(Sfdisc_t*)0)\fP and in the case of popping,
it is called as \f5(*exceptf)(f,SF_DBUFFER,disc)\fP where \f5disc\fP is
the discipline being popped. If the return value of \f5exceptf\fP is \f5>0\fP,
the push or pop operation will be allowed to go through.
Otherwise, \f5sfdisc()\fP returns failure.
.Tp
\f5SF_SYNC\fP:
.Tp
\f5SF_PURGE\fP:
These events are enabled only if the flag \f5SF_IOCHECK\fP is set.
They are raised when the application calls \f5sfsync()\fP or \f5sfpurge()\fP
on a stream \f5f\fP whose top discipline has an exception function.
In either case, the respective event is raised only after the IO operation
for synchronizing or purging the stream has been successfully completed.
Note that \f5sfsync()\fP is implicit in a closing operation for a write stream
or a share read stream so \f5SF_SYNC\fP is also raised when such a stream is closed.
Finally, although \f5sfsync((Sfio_t*)0)\fP will synchronize all streams, it does
not cause the \f5SF_SYNC\fP event to be raised on any of the streams.

.Ss "  int sfrd(Sfio_t* f, Void_t* buf, int n, Sfdisc_t* disc)"
.Ss "  int sfwr(Sfio_t* f, Void_t* buf, int n, Sfdisc_t* disc)"
.Ss "  long sfsk(Sfio_t* f, long addr, int offset, Sfdisc_t* disc)"
The discipline stack can be viewed as a set of filters to process incoming data.
These functions provides a safe method for a discipline I/O function to invoke
earlier discipline I/O functions and to properly handle exceptions.
It is not allowed to use them in any other context.
\f5sfrd()\fP and \f5sfwr()\fP return the number of bytes read or written.
\f5sfsk()\fP returns the new seek location.
On error, all three functions return a negative value which should be \f5-1\fP
or the value returned by the exception handler.

.PP
.Ss "STREAM BUFFERING"
.PP

.Ss "  int sfclose(Sfio_t* f)"
This function closes the stream \f5f\fP and possibly frees up its resources.
If \f5f\fP is a stack of streams, all streams on the stack are popped and closed.
If \f5f\fP is a \f5sfpopen\fP-stream,
\f5sfclose()\fP waits until the associated command terminates
and returns its exit status.
\f5SF_READ\fP streams with the \f5SF_SHARE\fP
flag turned on and \f5SF_WRITE\fP streams
are synchronized before closing (see \f5sfsync()\fP).
If the stream \f5f\fP has disciplines, their exception
handlers will be called
with the \f5type\fP argument being one of
\f5SF_CLOSE\fP or \f5SF_NEW\fP (see \f5sfdisc()\fP).
The latter, \f5SF_NEW\fP is used when a stream is being closed via \f5sfnew()\fP
so that it can be reused.
If such an exception handler returns a negative value,
\f5sfclose()\fP will immediately return this value
without further processing of the stream.
If the exception handler returns a positive value,
\f5sfclose()\fP will immediately return a zero value.
Normally, all space associated with a stream is deallocated upon closing.
However, the stream space will be preserved if the \f5SF_STATIC\fP flag is set.
\f5sfclose()\fP returns \f5-1\fP for failure and \f50\fP for success.

.Ss "  int sfsync(Sfio_t* f)"
This function synchronizes the physical file pointer of
\f5f\fP and the logical position in the stream.
For a write stream, this means to write out any buffered data.
For a seekable read stream,
the physical file pointer is moved to align with the stream pointer and,
if the flag \f5SF_SHARE\fP is on, at the next input operation,
the buffer will be refreshed
with data from the underlying file.
If \f5f\fP is the base of a stack of streams, all streams on the stack
are synchronized. Note that a stacked stream can only be synchronized
via its base stream.
If \f5f\fP is in a pool (see \f5sfpool()\fP) but not at the head of the
pool, the head of the pool is synchronized.
\f5sfsync()\fP returns a negative value for failure and \f50\fP for success.

.Ss "  int sfpurge(Sfio_t* f)"
This function throws away all pending data in the buffer of \f5f\fP
unless \f5f\fP is a \f5SF_STRING\fP stream.
Note that if \f5f\fP is an input stream corresponding to an unseekable device
such as a pipe or a terminal, the purged data will not be recoverable.
If \f5f\fP is a \f5sfpopen\fP-stream opened for both read and write,
data of both the read and write pipe ends will be purged.
See also \f5sfset()\fP to selectively turn off read or write mode
if one set of data is to be preserved.
\f5sfpurge()\fP returns \f5-1\fP for failure and \f50\fP for success.

.Ss "  Sfio_t* sfpool(Sfio_t* f, Sfio_t* poolf, int mode)"
Occasionally, it is desirable to coordinate I/O from different streams.
This can be done by pooling streams.
In a pool, only one stream is current and can have buffered data.
All other streams in the pool will be synchronized.
A stream becomes current when it is used for some I/O operation.
On success, \f5sfpool()\fP returns a value as defined below.
On failure, it returns \f5NULL\fP.
.Tp
\f5f\fP and \f5poolf\fP:
If \f5f\fP is \f5NULL\fP,
\f5sfpool()\fP returns the head stream in the pool identified by \f5poolf\fP.
Otherwise, if \f5poolf\fP is \f5NULL\fP, \f5f\fP is deleted from its current pool.
In this case, \f5sfpool()\fP returns some stream from the pool.
Note also that some other stream from the same pool will become current.
If this is not possible, \f5sfpool()\fP will return error.
If both \f5f\fP and \f5poolf\fP are not \f5NULL\fP,
\f5f\fP is deleted from its current pool if necessary
and put into the same pool with \f5poolf\fP.
In this case, \f5poolf\fP is returned.
.Tp
\f5mode\fP:
If \f5poolf\fP is already in a pool, \f5mode\fP is ignored.
Otherwise, \f5mode\fP should be \f50\fP or \f5SF_SHARE\fP.
A \f5SF_SHARE\fP pool must contain all streams capable of being in \f5SF_WRITE\fP mode.
In this case, when a new stream is to become current,
its currently buffered data will be moved to the buffer of the new stream
if there is room.

.Ss "  char* sfsetbuf(Sfio_t* f, char* buf, int size)"
This function changes or inquires about
the buffer of the stream \f5f\fP.
Except for buffer inquiry (see the case \f5size == 0\fP),
the stream will be synchronized before any modification of the buffer.
Upon completion,
if a new buffer is successfully set and the old buffer has not been deallocated,
\f5sfsetbuf()\fP returns the address of the old buffer.
Otherwise, it returns \f5NULL\fP.
After a call to \f5sfsetbuf()\fP,
\f5sfslen()\fP can be used to get the size of the buffer whose address was returned.
.Tp
\f5size < 0\fP:
\fIsfio\fP will pick a buffer size suitable for the stream.
If \f5buf\fP is \f5NULL\fP, \fIsfio\fP will also pick a suitable buffering scheme.
For example, on systems with memory mapping, a memory map may be used to
speed up I/O.
If \f5buf\fP is not \f5NULL\fP, its actual value is ignored
but it signifies that the buffer should be allocated (\f5malloc(3)\fP).
This is often used to avoid memory mapping on
file streams whose underlying files may be truncated during processing.
Such file truncation events can cause memory fault errors if occurred
after a memory map has been established (see \f5mmap(2)\fP for details.)
.Tp
\f5size > 0\fP:
This is the suggested size to use for buffering or memory mapping.
If \f5buf\fP is \f5NULL\fP, \fIsfio\fP will pick a suitable buffering scheme
as discussed above.
If \f5buf\fP is not \f5NULL\fP, then \f5buf\fP and \f5size\fP determine
a buffer of the given size.
.Tp
\f5size == 0\fP:
If \f5buf\fP is \f5NULL\fP, the stream will be unbuffered.
If \f5buf\fP is not \f5NULL\fP, its actual value is ignored but
it tells \f5sfsetbuf()\fP to return the address of the stream buffer.
In this case, no attempt will be made to synchronize the buffer.

.PP
.Ss "STREAM CONTROL"
.PP

.Ss "  Sfio_t* sfstack(Sfio_t* base, Sfio_t* top)"
In certain applications, it is useful to be able to process related streams
in a recursive manner. For example, when a \fIC\fP preprocessor processes
a \f5#include\fP file, it is convenient to be able to treat the content
of such a file as if it is part of the base stream.
This is done by using \f5sfstack()\fP to stack streams.
Every stream stack is identified by the base stream
via which all I/O operations are performed.
However, an I/O operation always takes effect on the top stream.
If an I/O operation is performed and the top stream
reaches the end of file condition or an error condition other than interrupts,
it is automatically popped and closed (see also \f5sfdisc()\fP for alternative
handling of these conditions).
.Tp
\f5base\fP:
This is the base stream of the stack.
.Tp
\f5top\fP:
If this is \f5SF_POPSTACK\fP or \f5(Sfio_t*)0\fP,
the stack is popped and \f5sfstack()\fP returns the popped stream.
Otherwise, \f5top\fP is the pointer to a stream to be pushed on top of the stack.
In this case, the \f5base\fP stream is returned.

.Ss "  Sfio_t* sfswap(Sfio_t* f1, Sfio_t* f2)"
This function swaps the content of the streams \f5f1\fP and \f5f2\fP so that
each will function as the other. This will fail if either stream
is in a stream stack but not being the base stream.
If \f5f2\fP is \f5NULL\fP, it will be allocated.
\f5sfswap()\fP returns \f5f2\fP or its allocated version on success and
\f5NULL\fP on failure.

.Ss "  char* sfreserve(Sfio_t* f, int n, int lock)"
This function reserves a data block.
For a read stream, a data block is a segment of data
and for a write stream, it is a buffer suitable for writing.
For consistency,
a stream opened for both read and write will be treated as if it is a read stream.
On systems where it is possible to peek at incoming data from an unseekable device
(\f5recv(2)\fP or \f5streamio(4)\fP),
\f5sfreserve()\fP will use this feature if the \f5SF_SHARE\fP bit is on and \f5lock\fP
is not zero.
This allows applications that share a common unseekable file
descriptor to peek at incoming data without actually consuming them.
\f5sfreserve()\fP returns the address of data block on success
and \f5NULL\fP on failure.
After a \f5sfreserve()\fP call, whether or not it succeeds,
\f5sfslen()\fP can be used to obtain the maximal size of the (would-be)
available data block.
.Tp
\f5n < 0\fP:
The stream will be filled or flushed as necessary to ensure that a data block
of positive size is available. If this is successful and \f5lock\fP is zero,
the stream I/O position will advance by the size of the available data block.
For example, upon success, \f5sfreserve(f,-1,0)\fP returns the pointer to
a positive size data block in the stream buffer and advances the I/O position by
the size of that block.
.Tp
\f5n == 0\fP:
If \f5lock\fP is zero, the stream will be filled or flushed as necessary to
ensure that a positive-size data block is available.
If \f5lock\fP is non-zero, no fill or flush will be performed.
In either case, the I/O position will not be advanced.
However, if \f5lock\fP is non-zero, the stream will be locked from further access.
Therefore, an application can use \f5sfreserve(f,0,1)\fP to lock a stream.
.Tp
\f5n > 0\fP:
An attempt is made to reserve a data block of size at least \f5n\fP.
If this succeeds and \f5lock\fP is zero, the stream I/O position will advance by \f5n\fP.
.Tp
\f5lock\fP:
If the reservation is successful and \f5lock\fP is non-zero,
the stream I/O position will remain the same and the stream will be locked.
A locked stream remains inaccessible until the application calls
\f5sfread/sfwrite(f,data_block,size)\fP to unlock.
\f5sfread()\fP should be used on read-only stream and
\f5sfwrite()\fP should be used on write-only stream.
A stream in both read and write modes can release the lock with either call.
\f5data_block\fP is the address of the data block returned by \f5sfreserve()\fP.

.Ss "  int sfpeek(Sfio_t* f, char** bufp, int n)"
This function is obsolete and will be deleted in a future release.
It uses \f5sfreserve()\fP to secure a data block confined to
the internal buffer of a stream \f5f\fP.
.Tp
\f5bufp\fP:
If this is \f5NULL\fP, only the size of the available data block is returned.
This is allowed even if the stream is locked.
If this is not \f5NULL\fP, the available data buffer is
returned in \f5*bufp\fP.
.Tp
\f5n\fP:
If \f5n > 0\fP, \f5sfpeek()\fP returns the size of the
maximum available data block and locks the stream from further access.
The lock can be released in a similar fashion to \f5sfreserve()\fP.
If \f5n < 0\fP, \f5sfpeek()\fP advances the stream I/O location by
whichever smaller of \f5n\fP or the available data block and
returns the amount advanced. The stream remains unlocked.
Finally, if\f5n == 0\fP and \f5bufp\fP is not \f5NULL\fP,
\f5*bufp\fP is set to the address of the available data block and
\f5sfpeek()\fP returns \f50\fP. This is done even if the stream is locked.

.Ss "  int sfpoll(Sfio_t** fa, int n, int timeout)"
This function polls a set of streams to see if I/O operations
can be performed on them without blocking.
This is useful for multiplexing I/O over a set of streams.
\f5sfpoll()\fP returns the number of ready streams or \f5-1\fP on failure.
.Tp
\f5fa\fP and \f5n\fP:
These define an array of \f5n\fP streams to be polled.
This array will be modified in place by \f5sfpoll()\fP
so that the ready streams will come first.
.Tp
\f5timeout\fP:
This defines the length of time in milliseconds for \f5sfpoll()\fP
to wait to see if any stream is ready for I/O.
If \f5timeout\fP is negative, \f5sfpoll()\fP will block as long as necessary.
Note that \f5SF_STRING\fP and regular file streams can never block
so they are always ready for I/O.
If a stream with discipline is polled and
its readiness is as yet undetermined (no data in the buffer),
the discipline exception function will be called with \f5SF_DPOLL\fP
before normal actions are taken. See also \f5sfdisc()\fP.

.Ss "  long sfseek(Sfio_t* f, long addr, int offset)"
This function sets a new I/O position for the stream \f5f\fP.
If the stream is a \f5SF_STRING\fP stream and the new
address is beyond the current buffer extent, an \f5SF_SEEK\fP exception
will be raised (see \f5sfdisc()\fP). The discipline exception handler, if any,
can call \f5sfslen()\fP to find out the total buffer size needed.
\f5sfseek()\fP returns the new address or \f5-1\fP on failure.
The new address is determined based on \f5addr\fP and
the following values for \f5offset\fP:
.Tp
\f50\fP or \f5SEEK_SET\fP:
\f5addr\fP is the desired address.
.Tp
\f51\fP or \f5SEEK_CUR\fP:
\f5addr\fP is a relative offset from the current location.
Note that if \f5f\fP was opened for appending (\f5SF_APPEND\fP) and the last operation
done on it was a write operation, the \fIcurrent location\fP is at the physical
end of file.
.Tp
\f52\fP or \f5SEEK_END\fP:
\f5addr\fP is offset from the \fIphysical\fP end of the stream.

.Ss "  long sftell(Sfio_t* f)"
This function returns the current location in the stream \f5f\fP.
As with \f5sfseek()\fP, if \f5f\fP was opened for appending (\f5SF_APPEND\fP)
and the last operation done on it was a write operation,
the current location is at the physical end of file.
If the stream \f5f\fP is unseekable, \f5sftell\fP returns the number of bytes
read from or written to \f5f\fP.
See also \f5sfungetc()\fP.

.Ss "  int sfsetfd(Sfio_t* f, int fd)"
This function changes the file descriptor of the file stream \f5f\fP.
If the change is deemed possible,
\f5sfsetfd()\fP will call \f5(*notify)(f,SF_SETFD,newfd)\fP (see \f5sfnotify()\fP)
before switching
the file descriptor of \f5f\fP to the new file descript \f5newfd\fP.
\f5sfsetfd()\fP returns \f5-1\fP on failure and the new file descriptor on success.
.Tp
\f5fd >= 0\fP:
If the current file descriptor is also non-negative,
it will be changed using \f5dup(3)\fP to a value larger or equal to \f5fd\fP.
Upon a successful change, the previous file descriptor will be closed.
If the current file descriptor is negative, it will be set to \f5fd\fP and
the stream will be reinitialized.
.Tp
\f5fd < 0\fP:
The stream is synchronized (see \f5sfsync()\fP) and its
file descriptor will be set to this value.
Then, except for \f5sfclose()\fP, the stream will be inaccessible to
all other IO operations until
a future \f5sfsetfd()\fP call resets the file descriptor to a non-negative value.
Thus, if the file descriptor of a stream is to be preserved upon
closing, \f5sfsetfd()\fP should be used to set the stream's file descriptor
to a negative value first.

.Ss "  int sfset(Sfio_t* f, int flags, int set)"
This function sets or inquires flags for the stream \f5f\fP.
It returns the previous set of flags or \f50\fP if
the stream is currently unaccessible.
\f5flags\fP defines a collection of flags to be turned on or off
based on whether \f5set\fP is non-zero or zero.
For example, the current set of flags can be obtained via \f5sfset(f,0,0)\fP.
The flags that can be set are:
\f5SF_READ\fP, \f5SF_WRITE\fP,
\f5SF_LINE\fP, \f5SF_SHARE\fP, \f5SF_MALLOC\fP and \f5SF_STATIC\fP.
Note that \f5SF_READ\fP and \f5SF_WRITE\fP can be set only
if the stream was opened as \f5SF_READ|SF_WRITE\fP.
Turning off one of them means that the stream is to be treated as
if it was opened with the other flag exclusively.
It is not possible to turn off both.
An attempt to turn on either \f5SF_READ\fP or \f5SF_WRITE\fP also
cause the stream to set its current I/O mode to the given type.
This is useful when an application needs to make sure that a stream
opened for both read and write be in a specific I/O mode.

.PP
.Ss "STREAM INPUT"
.PP

.Ss "  int sfgetc(Sfio_t* f)"
This function returns a byte from the stream \f5f\fP or \f5-1\fP on end-of-file
or error.

.Ss "  int sfungetc(Sfio_t* f, int c)"
This function pushes the byte \f5c\fP back into the stream \f5f\fP
and makes it available on the next read.
For efficiency, if \f5c\fP matches the byte
immediately before the current byte in the buffer,
the buffer pointer is simply backed up (note the effect on \f5sftell()\fP and
\f5sfseek()\fP). There is no theoretical limit on the number of bytes that
can be pushed back into a stream. Pushed back bytes that were not part of
the buffer as noted will be discarded on any operation that require
buffer synchronization, e.g., \f5sftell()\fP, \f5sfseek()\fP, and \f5sfsync()\fP.
\f5sfungetc()\fP returns \f5c\fP on success and \f5-1\fP on failure.

.Ss "  long sfgetu(Sfio_t* f)"
.Ss "  long sfgetl(Sfio_t* f)"
.Ss "  double sfgetd(Sfio_t* f)"
These functions return respectively
\fIunsigned long\fP, \fIlong\fP, and \fIdouble\fP values
coded by \f5sfputu()\fP, \f5sfputl()\fP, and \f5sfputd()\fP.
On error, they return \f5-1\fP.

.Ss "  char* sfgetr(Sfio_t* f, int rsc, int string)"
This function reads a record of data
and returns the data in some buffer defined by \fIsfio\fP.
This buffer is constructed on a per stream basis so that
calls to \f5sfgetr()\fP on different streams will result in
different buffer areas. On error, \f5sfgetr()\fP returns \f5NULL\fP.
In this case, there may be an incomplete record. Such a record can be
obtained by calling \f5sfgetr()\fP again with a negative value for \f5string\fP.
After a successful call to \f5sfgetr()\fP,
the record length including the record separator (or its \f50\fP replacement)
can be retrieved with \f5sfslen()\fP.
.Tp
\f5f\fP:
This is the stream to read a record from.
.Tp
\f5rsc\fP:
This is the record separator.
Note that reaching end-of-file without finding the record separator is an error
and \f5sfgetr()\fP will return \f5NULL\fP.
.Tp
\f5string\fP:
If \f5string\fP is positive, a \f50\fP byte will replace the record separator
to make it a C string. If \f5string\fP is \f50\fP, the record separator
will be left intact so the returned buffer may or may not be a null-terminated string.
After \f5sfgetr()\fP returns \f5NULL\fP due to an error,
a negative value for \f5string\fP can be used
to retrieve any incomplete record.

.Ss "  int sfread(Sfio_t* f, Void_t* buf, int n)"
This function reads up to \f5n\fP bytes from the stream \f5f\fP and
stores them in the given buffer \f5buf\fP.
It returns the number of bytes actually read or \f5-1\fP on error.

.Ss "  int sfscanf(Sfio_t* f, const char* format,...)"
.Ss "  int sfsscanf(const char* s, const char* format,...)"
.Ss "  int sfvscanf(Sfio_t* f, const char* format, va_list args)"
These functions scan data items from an input source.
\f5sfscanf()\fP scans from the input stream \f5f\fP
while \f5sfsscanf()\fP scans from the input string \f5s\fP.
\f5sfvscanf()\fP is the underlying primitive for the other functions
based on a variable argument format.
The item types are determined from the string \f5format\fP.
These functions return
the number of items successfully scanned or \f5-1\fP on error.
.PP
The predefined scanning  formats are the same as that of
\f5fscanf(3)\fP (UNIX User's Manual).
They are:
\f5i, d, u, o, x, p, n, f, F, e, E, g, G, c, %, s,\fP and \f5[]\fP.
A few modifications described below
extend the usage of these formats.
.PP
Unlike \f5fscanf(3)\fP where the \f5\en\fP character in the \f5format\fP
string is treated as any white space character,
if the input stream is in \f5SF_LINE\fP mode (see \f5sfset()\fP)
the \f5\en\fP character matches white spaces but stops after matching
the first input \f5\en\fP.
This avoids unnecessary blocking
when scanning values from terminals or other unseekable devices
with patterns such as ``\f5%s\en\fP''.
Note that other white space characters in the
format strings, i.e. blanks or tabs, still match any input white
space characters including \f5\en\fP.
.PP
The \f5i\fP and \f5d\fP format are extended to scan numbers with general bases
from \f52\fP to \f564\fP.
The \f5d\fP format can be specified as \f5%[*][width][.base]d\fP where
\f5base\fP is the base for number to be scanned.
For the \f5i\fP format, numbers with general bases are assumed
to be of the form: \f5base#integer\fP.
Here \f5base\fP must be a number in base 10 and \f5integer\fP
is a number in the given base. If \f5base\fP is \f536\fP or less,
the digits for \f5integer\fP can be any combination of \f5[0-9], [a-z], [A-Z]\fP
where upper and lower case digits are not distinguishable.
If \f5base\fP is larger than \f536\fP, the set of digits is:
.nf
    \f50123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_\fP
.fi
.PP
To avoid overwriting array boundary,
the formats \f5c\fP, \f5s\fP, and \f5[]\fP
can be modified with the qualifier \f5l\fP.
Then, immediately after specifying a buffer, the buffer size must also be given.
Note that the buffer size does not affect the scan length.
Rather, only the appropriate amount of scanned data
will be copied, the rest is discarded.
.PP
Scanning is extended with the below formats:
.Tp
\f5%&\fP
This pattern indicates that the next argument in the argument list of
\f5sfscanf()\fP is a function, \f5(*extf)()\fP, to process patterns that are not
predefined.
The prototype of \f5(*extf)()\fP is:
.nf
      \f5int (*extf)(Sfio_t* f, int fmt, int length, char** rv);\fP
.fi
\f5f\fP is the same input stream passed to \f5sfvscanf\fP.
\f5fmt\fP is the pattern to be processed.
\f5length\fP, if non-negative, is the maximum number of input bytes
to be read in processing the pattern,
\f5rv\fP is used to return the address of the value to be assigned.
\f5(*extf)()\fP should return the size of the value to be assigned.
A negative return value from \f5(*extf)()\fP means that the specified pattern
\f5fmt\fP cannot be handled and it will be treated as unmatched.
.Tp
\f5%@\fP
This pattern indicates that the next argument in the argument list \f5args\fP
is a function, \f5(*argf)()\fP, to process the values of matched patterns.
The prototype of \f5(*argf)()\fP is:
.nf
      \f5int (*argf)(int fmt, char* value, int n)\fP;
.fi
If the return value of \f5(*argf)()\fP is negative, the processing
of the current format string will be stopped (see \f5%:\fP below).
\f5fmt\fP determines the type of \f5value\fP: \f5f\fP for \fIfloat\fP,
\f5F\fP for \fIdouble\fP, \f5h\fP for \fIshort\fP, \f5d\fP for \fIint\fP,
\f5D\fP for \fIlong\fP, \f5s\fP for \fIchar*\fP. Any other value for \f5fmt\fP
means that it is an extended pattern and \f5value\fP contains an address
to the scanned value. \f5n\fP contains the size of the object if it is a
primitive type. If the object is \f5char*\fP or the address of the scanned
value of an extended format, \f5n\fP is the length of this object.
.Tp
\f5%:\fP
This pattern indicates that the next two arguments in the argument list
\f5args\fP define a new pair of format string and a list of arguments of
the type \f5va_list*\fP (see \f5varargs.h\fP or \f5stdarg.h\fP).
The new pair is pushed on top of the stack and the scanning process continues with them.
The top pair of format string and argument list is popped when the processing
of the format string is stopped. When a new pair is stacked,
\f5(*argf)()\fP and \f5(*extf)()\fP are inherited.
They are reset when the stack is popped.

.PP
.Ss "STREAM OUTPUT"
.PP

.Ss "  int sfputc(Sfio_t* f, int c)"
This function writes the byte \f5c\fP to the stream \f5f\fP.
It returns \f5c\fP on success and \f5-1\fP on error.

.Ss "  int sfnputc(Sfio_t* f, int c, int n)"
This function tries to write \f5n\fP bytes of \f5c\fP to \f5f\fP.
It returns the number of bytes written or \f5-1\fP on failure.

.Ss "  int sfputu(Sfio_t* f, ulong v)"
.Ss "  int sfputl(Sfio_t* f, long v)"
.Ss "  int sfputd(Sfio_t* f, double v)"
These functions write respectively the
\fIunsigned long\fP, \fIlong\fP, or \fIdouble\fP
value \f5v\fP in a minimal, portable and variable length format.
Portability across two different machines
requires that the bit order in a byte is the same on both machines and
the size of the respective primitive type on the output machine is less than or equal
to that on the input machine.
\f5sfputd()\fP relies on the functions \f5ldexp()\fP and \f5frexp()\fP
(See \fIfrexp.3\fP) for coding.
\f5sfputu()\fP, \f5sfputl()\fP and \f5sfputd()\fP
return the number of bytes output or \f5-1\fP on error.
See also \f5sfulen()\fP, \f5sfllen()\fP and \f5sfdlen()\fP.

.Ss "  int sfputr(Sfio_t* f, const char* s, int rsc)"
This function writes the null-terminated string
\f5s\fP to the stream \f5f\fP.
If \f5rsc\fP is non-negative,
it is a character to be appended after the string has been output.
\f5sfputr()\fP returns the number of bytes written or \f5-1\fP on failure.

.Ss "  int sfwrite(Sfio_t* f, const Void_t* buf, int n)"
This function writes out \f5n\fP bytes from the buffer \f5buf\fP to the
stream \f5f\fP.
If the stream is \f5SF_STRING\fP, and the buffer extent is not large enough,
an \f5SF_WRITE\fP exception is raised. The discipline exception handler,
if any, can call \f5sfslen()\fP to find out the total buffer size needed
for existing as well as data remained to be written.
\f5sfwrite()\fP returns the number of bytes written or \f5-1\fP on failure.

.Ss "  long sfmove(Sfio_t* fr, Sfio_t* fw, long n, int rsc)"
This function moves objects
from the input stream \f5fr\fP to the output stream \f5fw\fP.
An object is either a byte or a record.
The latter is indicated by the record separator \f5rsc\fP if it is non-negative.
If \f5n\fP is non-negative, it indicates the number of objects to move;
otherwise, all of \f5fr\fP will be moved.
If either \f5fr\fP or \f5fw\fP is \f5NULL\fP, it acts
as if it is a stream corresponding to \fI/dev/null\fP.
\f5sfmove()\fP returns the number of objects moved or \f5-1\fP on failure.

.Ss "  int sfprintf(Sfio_t* f, const char* format,...)"
.Ss "  int sfsprintf(char* s, int n, const char* format,...)"
.Ss "  int sfvprintf(Sfio_t* f, const char* format, va_list args)"
.Ss "  char* sfprints(const char* format,...)"
These function write data in the given \f5format\fP to some output source.
\f5sfprintf()\fP and \f5sfvprintf()\fP write to the output stream \f5f\fP.
\f5sfsprintf()\fP writes to the buffer \f5s\fP of size \f5n\fP.
\f5sfprints()\fP constructs the output in some statically allocated area
and returns the address of this area upon completion.
Except for \f5sfprints()\fP which returns a null-terminated string,
the other functions return the number of bytes output or -1 on error.
The length of the string constructed by either \f5sfprints()\fP or \f5sfsprintf()\fP
can be retrieved using \f5sfslen()\fP.
.PP
The predefined formats are that of
\f5fprintf(3)\fP (UNIX User's Manual):
\f5n, s, c, %, h, i, d, p, u, o, x, X, g, G, e, E, f,\fP and \f5F\fP.
A pattern specification is of the form:
\f5%[flag][width].[precision].[base][(type)]z\fP
where \f5z\fP stands for the format type.
.Tp
\f5flag\fP:
The flag characters are \f5\-\fP, \f5+\fP, \fIspace\fP, \f5#\fP, and \f50\fP.
.Tp
\f5width\fP:
This defines the width of the printing field. If the value to be printed has less
characters than the field width it may be padded.
.Tp
\f5precis\fP:
This defines the precision for the conversion.
.Tp
\f5base\fP:
This defines the base of conversion for the formats \f5i\fP, \f5d\fP, and \f5u\fP.
The range for \f5base\fP is from \f52\fP to \f564\fP.
If \f5base\fP is not defined or not within the defined range,
it is taken to be \f510\fP.
The digits to represent numbers are:
.nf
\f501234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@_\fP
.fi
.br
Note that the flag \f5#\fP will cause the output to be
int the format \f5base#number\fP.
For example, the number \fI10\fP printed with
\f5%..2d\fP is \f51010\fP while it will be \f52#1010\fP if printed with \f5%#..2d\fP.
.Tp
\f5(type)\fP:
The characters between the parentheses define some type information
that will be passed on the extension functions defined by the format \f5%@\fP
and \f5%&\fP below. The right parenthesis can be escaped as \f5%)\fP.
.PP
In addition to the standard formats, there are three extended formats:
\f5%&\fP, \f5%@\fP, and \f5%:\fP.
They are described below.
.PP
The \f5%&\fP
pattern indicates that the next argument
is a function, \f5(*extf)()\fP, to interpret patterns not yet defined
by \f5sfprintf()\fP.
The prototype of \f5(*extf)()\fP is:
.nf
\f5int (*extf)(void* value,int fmt,int precis,char** sp,int base,char* type,int n);\fP
.fi
.Tp
\f5value\fP:
This is the value to be formatted.
.Tp
\f5fmt\fP:
This is the pattern to format the value.
.Tp
\f5precis\fP:
This is the amount of precision required.
.Tp
\f5sp\fP:
This is used to return the address of a string containing the formatted value.
If upon returning from \f5(*extf)()\fP, \f5*sp\fP is \f5NULL\fP, the pattern \f5fmt\fP
is treated as if it is not matched.
Otherwise, the return value of \f5(*extf)()\fP, if nonnegative, is taken as the length
of the string returned in \f5sp\fP. If not, the string is considered null-terminated.
The string \f5*sp\fP will be processed as if the pattern \f5`s'\fP was specified.
.Tp
\f5base\fP:
This is the base to format the value.
It should be a value between \f52\fP and \f564\fP.
.Tp
\f5type, n\fP:
\f5type\fP is the string between parentheses that was specified before the
format \f5fmt\fP. \f5n\fP is the length of this string.
.PP
The \f5%@\fP
pattern indicates that the next argument is a function, \f5(*argf)()\fP,
to get arguments. As long as \f5(*argf)()\fP is defined, the argument list is ignored.
The return value of \f5(*argf)()\fP, if negative, stops the processing
of the current format (see also \f5%:\fP).
The prototype of \f5(*argf)()\fP is:
.nf
\f5int (*argf)(int fmt, char* val, char* type, int n)\fP;
.fi
.Tp
\f5fmt\fP:
This defines the pattern to be processed.
In addition to the below patterns, if \f5(*extf)()\fP is defined,
and an undefined pattern is encountered,
\f5(*argf)()\fP will be called with this pattern.
.nf
   \f5@\fP to get a new \f5(*argf)()\fP,
   \f5&\fP to get a new \f5(*extf)()\fP,
   \f51\fP to get a new format string for stacking,
   \f52\fP to get a new argument list for stacking,
   \f5c\fP to get a \f5char\fP,
   \f5h\fP to get a \f5short\fP,
   \f5d\fP to get an \f5int\fP,
   \f5D\fP to get a \f5long\fP,
   \f5n\fP to get a \f5int*\fP,
   \f5N\fP to get a \f5long*\fP,
   \f5f\fP to get a \f5float\fP,
   \f5F\fP to get a \f5double\fP, and
   \f5s\fP to get a \f5char*\fP.
.fi
.Tp
\f5val\fP:
This is used to return the requested value.
.Tp
\f5type, n\fP:
\f5type\fP is the string between parentheses that was specified before the
format \f5fmt\fP. \f5n\fP is the length of this string.
.PP
The \f5%:\fP
pattern indicates that the next two arguments define
a pair of format string and argument list of the type \f5va_list*\fP.
If the argument getting function \f5(*argf)()\fP is already defined,
it is called with the argument \f5fmt\fP being the characters
\f51\fP and \f52\fP for the new format string and argument list respectively.
The new pair is stacked on top and processing continue from there.
The top pair of format string and argument is popped when the format string
is exhausted. When a new pair is pushed, \f5(*argf)()\fP and \f5(*extf)()\fP
are inherited. When a pair is popped, these functions will be reset.

.PP
.Ss "STREAM STATUS"
.PP

.Ss "  int sfnotify((void(*)notify)(Sfio_t*, int, int) )"
This sets a function \f5(*notify)()\fP which is
used to notify the applications of various stream events.
\f5(*notify)(f,type,file)\fP is called with three arguments.
The first and third arguments are the affected stream \f5f\fP
and a file descriptor.
The second argument \f5type\fP is one of the following values:
.Tp
\f5SF_NEW\fP:
The stream is being opened.
.Tp
\f5SF_CLOSE\fP:
The stream is being closed.
.Tp
\f5SF_SETFD\fP:
The file descriptor of the stream is being changed to
the value in the third argument (see \f5sfsetfd()\fP).
.Tp
\f5SF_READ\fP:
The stream fails trying to change to read mode.
.Tp
\f5SF_WRITE\fP:
The stream fails trying to change to write mode.

.Ss "  long sfsize(Sfio_t* f)"
This function returns the size of the stream \f5f\fP (see \f5sfnew()\fP).
If the stream is not seekable or if the size is not determinable,
\f5sfsize()\fP returns \f5-1\fP.

.Ss "  int sffileno(Sfio_t* f)"
This function returns the file descriptor of the stream \f5f\fP.

.Ss "  int sfstacked(Sfio_t* f)"
This function returns 1 or 0 depending on whether or not the stream \f5f\fP has been
stacked.

.Ss "  int sfeof(Sfio_t* f)"
.Ss "  int sferror(Sfio_t* f)"
.Ss "  int sfclrerr(Sfio_t* f)"
\f5sfeof()\fP tells whether or not the previous I/O operation generated
and end-of-file condition.
\f5sferror()\fP tells whether or not the previous I/O operation generated an error.
\f5sfclrerr()\fP clears the end-of-file and error conditions.
Note that even without using \f5sfclrerr()\fP,
the end-of-file and error conditions are also cleared on any successful
I/O operation.

.Ss "  int sfclrlock(Sfio_t* f)"
This function clears any lock on a locked stream.
Though this is unsafe, it is useful for emergency access to a stream.
It returns the current set of flags.

.PP
.Ss "SFIO LIBRARIES"
.PP

.Ss "  #include <sfio_t.h>"
Most applications based on the \fIsfio\fP library only need to include
the header file \f5sfio.h\fP. However, there are circumstances (e.g., debugging)
where an application may require more details about the full \f5Sfio_t\fP
structure. In such cases, the header file \f5sfio_t.h\fP can be used
instead of \f5sfio.h\fP.
Note that applications based on features defined in \f5sfio_t.h\fP
may become invalid whenever the internal architecture of \fIsfio\fP changes.

.Ss "  #define SFNEW(buf,size,file,flags,disc)"
This macro function is defined only in \f5sfio_t.h\fP.
It is used to statically initialize a full \f5Sfio_t\fP structure.
It requires five arguments:
.Tp
\f5buf, size\fP:
These define a buffer for I/O and the size of that buffer.
.Tp
\f5file\fP:
This defines the file descriptor associated with the stream.
.Tp
\f5flags\fP:
This defines the type of the stream. It is composed from the bit flags
as described above.
.Tp
\f5disc\fP:
This defines a discipline associated with the stream (\f5sfdisc()\fP).

.PP
.Ss "MISCELLANEOUS"
.PP

.Ss "  int sfslen()"
This function returns the length of the string most recently obtained
via \f5sfreserve()\fP, \f5sfsetbuf()\fP, \f5sfgetr()\fP,
\f5sfsprintf()\fP, \f5sfprints()\fP, \f5sfecvt()\fP or \f5sffcvt()\fP.
It can also be used during an exception handler to find certain state
information about the I/O operation (see \f5sfdisc()\fP).

.Ss "  int sfulen(ulong v)"
.Ss "  int sfllen(long v)"
.Ss "  int sfdlen(double v)"
These functions return respectively the number of bytes required to code the
\fIunsigned long\fP, \fIlong\fP or \fIdouble\fP value \f5v\fP by \f5sfputu()\fP,
\f5sfputl()\fP or \f5sfputd()\fP.

.Ss "  int sfpkrd(int fd, char* buf, int n, int rsc, long tm, int action)"
This function acts directly on the file descriptor \f5fd\fP.
It does a combination of peeking on incoming data and a time-out read.
Upon success, it returns the number of bytes received.
A return value of \f50\fP means that the end-of-file condition has been detected.
A negative value represents an error.
.Tp
\f5buf\fP, \f5n\fP:
These define a buffer and its size to read data into.
.Tp
\f5rsc\fP:
If \f5>=0\fP, this defines a record separator.
Depending on \f5action\fP, \f5sfpkrd()\fP may read data only up to this record separator.
.Tp
\f5tm\fP:
If \f5>=0\fP, this defines a time interval in milliseconds to wait for incoming data.
.Tp
\f5action\fP:
If \f5action > 0\fP, \f5sfpkrd()\fP will peek on incoming data but
will not read past it. Therefore, a future \f5sfpkrd()\fP or \f5read(2)\fP will see
the same data again. If \f5action == 0\fP, \f5sfpkrd()\fP will not peek.
In addition if \f5rsc >= 0\fP, \f5sfpkrd()\fP guarantees that only a record of
data up to the first appearance of \f5rsc\fP is read.
Finally, if \f5action < 0\fP, on systems with peeking ability,
\f5sfpkrd()\fP guarantees that only a record of data
up to the first appearance of \f5rsc\fP is read. Otherwise,
it will do a single \f5read(fd,buf,n)\fP to fill the buffer.

.Ss "  char* sfecvt(double v, int n, int* decpt, int* sign)"
.Ss "  char* sffcvt(double v, int n, int* decpt, int* sign)"
These functions convert floating point values to ASCII.
They correspond to the standard C library functions \f5ecvt(3)\fP and \f5fcvt(3)\fP.
The length of the conversion string most recently done by
\f5sfecvt()\fP or \f5sffcvt()\fP can be found by \f5sfslen()\fP.

.SH AUTHORS
(Kiem-)Phong Vo (kpv@ulysses.att.com) and  David G. Korn (dgk@ulysses.att.com).
